(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
class AIManager {
    constructor() {
        this.actors = new Array();
        this.registeredAI = new Map_1.default();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    registerActor(actor) {
        this.actors.push(actor);
    }
    removeActor(actor) {
        let index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    }
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    registerAI(name, constr) {
        this.registeredAI.add(name, constr);
    }
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    generateAI(name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw `Cannot create AI with name ${name}, no AI with that name is registered`;
        }
    }
    update(deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(actor => { if (actor.aiActive)
            actor.ai.update(deltaT); });
    }
}
exports.default = AIManager;

},{"../DataTypes/Collections/Map":8}],2:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoapActionStatus = void 0;
const State_1 = __importDefault(require("../../DataTypes/State/State"));
class GoapAction extends State_1.default {
    constructor(parent, actor) {
        super(parent);
        this.actor = actor;
        this._preconditions = new Set();
        this._effects = new Set();
        this._cost = 0;
    }
    /** Cost it takes to complete this action */
    get cost() { return this._cost; }
    set cost(cost) { this._cost = cost; }
    /** Preconditions that have to be satisfied for an action to happen */
    get preconditions() { return Array.from(this._preconditions.values()); }
    ;
    /** Resulting statuses after this action completes */
    get effects() { return Array.from(this._effects.values()); }
    checkPreconditions(status) {
        return Array.from(this._preconditions.values()).every(precondition => status.includes(precondition));
    }
    addPrecondition(status) {
        this._preconditions.add(status);
    }
    addEffect(status) {
        this._effects.add(status);
    }
    finished() {
        this.parent.changeState();
    }
}
exports.default = GoapAction;
var GoapActionStatus;
(function (GoapActionStatus) {
    GoapActionStatus[GoapActionStatus["FAILURE"] = 0] = "FAILURE";
    GoapActionStatus[GoapActionStatus["SUCCESS"] = 1] = "SUCCESS";
    GoapActionStatus[GoapActionStatus["RUNNING"] = 2] = "RUNNING";
})(GoapActionStatus = exports.GoapActionStatus || (exports.GoapActionStatus = {}));

},{"../../DataTypes/State/State":23}],3:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = __importDefault(require("../../DataTypes/Graphs/Graph"));
const Stack_1 = __importDefault(require("../../DataTypes/Collections/Stack"));
const GraphUtils_1 = __importDefault(require("../../Utils/GraphUtils"));
class GoapActionPlanner {
    static plan(status, goal, actions) {
        let graph = new Graph_1.default(true);
        let mapping = new Map();
        //0 is our root
        graph.addNode();
        mapping.set(0, "Start");
        //1 is the goal
        graph.addNode();
        mapping.set(1, "Goal");
        graph.addEdge(1, 1, Number.POSITIVE_INFINITY);
        //Build tree from 0 to 1
        this.buildTree(status, actions, 0, goal, mapping, graph);
        //Run djikstra to find shortest path
        let path = GraphUtils_1.default.djikstra(graph, 0);
        //Push all elements of the plan
        let plan = new Stack_1.default();
        let i = 1;
        while (path[i] !== -1) {
            if (path[i] !== 0) {
                plan.push(mapping.get(path[i]));
            }
            i = path[i];
        }
        return plan;
    }
    static buildTree(status, actions, root, goal, mapping, graph) {
        //For each possible action 
        actions.forEach(action => {
            //Can it be performed?
            if (action.checkPreconditions(status)) {
                //This action can be performed
                //Add effects to currentStatus
                let newStatus = [...status];
                newStatus.push(...action.effects);
                //Check if the new node is the goal
                if (newStatus.includes(goal)) {
                    let newNode = graph.addNode();
                    mapping.set(newNode, action);
                    graph.addEdge(root, newNode, action.cost);
                    graph.addEdge(newNode, 1, 0);
                    return;
                }
                //Add node and edge from root
                let newNode = graph.addNode();
                mapping.set(newNode, action);
                graph.addEdge(root, newNode, action.cost);
                //Recursive call
                let newActions = actions.filter(act => act !== action);
                this.buildTree(newStatus, newActions, newNode, goal, mapping, graph);
            }
        });
    }
}
exports.default = GoapActionPlanner;

},{"../../DataTypes/Collections/Stack":10,"../../DataTypes/Graphs/Graph":13,"../../Utils/GraphUtils":107}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A state for a GoapAI. The "state" is not the same as a state in a state machine, or something of that nature.
 */
class GoapState {
}
exports.default = GoapState;

},{}],5:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = __importDefault(require("../../DataTypes/Collections/Stack"));
const GoapActionPlanner_1 = __importDefault(require("./GoapActionPlanner"));
const Map_1 = __importDefault(require("../../DataTypes/Collections/Map"));
const StateMachineAI_1 = __importDefault(require("../StateMachineAI"));
/**
 * An implementation of basic Goap behavior.
 *
 * GOAP requires a lot of overhead for managing all of the symbols (statuses and goals), the
 * actual goap-actions, and creating the action plans.
 *
 * I've opted to try and extend the StateMachineAI for this class, mostly to try and keep things
 * similar to the StateMachineAI. My StateMachineGoapAI class kind of breaks LSP (Liskov's substitution principle)
 * which cues me into the fact that I should probably make a seperate class.
 *
 * Something I'd like to add is an additional class for managing a set of goals. The goals
 * are pretty similar to statuses, except that goals have some kind off priority associated
 * with them. Not sure how we'd do this.
 *
 * @author Peter Walsh
 */
class StateMachineGoapAI extends StateMachineAI_1.default {
    constructor() {
        super();
        this.statuses = new Map_1.default();
        this.stateMap = new Map_1.default();
        this.stack = new Stack_1.default();
        this.goal = null;
    }
    update(deltaT) {
        super.update(deltaT);
    }
    initialize() {
        // Initialize the AI by building a plan from the the current actions
        this.stack = this.buildPlan();
        this.currentState = this.stack.peek();
        this.currentState.onEnter({});
        this.setActive(true);
    }
    // NOTE; this method might trigger infinite recursion in your GOAP AI - Peteylumpkins
    changeState() {
        // Exit the current state
        let options = this.currentState.onExit();
        // Remove the previous state
        this.stack.pop();
        // If the plan is empty, build a new plan
        if (this.stack.isEmpty()) {
            this.stack = this.buildPlan();
        }
        // Set the current action
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
        }
        // Enter the new action
        this.currentState.onEnter(options);
    }
    buildPlan() {
        // Get all the current statuses
        let statuses = this.currentStatus();
        // Get all the current actions
        let actions = Array.from(this.stateMap.keys()).map(key => this.stateMap.get(key));
        // Create the plan
        return GoapActionPlanner_1.default.plan(statuses, this.goal, actions);
    }
    currentStatus() {
        return Array.from(this.statuses.keys()).filter(stat => this.statuses.get(stat).isSatisfied());
    }
    setGoal(goal) {
        if (!this.statuses.has(goal)) {
            throw new Error("Goal doesn't exist. Make sure your goal is a status for this GOAP AI");
        }
        this.goal = goal;
    }
    addStatus(statusName, status) {
        this.statuses.set(statusName, status);
    }
    addState(stateName, state) {
        super.addState(stateName, state);
    }
}
exports.default = StateMachineGoapAI;

},{"../../DataTypes/Collections/Map":8,"../../DataTypes/Collections/Stack":10,"../StateMachineAI":6,"./GoapActionPlanner":3}],6:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachine_1 = __importDefault(require("../DataTypes/State/StateMachine"));
/**
 * A version of a @reference[StateMachine] that is configured to work as an AI controller for a @reference[GameNode]
 */
class StateMachineAI extends StateMachine_1.default {
    // @implemented
    initializeAI(owner, config) { }
    // @implemented
    destroy() {
        // Get rid of our reference to the owner
        delete this.owner;
        this.receiver.destroy();
    }
    // @implemented
    activate(options) { }
}
exports.default = StateMachineAI;

},{"../DataTypes/State/StateMachine":24}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BinaryHeapSet {
    constructor(compareTo, maxElements = 100) {
        this.ROOT = 0;
        this.MAX_ELEMENTS = maxElements;
        this.heap = new Array(this.MAX_ELEMENTS);
        this.map = new Map();
        this.size = 0;
        this.comp = compareTo;
    }
    push(e) {
        if (!this.map.has(e)) {
            this.heap[this.size] = e;
            this.map.set(e, this.size);
            this.percup(this.size);
            this.size += 1;
        }
    }
    pop() {
        let top = this.peek();
        this.map.delete(this.heap[this.ROOT]);
        this.size -= 1;
        this.heap[this.ROOT] = this.heap[this.size];
        this.percdown(this.ROOT);
        return top;
    }
    peek() {
        return this.heap[this.ROOT];
    }
    isEmpty() {
        return this.size === 0;
    }
    forEach(func) {
        this.heap.forEach(func());
    }
    clear() {
        this.heap.fill(null);
    }
    restore(value) {
        let node = this.map.get(value);
        this.percup(node);
        this.percdown(node);
    }
    has(value) {
        return this.map.has(value);
    }
    toString() {
        let res = "Backing Heap: [";
        for (let i = 0; i < this.size; i++) {
            res += `${this.heap[i]}`;
            if (i < this.size - 1) {
                res += ", ";
            }
        }
        res += "]\nMap: [\n";
        this.map.forEach((val, key) => {
            res += `\t${key} -> ${val}\n`;
        });
        res += "]";
        return res;
    }
    percup(node) {
        let prnt = this.parent(node);
        while (node > this.ROOT && this.comp(this.heap[node], this.heap[prnt]) > 0) {
            this.swap(node, prnt);
            node = prnt;
            prnt = this.parent(node);
        }
    }
    percdown(node) {
        let child = this.lchild(node);
        while (child < this.size) {
            if (child < this.size - 1 && this.comp(this.heap[child], this.heap[child + 1]) <= 0) {
                child += 1;
            }
            if (this.comp(this.heap[child], this.heap[node]) > 0) {
                this.swap(node, child);
                node = child;
                child = this.lchild(node);
            }
            else {
                break;
            }
        }
    }
    parent(node) {
        return Math.floor((node - 1) / 2);
    }
    lchild(node) {
        return node * 2 + 1;
    }
    rchild(node) {
        return node * 2 + 2;
    }
    swap(node1, node2) {
        this.map.set(this.heap[node1], node2);
        this.map.set(this.heap[node2], node1);
        let temp = this.heap[node1];
        this.heap[node1] = this.heap[node2];
        this.heap[node2] = temp;
    }
}
exports.default = BinaryHeapSet;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Associates strings with elements of type T
 */
class Map {
    /** Creates a new map */
    constructor() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    add(key, value) {
        this.map[key] = value;
    }
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    get(key) {
        return this.map[key];
    }
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    set(key, value) {
        this.add(key, value);
    }
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    has(key) {
        return this.map[key] !== undefined;
    }
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    keys() {
        return Object.keys(this.map);
    }
    // @implemented
    forEach(func) {
        Object.keys(this.map).forEach(key => func(key));
    }
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    delete(key) {
        delete this.map[key];
    }
    // @implemented
    clear() {
        this.forEach(key => delete this.map[key]);
    }
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    toString() {
        let str = "";
        this.forEach((key) => str += key + " -> " + this.get(key).toString() + "\n");
        return str;
    }
}
exports.default = Map;

},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FIFO queue with elements of type T
 */
class Queue {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    enqueue(item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    }
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    dequeue() {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        let item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    }
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    peekNext() {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        let item = this.q[this.head];
        return item;
    }
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    hasItems() {
        return this.head !== this.tail;
    }
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    getSize() {
        return this.size;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.q[index]);
        this.size = 0;
        this.head = this.tail;
    }
    // @implemented
    forEach(func) {
        let i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    }
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Queue;

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A LIFO stack with items of type T
 */
class Stack {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    push(item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    }
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    pop() {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    }
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    peek() {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    }
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
    */
    isEmpty() {
        return this.head === -1;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.stack[index]);
        this.head = -1;
    }
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    size() {
        return this.head + 1;
    }
    // @implemented
    forEach(func) {
        let i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    }
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Stack;

},{}],11:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A placeholder function for No Operation. Does nothing
 */
const NullFunc = () => { };
exports.default = NullFunc;

},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A linked-list for the edges in a @reference[Graph].
 */
class EdgeNode {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    constructor(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
}
exports.default = EdgeNode;

},{}],13:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_V = void 0;
const EdgeNode_1 = __importDefault(require("./EdgeNode"));
exports.MAX_V = 10000;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
class Graph {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
    */
    addNode() {
        return this.numVertices++;
    }
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
    */
    addEdge(x, y, weight) {
        let edge = new EdgeNode_1.default(y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1.default(x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    }
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    edgeExists(x, y) {
        let edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    }
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    getEdges(x) {
        return this.edges[x];
    }
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    getDegree(x) {
        return this.degree[x];
    }
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    nodeToString(index) {
        return "Node " + index;
    }
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    toString() {
        let retval = "";
        for (let i = 0; i < this.numVertices; i++) {
            let edge = this.edges[i];
            let edgeStr = "";
            while (edge !== undefined && edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    }
}
exports.default = Graph;

},{"./EdgeNode":12}],14:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = __importStar(require("./Graph"));
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
*/
class PositionGraph extends Graph_1.default {
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        super(directed);
        this.debugRender = () => {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        this.positions = new Array(Graph_1.MAX_V);
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    addPositionedNode(position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    }
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    setNodePosition(index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (let i = 0; i < this.numEdges; i++) {
            let edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    }
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    getNodePosition(index) {
        return this.positions[index];
    }
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    addEdge(x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        let weight = this.positions[x].distanceTo(this.positions[y]);
        super.addEdge(x, y, weight);
    }
    // @override
    nodeToString(index) {
        return "Node " + index + " - " + this.positions[index].toString();
    }
    /**
     * Finds the node in the graph with the position closest to the given position
     * @param position the position
     * @returns the node in the graph that is closest to the given position
     */
    snap(position) {
        let n = this.numVertices;
        let i = 1;
        let index = 0;
        let dist = position.distanceSqTo(this.positions[0]);
        while (i < n) {
            let d = position.distanceSqTo(this.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    }
}
exports.default = PositionGraph;

},{"./Graph":13}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;

},{}],16:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("./Vec2"));
/** A 4x4 matrix0 */
class Mat4x4 {
    constructor() {
        this.mat = new Float32Array([
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ]);
    }
    // Static members
    static get IDENTITY() {
        return new Mat4x4().identity();
    }
    static get ZERO() {
        return new Mat4x4().zero();
    }
    // Accessors
    set _00(x) {
        this.mat[0] = x;
    }
    set(col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
        }
        this.mat[row * 4 + col] = value;
        return this;
    }
    get(col, row) {
        return this.mat[row * 4 + col];
    }
    setAll(...items) {
        this.mat.set(items);
        return this;
    }
    identity() {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    zero() {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    rotate(zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    translate(translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1.default) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    }
    scale(scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1.default) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    mult(other, out) {
        let temp = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let value = 0;
                for (let k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll(...temp);
        }
        else {
            return new Mat4x4().setAll(...temp);
        }
    }
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    static MULT(...mats) {
        // Create a new array
        let temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (let i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    }
    toArray() {
        return this.mat;
    }
    toString() {
        return `|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
            `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
            `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
            `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`;
    }
}
exports.default = Mat4x4;

},{"./Vec2":26}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
class AreaCollision {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    constructor(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
}
exports.default = AreaCollision;

},{}],18:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../Vec2"));
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class Hit {
    constructor() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1.default.ZERO;
        /** The position of the collision */
        this.pos = Vec2_1.default.ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1.default.ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1.default.ZERO;
    }
}
exports.default = Hit;

},{"../Vec2":26}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A container for info about a webGL shader program */
class WebGLProgramType {
    /**
     * Deletes this shader program
     */
    delete(gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    }
}
exports.default = WebGLProgramType;

},{}],20:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Shape_1 = __importDefault(require("./Shape"));
const Vec2_1 = __importDefault(require("../Vec2"));
const MathUtils_1 = __importDefault(require("../../Utils/MathUtils"));
const Circle_1 = __importDefault(require("./Circle"));
const Hit_1 = __importDefault(require("../Physics/Hit"));
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class AABB extends Shape_1.default {
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    constructor(center, halfSize) {
        super();
        this.center = center ? center : new Vec2_1.default(0, 0);
        this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
    }
    /** Returns a point representing the top left corner of the AABB */
    get topLeft() {
        return new Vec2_1.default(this.left, this.top);
    }
    /** Returns a point representing the top right corner of the AABB */
    get topRight() {
        return new Vec2_1.default(this.right, this.top);
    }
    /** Returns a point representing the bottom left corner of the AABB */
    get bottomLeft() {
        return new Vec2_1.default(this.left, this.bottom);
    }
    /** Returns a point representing the bottom right corner of the AABB */
    get bottomRight() {
        return new Vec2_1.default(this.right, this.bottom);
    }
    // @override
    getBoundingRect() {
        return this.clone();
    }
    // @override
    getBoundingCircle() {
        let r = Math.max(this.hw, this.hh);
        return new Circle_1.default(this.center.clone(), r);
    }
    // @deprecated
    getHalfSize() {
        return this.halfSize;
    }
    // @deprecated
    setHalfSize(halfSize) {
        this.halfSize = halfSize;
    }
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return point.x >= this.x - this.hw && point.x <= this.x + this.hw
            && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    intersectPoint(point) {
        let dx = point.x - this.x;
        let px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = point.y - this.y;
        let py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPointSoft(point) {
        return point.x > this.x - this.hw && point.x <= this.x + this.hw
            && point.y > this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    intersectSegment(point, delta, padding) {
        let paddingX = padding ? padding.x : 0;
        let paddingY = padding ? padding.y : 0;
        let scaleX = 1 / delta.x;
        let scaleY = 1 / delta.y;
        let signX = MathUtils_1.default.sign(scaleX);
        let signY = MathUtils_1.default.sign(scaleY);
        let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        let tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        let tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        let hit = new Hit_1.default();
        hit.time = MathUtils_1.default.clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    }
    // @override
    overlaps(other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    }
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    overlapsAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    touchesAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    touchesAABBWithoutCorners(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    overlapArea(other) {
        let leftx = Math.max(this.x - this.hw, other.x - other.hw);
        let rightx = Math.min(this.x + this.hw, other.x + other.hw);
        let dx = rightx - leftx;
        let lefty = Math.max(this.y - this.hh, other.y - other.hh);
        let righty = Math.min(this.y + this.hh, other.y + other.hh);
        let dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    }
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    sweep(velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        let centerX = fromPosition.x + velocity.x / 2;
        let centerY = fromPosition.y + velocity.y / 2;
        let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    }
    // @override
    clone() {
        return new AABB(this.center.clone(), this.halfSize.clone());
    }
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    toString() {
        return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
    }
}
exports.default = AABB;

},{"../../Utils/MathUtils":108,"../Physics/Hit":18,"../Vec2":26,"./Circle":21,"./Shape":22}],21:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../Vec2"));
const AABB_1 = __importDefault(require("./AABB"));
const Shape_1 = __importDefault(require("./Shape"));
/**
 * A Circle
 */
class Circle extends Shape_1.default {
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    constructor(center, radius) {
        super();
        this._center = center ? center : new Vec2_1.default(0, 0);
        this.radius = radius ? radius : 0;
    }
    get center() {
        return this._center;
    }
    set center(center) {
        this._center = center;
    }
    get halfSize() {
        return new Vec2_1.default(this.radius, this.radius);
    }
    get r() {
        return this.radius;
    }
    set r(radius) {
        this.radius = radius;
    }
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    }
    // @override
    getBoundingRect() {
        return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
    }
    // @override
    getBoundingCircle() {
        return this.clone();
    }
    // @override
    overlaps(other) {
        throw new Error("Method not implemented.");
    }
    // @override
    clone() {
        return new Circle(this._center.clone(), this.radius);
    }
    toString() {
        return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
    }
}
exports.default = Circle;

},{"../Vec2":26,"./AABB":20,"./Shape":22}],22:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../Vec2"));
const AABB_1 = __importDefault(require("./AABB"));
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
class Shape {
    get x() {
        return this.center.x;
    }
    get y() {
        return this.center.y;
    }
    get hw() {
        return this.halfSize.x;
    }
    get hh() {
        return this.halfSize.y;
    }
    get top() {
        return this.y - this.hh;
    }
    get bottom() {
        return this.y + this.hh;
    }
    get left() {
        return this.x - this.hw;
    }
    get right() {
        return this.x + this.hw;
    }
    static getTimeOfCollision(A, velA, B, velB) {
        if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    }
    static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
        let posSmaller = A.center;
        let posLarger = B.center;
        let sizeSmaller = A.halfSize;
        let sizeLarger = B.halfSize;
        let firstContact = new Vec2_1.default(0, 0);
        let lastContact = new Vec2_1.default(0, 0);
        let collidingX = false;
        let collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            let relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            let relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    }
}
exports.default = Shape;

},{"../Vec2":26,"./AABB":20}],23:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = __importDefault(require("../../Events/Emitter"));
/**
 * An abstract implementation of a state for a @reference[StateMachine].
 * This class should be extended to allow for custom state behaviors.
 */
class State {
    /**
     * Constructs a new State
     * @param parent The parent StateMachine of this state
     */
    constructor(parent) {
        this.parent = parent;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Tells the state machine that this state has ended, and makes it transition to the new state specified
     * @param stateName The name of the state to transition to
     */
    finished(stateName) {
        this.parent.changeState(stateName);
    }
}
exports.default = State;

},{"../../Events/Emitter":29}],24:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = __importDefault(require("../Collections/Stack"));
const Map_1 = __importDefault(require("../Collections/Map"));
const Receiver_1 = __importDefault(require("../../Events/Receiver"));
const Emitter_1 = __importDefault(require("../../Events/Emitter"));
/**
 * An implementation of a Push Down Automata State machine. States can also be hierarchical
 * for more flexibility, as described in @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/state.html).
 */
class StateMachine {
    /**
     * Creates a new StateMachine
     */
    constructor() {
        this.stack = new Stack_1.default();
        this.stateMap = new Map_1.default();
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.emitEventOnStateChange = false;
    }
    /**
     * Sets the activity state of this state machine
     * @param flag True if you want to set this machine running, false otherwise
     */
    setActive(flag) {
        this.active = flag;
    }
    /**
     * Makes this state machine emit an event any time its state changes
     * @param stateChangeEventName The name of the event to emit
     */
    setEmitEventOnStateChange(stateChangeEventName) {
        this.emitEventOnStateChange = true;
        this.stateChangeEventName = stateChangeEventName;
    }
    /**
     * Stops this state machine from emitting events on state change.
     */
    cancelEmitEventOnStateChange() {
        this.emitEventOnStateChange = false;
    }
    /**
     * Initializes this state machine with an initial state and sets it running
     * @param initialState The name of initial state of the state machine
     */
    initialize(initialState, options) {
        this.stack.push(this.stateMap.get(initialState));
        this.currentState = this.stack.peek();
        this.currentState.onEnter(options);
        this.setActive(true);
    }
    /**
     * Adds a state to this state machine
     * @param stateName The name of the state to add
     * @param state The state to add
     */
    addState(stateName, state) {
        this.stateMap.add(stateName, state);
    }
    /**
     * Changes the state of this state machine to the provided string
     * @param state The string name of the state to change to
     */
    changeState(state) {
        // Exit the current state
        let options = this.currentState.onExit();
        // Make sure the correct state is at the top of the stack
        if (state === "previous") {
            // Pop the current state off the stack
            this.stack.pop();
        }
        else {
            // Retrieve the new state from the statemap and put it at the top of the stack
            this.stack.pop();
            this.stack.push(this.stateMap.get(state));
        }
        // Retreive the new state from the stack
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
        }
        // Enter the new state
        this.currentState.onEnter(options);
    }
    /**
     * Handles input. This happens at the very beginning of this state machine's update cycle.
     * @param event The game event to process
     */
    handleEvent(event) {
        if (this.active) {
            this.currentState.handleInput(event);
        }
    }
    // @implemented
    update(deltaT) {
        // Distribute events
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            this.handleEvent(event);
        }
        // Delegate the update to the current state
        this.currentState.update(deltaT);
    }
}
exports.default = StateMachine;

},{"../../Events/Emitter":29,"../../Events/Receiver":33,"../Collections/Map":8,"../Collections/Stack":10}],25:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Vec2_1 = __importDefault(require("../Vec2"));
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
class Tileset {
    // TODO: Change this to be more general and work with other tileset formats
    constructor(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    initFromTiledData(tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
    }
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    getImageKey() {
        return this.imageKey;
    }
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    getImageOffsetForTile(tileIndex) {
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        return new Vec2_1.default(left, top);
    }
    /**
     * Gets the start index
     * @returns The start index
     */
    getStartIndex() {
        return this.startIndex;
    }
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    getNumRows() {
        return this.numRows;
    }
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    getNumCols() {
        return this.numCols;
    }
    getTileCount() {
        return this.endIndex - this.startIndex + 1;
    }
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    hasTile(tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    }
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor((dataIndex % maxCols) * width * scale.x);
        let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    }
}
exports.default = Tileset;

},{"../../ResourceManager/ResourceManager":89,"../Vec2":26}],26:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("../Utils/MathUtils"));
/**
 * A two-dimensional vector (x, y)
 */
class Vec2 {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    constructor(x = 0, y = 0) {
        /**
         * When this vector changes its value, do something
         */
        this.onChange = () => { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    // Expose x and y with getters and setters
    get x() {
        return this.vec[0];
    }
    set x(x) {
        this.vec[0] = x;
        if (this.onChange) {
            this.onChange();
        }
    }
    get y() {
        return this.vec[1];
    }
    set y(y) {
        this.vec[1] = y;
        if (this.onChange) {
            this.onChange();
        }
    }
    static get ZERO() {
        return new Vec2(0, 0);
    }
    static get INF() {
        return new Vec2(Infinity, Infinity);
    }
    static get UP() {
        return new Vec2(0, -1);
    }
    static get DOWN() {
        return new Vec2(0, 1);
    }
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    magSq() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    normalize() {
        if (this.x === 0 && this.y === 0)
            return this;
        let mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    }
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    normalized() {
        if (this.isZero()) {
            return this;
        }
        let mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    }
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    zero() {
        return this.set(0, 0);
    }
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    setToAngle(angle, radius = 1) {
        this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    }
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    vecTo(other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    }
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    dirTo(other) {
        return this.vecTo(other).normalize();
    }
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    scaleTo(magnitude) {
        return this.normalize().scale(magnitude);
    }
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    scale(factor, yFactor = null) {
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    scaled(factor, yFactor = null) {
        return this.clone().scale(factor, yFactor);
    }
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    rotateCCW(angle) {
        let cs = Math.cos(angle);
        let sn = Math.sin(angle);
        let tempX = this.x * cs - this.y * sn;
        let tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    }
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    copy(other) {
        return this.set(other.x, other.y);
    }
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    inc(a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    }
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    mult(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    div(other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    remainder(other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    }
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    distanceSqTo(other) {
        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
    }
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    distanceTo(other) {
        return Math.sqrt(this.distanceSqTo(other));
    }
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    angleToCCW(other) {
        let dot = this.dot(other);
        let det = this.x * other.y - this.y * other.x;
        let angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    }
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    toString() {
        return this.toFixed();
    }
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    toFixed(numDecimalPoints = 1) {
        return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
    }
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    strictEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    equals(other) {
        let xEq = Math.abs(this.x - other.x) < 0.0000001;
        let yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    }
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    strictIsZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    isZero() {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    }
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    setOnChange(f) {
        this.onChange = f;
    }
    toArray() {
        return this.vec;
    }
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    static lerp(a, b, t) {
        return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
    }
}
exports.default = Vec2;
Vec2.ZERO_STATIC = new Vec2(0, 0);

},{"../Utils/MathUtils":108}],27:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Color_1 = __importDefault(require("../Utils/Color"));
/**
 * A util class for rendering Debug messages to the canvas.
 */
class Debug {
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    static log(id, ...messages) {
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        let message = messages.map((m) => m.toString()).join(" ");
        this.logMessages.add(id, message);
    }
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    static clearLogItem(id) {
        this.logMessages.delete(id);
    }
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    static setNodes(nodes) {
        this.nodes = nodes;
    }
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    static drawBox(center, halfSize, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    static drawCircle(center, radius, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    static drawRay(from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    }
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    static drawPoint(pos, color) {
        let pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    }
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    static setDefaultTextColor(color) {
        this.defaultTextColor = color;
    }
    /**
     * Performs any necessary setup operations on the Debug canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    static initializeDebugCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1.default(width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    }
    /** Clears the debug canvas */
    static clearCanvas() {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    }
    /** Renders the text and nodes sent to the Debug system */
    static render() {
        this.renderText();
        this.renderNodes();
    }
    /** Renders the text sent to the Debug canvas */
    static renderText() {
        let y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach((key) => {
            this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
            y += 30;
        });
    }
    /** Renders the nodes registered with the debug canvas */
    static renderNodes() {
        if (this.nodes) {
            this.nodes.forEach(node => {
                node.debugRender();
            });
        }
    }
}
exports.default = Debug;
/** A map of log messages to display on the screen */
Debug.logMessages = new Map_1.default();
/** The rendering color for text */
Debug.defaultTextColor = Color_1.default.WHITE;

},{"../DataTypes/Collections/Map":8,"../DataTypes/Vec2":26,"../Utils/Color":105}],28:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = __importDefault(require("../Utils/Color"));
// @ignorePage
class Stats extends Object {
    static initStats() {
        let canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        let clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        let fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        let updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        let queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        let br1 = document.createElement("br");
        let br2 = document.createElement("br");
        let br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = document.getElementById("chart-option");
        let option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        let option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        let option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        let option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        let option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        let optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    }
    static updateFPS(fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    }
    static log(key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    }
    static render() {
        // Display stats
        this.drawCharts();
    }
    static drawCharts() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        let paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            let param = this.prevfps;
            let color = Color_1.default.BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            let param = this.prevClearTimes;
            let color = Color_1.default.RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            let param = this.prevFillTimes;
            let color = Color_1.default.GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            let param = this.prevUpdateTimes;
            let color = Color_1.default.CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            let param = this.prevQueryTimes;
            let color = Color_1.default.ORANGE.toString();
            this.drawChart(param, color);
        }
    }
    static drawChart(param, color) {
        this.ctx.strokeStyle = Color_1.default.BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        let max = Math.max(...param);
        let prevX = 10;
        let prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (let i = 1; i < param.length; i++) {
            let fps = param[i];
            let x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
            let y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    }
    static updateSGStats() {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime = this.SGClearTimes.reduce((acc, val) => acc + val) / this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime = this.SGFillTimes.reduce((acc, val) => acc + val) / this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime = this.SGUpdateTimes.reduce((acc, val) => acc + val) / this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime = this.SGQueryTimes.reduce((acc, val) => acc + val) / this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
    }
}
exports.default = Stats;
Stats.NUM_POINTS = 60;
Stats.CANVAS_WIDTH = 300;
Stats.CANVAS_HEIGHT = 300;

},{"../Utils/Color":105}],29:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = __importDefault(require("./EventQueue"));
const GameEvent_1 = __importDefault(require("./GameEvent"));
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
class Emitter {
    /** Creates a new Emitter */
    constructor() {
        this.eventQueue = EventQueue_1.default.getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    fireEvent(eventType, data = null) {
        this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
    }
}
exports.default = Emitter;

},{"./EventQueue":30,"./GameEvent":31}],30:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = __importDefault(require("../DataTypes/Collections/Queue"));
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
class EventQueue {
    constructor() {
        this.MAX_SIZE = 200;
        this.q = new Queue_1.default(this.MAX_SIZE);
        this.receivers = new Map_1.default();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    static getInstance() {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    }
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    addEvent(event) {
        this.q.enqueue(event);
    }
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    subscribe(receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (let t of type) {
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    }
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    unsubscribe(receiver, ...events) {
        this.receivers.forEach(eventName => {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            let index = this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                this.receivers.get(eventName).splice(index, 1);
            }
        });
    }
    // Associate the receiver and the type
    addListener(receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    }
    update(deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            let event = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event.type)) {
                for (let receiver of this.receivers.get(event.type)) {
                    receiver.receive(event);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                    receiver.receive(event);
                }
            }
        }
    }
}
exports.default = EventQueue;
EventQueue.instance = null;

},{"../DataTypes/Collections/Map":8,"../DataTypes/Collections/Queue":9,"./GameEventType":32}],31:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
class GameEvent {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    constructor(type, data = null) {
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1.default();
        }
        else if (!(data instanceof Map_1.default)) {
            // data is a raw object, unpack
            this.data = new Map_1.default();
            for (let key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    isType(type) {
        return this.type === type;
    }
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    toString() {
        return this.type + ": @" + this.time;
    }
}
exports.default = GameEvent;

},{"../DataTypes/Collections/Map":8}],32:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {recording: AbstractRecording}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
    /**
     * Disables reveiving input from the user for the specified inputs. Has data: {inputs: InputHanlders[]}
     */
    GameEventType["DISABLE_USER_INPUT"] = "disable_user_input";
    /**
     * Enables receiving input from the user for the specified inputs. Has data: {inputs: InputHandlers[]}
     */
    GameEventType["ENABLE_USER_INPUT"] = "enable_user_input";
    /**
     * Triggers a scene change. Has data: {scene: new (...args: any) => T extends Scene, init: Record<string, any>}
     */
    GameEventType["CHANGE_SCENE"] = "change_scene";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));

},{}],33:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = __importDefault(require("../DataTypes/Collections/Queue"));
const EventQueue_1 = __importDefault(require("./EventQueue"));
/**
 * Receives subscribed events from the EventQueue.
 */
class Receiver {
    /** Creates a new Receiver */
    constructor() {
        this.MAX_SIZE = 200;
        this.q = new Queue_1.default(this.MAX_SIZE);
    }
    destroy() {
        EventQueue_1.default.getInstance().unsubscribe(this);
    }
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    subscribe(eventTypes) {
        EventQueue_1.default.getInstance().subscribe(this, eventTypes);
        this.q.clear();
    }
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    receive(event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    }
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    getNextEvent() {
        return this.q.dequeue();
    }
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    peekNextEvent() {
        return this.q.peekNext();
    }
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    hasNextEvent() {
        return this.q.hasItems();
    }
    /**
     * Ignore all events this frame
     */
    ignoreEvents() {
        this.q.clear();
    }
}
exports.default = Receiver;

},{"../DataTypes/Collections/Queue":9,"./EventQueue":30}],34:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const EventQueue_1 = __importDefault(require("../Events/EventQueue"));
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
class Input {
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     */
    static initialize(viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1.default();
        Input.keyJustPressed = new Map_1.default();
        Input.keyPressed = new Map_1.default();
        Input.mousePosition = new Vec2_1.default(0, 0);
        Input.mousePressPosition = new Vec2_1.default(0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1.default();
        // Add all keys to the keymap
        for (let entry in keyMap) {
            let name = keyMap[entry].name;
            let keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
        Input.eventQueue = EventQueue_1.default.getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
    }
    static update(deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            let event = Input.receiver.getNextEvent();
            // Handle each event type
            if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event.data.get("position");
                Input.mouseButtonPressed = event.data.get("button");
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    }
    static clearKeyPresses() {
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
    }
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    static isKeyJustPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    static getKeysJustPressed() {
        if (Input.keysDisabled)
            return [];
        let keys = Array();
        Input.keyJustPressed.forEach(key => {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    static isKeyPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    static changeKeyBinding(inputName, keys) {
        Input.keyMap.set(inputName, keys);
    }
    /**
     * Clears all key bindings
     */
    static clearAllKeyBindings() {
        Input.keyMap.clear();
    }
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    static isJustPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let justPressed = false;
            for (let key of keys) {
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    static isPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let pressed = false;
            for (let key of keys) {
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    }
    /**
     *
     * Returns whether or not the mouse was newly pressed Input frame.
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse was just pressed, false otherwise
     */
    static isMouseJustPressed(mouseButton) {
        if (mouseButton !== undefined) {
            return Input.mouseJustPressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
        }
        return Input.mouseJustPressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether or not the mouse is currently pressed
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse is currently pressed, false otherwise
     */
    static isMousePressed(mouseButton) {
        if (mouseButton !== undefined) {
            return Input.mousePressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
        }
        return Input.mousePressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    static didJustScroll() {
        return Input.justScrolled && !Input.mouseDisabled;
    }
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    static getScrollDirection() {
        return Input.scrollDirection;
    }
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    static getMousePosition() {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    }
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePosition() {
        return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
    }
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    static getMousePressPosition() {
        return Input.getMousePosition();
    }
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePressPosition() {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    }
    /**
     * Disables all keypress and mouse click inputs
     */
    static disableInput() {
        Input.keysDisabled = true;
        Input.mouseDisabled = true;
    }
    /**
     * Enables all keypress and mouse click inputs
     */
    static enableInput() {
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
    }
}
exports.default = Input;

},{"../DataTypes/Collections/Map":8,"../DataTypes/Vec2":26,"../Events/EventQueue":30,"../Events/GameEventType":32,"../Events/Receiver":33}],35:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputHandlers = void 0;
const EventQueue_1 = __importDefault(require("../Events/EventQueue"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const GameEvent_1 = __importDefault(require("../Events/GameEvent"));
const GameEventType_1 = require("../Events/GameEventType");
const Receiver_1 = __importDefault(require("../Events/Receiver"));
var InputHandlers;
(function (InputHandlers) {
    InputHandlers[InputHandlers["MOUSE_DOWN"] = 0] = "MOUSE_DOWN";
    InputHandlers[InputHandlers["MOUSE_UP"] = 1] = "MOUSE_UP";
    InputHandlers[InputHandlers["CONTEXT_MENU"] = 2] = "CONTEXT_MENU";
    InputHandlers[InputHandlers["MOUSE_MOVE"] = 3] = "MOUSE_MOVE";
    InputHandlers[InputHandlers["KEY_DOWN"] = 4] = "KEY_DOWN";
    InputHandlers[InputHandlers["KEY_UP"] = 5] = "KEY_UP";
    InputHandlers[InputHandlers["ON_BLUR"] = 6] = "ON_BLUR";
    InputHandlers[InputHandlers["ON_WHEEL"] = 7] = "ON_WHEEL";
})(InputHandlers = exports.InputHandlers || (exports.InputHandlers = {}));
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
class InputHandler {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    constructor(canvas) {
        this.handleMouseDown = (event, canvas) => {
            if (!this.enabled[InputHandlers.MOUSE_DOWN])
                return;
            let pos = this.getMousePosition(event, canvas);
            let button = event.button;
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos, button: button });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = (event, canvas) => {
            if (!this.enabled[InputHandlers.MOUSE_DOWN])
                return;
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = (event, canvas) => {
            if (!this.enabled[InputHandlers.MOUSE_MOVE])
                return;
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = (event) => {
            if (!this.enabled[InputHandlers.KEY_DOWN])
                return;
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = (event) => {
            if (!this.enabled[InputHandlers.KEY_UP])
                return;
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = (event) => {
            if (!this.enabled[InputHandlers.ON_BLUR])
                return;
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (!this.enabled[InputHandlers.ON_WHEEL])
                return;
            let gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1.default.getInstance();
        this.enabled = new Array(...[true, true, true, true, true, true, true, true]);
        canvas.onmousedown = (event) => this.handleMouseDown(event, canvas);
        canvas.onmouseup = (event) => this.handleMouseUp(event, canvas);
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = (event) => this.handleMouseMove(event, canvas);
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe(GameEventType_1.GameEventType.DISABLE_USER_INPUT);
        this.receiver.subscribe(GameEventType_1.GameEventType.ENABLE_USER_INPUT);
    }
    update(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
    }
    handleEvent(event) {
        switch (event.type) {
            case GameEventType_1.GameEventType.DISABLE_USER_INPUT: {
                this.disableHandlers(event.data.get("inputs"));
                break;
            }
            case GameEventType_1.GameEventType.ENABLE_USER_INPUT: {
                this.enableHandlers(event.data.get("inputs"));
                break;
            }
            default: {
                throw new Error(`Unhandled event with type: ${event.type} caught in InputHandler.ts`);
            }
        }
    }
    enableHandlers(handlers) {
        handlers.forEach(handler => this.enabled[handler] = true);
    }
    disableHandlers(handlers) {
        handlers.forEach(handler => this.enabled[handler] = false);
    }
    getKey(keyEvent) {
        return keyEvent.key.toLowerCase();
    }
    getMousePosition(mouseEvent, canvas) {
        let rect = canvas.getBoundingClientRect();
        let x = mouseEvent.clientX - rect.left;
        let y = mouseEvent.clientY - rect.top;
        return new Vec2_1.default(x, y);
    }
}
exports.default = InputHandler;

},{"../DataTypes/Vec2":26,"../Events/EventQueue":30,"../Events/GameEvent":31,"../Events/GameEventType":32,"../Events/Receiver":33}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
class EnvironmentInitializer {
    static setup() {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    }
}
exports.default = EnvironmentInitializer;

},{}],37:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GameLoop_1 = __importDefault(require("./GameLoop"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const Stats_1 = __importDefault(require("../Debug/Stats"));
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
class FixedUpdateGameLoop extends GameLoop_1.default {
    constructor() {
        super();
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        this.doFrame = (timestamp) => {
            // If a pause was executed, stop doing the loop.
            if (this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame((t) => this.doFrame(t));
            // If we are trying to render too soon, do nothing.
            if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            this.numUpdateSteps = 0;
            let panic = false;
            while (this.frameDelta >= this.updateTimestep) {
                // Do an update
                this._doUpdate(this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                this.frameDelta -= this.updateTimestep;
                // Increment steps and check if we've done too many
                this.numUpdateSteps++;
                if (this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            this._doRender();
            // Wrap up the frame
            this.finishFrame(panic);
        };
        this.maxUpdateFPS = 60;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        this.frameDelta = 0;
        this.lastFrameTime = 0;
        this.minFrameDelay = 0;
        this.frame = 0;
        this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = 0;
        this.framesSinceLastFpsUpdate = 0;
        this.started = false;
        this.paused = false;
        this.running = false;
        this.numUpdateSteps = 0;
    }
    getFPS() {
        return 0;
    }
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    updateFPS(timestamp) {
        this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1.default.updateFPS(this.fps);
    }
    /**
 * Changes the maximum allowed physics framerate of the game
 * @param initMax The max framerate
 */
    setMaxUpdateFPS(initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    }
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    setMaxFPS(maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    }
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    resetFrameDelta() {
        let oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    }
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    start() {
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame((timestamp) => this.doFirstFrame(timestamp));
        }
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    doFirstFrame(timestamp) {
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame((t) => this.doFrame(t));
    }
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    startFrame(timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    }
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    finishFrame(panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
}
exports.default = FixedUpdateGameLoop;

},{"../Debug/Debug":27,"../Debug/Stats":28,"./GameLoop":39}],38:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = __importDefault(require("../Events/EventQueue"));
const Input_1 = __importDefault(require("../Input/Input"));
const InputHandler_1 = __importDefault(require("../Input/InputHandler"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const Viewport_1 = __importDefault(require("../SceneGraph/Viewport"));
const SceneManager_1 = __importDefault(require("../Scene/SceneManager"));
const AudioManager_1 = __importDefault(require("../Sound/AudioManager"));
const Stats_1 = __importDefault(require("../Debug/Stats"));
const CanvasRenderer_1 = __importDefault(require("../Rendering/CanvasRenderer"));
const Color_1 = __importDefault(require("../Utils/Color"));
const GameOptions_1 = __importDefault(require("./GameOptions"));
const FixedUpdateGameLoop_1 = __importDefault(require("./FixedUpdateGameLoop"));
const EnvironmentInitializer_1 = __importDefault(require("./EnvironmentInitializer"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const RegistryManager_1 = __importDefault(require("../Registry/RegistryManager"));
const WebGLRenderer_1 = __importDefault(require("../Rendering/WebGLRenderer"));
const PlaybackManager_1 = __importDefault(require("../Playback/PlaybackManager"));
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
class Game {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    constructor(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1.default.setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1.default.parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1.default();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = document.getElementById("game-canvas");
        this.DEBUG_CANVAS = document.getElementById("debug-canvas");
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1.default();
        }
        else {
            this.renderingManager = new CanvasRenderer_1.default();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1.default.initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1.default.getInstance();
        this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
        Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1.default.getInstance();
        this.playbackManager = new PlaybackManager_1.default();
    }
    /**
     * Set up the game window that holds the canvases
     */
    initializeGameWindow() {
        const gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    }
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    getSceneManager() {
        return this.sceneManager;
    }
    /**
     * Starts the game
     */
    start(InitialScene, options) {
        // Set the update function of the loop
        this.loop.doUpdate = (deltaT) => this.update(deltaT);
        // Set the render function of the loop
        this.loop.doRender = () => this.render();
        // Preload registry items
        RegistryManager_1.default.preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(() => {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            this.sceneManager.changeToScene(InitialScene, {}, options);
            this.loop.start();
        });
    }
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    update(deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input handler - disabling/enabling user input
            this.inputHandler.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1.default.update(deltaT);
            // Update the recording of the game
            this.playbackManager.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    }
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    render() {
        try {
            // Clear the canvases
            Debug_1.default.clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1.default.isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug render
            if (this.showDebug) {
                Debug_1.default.render();
            }
            if (this.showStats) {
                Stats_1.default.render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    }
}
exports.default = Game;

},{"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Debug/Stats":28,"../Events/EventQueue":30,"../Input/Input":34,"../Input/InputHandler":35,"../Playback/PlaybackManager":68,"../Registry/RegistryManager":71,"../Rendering/CanvasRenderer":77,"../Rendering/WebGLRenderer":82,"../ResourceManager/ResourceManager":89,"../Scene/SceneManager":97,"../SceneGraph/Viewport":101,"../Sound/AudioManager":102,"../Utils/Color":105,"./EnvironmentInitializer":36,"./FixedUpdateGameLoop":37,"./GameOptions":40}],39:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const NullFunc_1 = __importDefault(require("../DataTypes/Functions/NullFunc"));
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
class GameLoop {
    constructor() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1.default;
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1.default;
    }
    set doUpdate(update) {
        this._doUpdate = update;
    }
    set doRender(render) {
        this._doRender = render;
    }
}
exports.default = GameLoop;

},{"../DataTypes/Functions/NullFunc":11}],40:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/** The options for initializing the @reference[GameLoop] */
class GameOptions {
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    static parse(options) {
        let gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    }
}
exports.default = GameOptions;

},{}],41:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GameNode_1 = __importDefault(require("./GameNode"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const AABB_1 = __importDefault(require("../DataTypes/Shapes/AABB"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const Color_1 = __importDefault(require("../Utils/Color"));
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
class CanvasNode extends GameNode_1.default {
    constructor() {
        super();
        /** A flag for whether or not the CanvasNode is visible */
        this.visible = true;
        this._size = new Vec2_1.default(0, 0);
        this._size.setOnChange(() => this.sizeChanged());
        this._scale = new Vec2_1.default(1, 1);
        this._scale.setOnChange(() => this.scaleChanged());
        this._boundary = new AABB_1.default();
        this.updateBoundary();
        this._hasCustomShader = false;
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(a) {
        this._alpha = a;
    }
    get size() {
        return this._size;
    }
    set size(size) {
        this._size = size;
        // Enter as a lambda to bind "this"
        this._size.setOnChange(() => this.sizeChanged());
        this.sizeChanged();
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this._scale = scale;
        // Enter as a lambda to bind "this"
        this._scale.setOnChange(() => this.scaleChanged());
        this.scaleChanged();
    }
    set scaleX(value) {
        this.scale.x = value;
    }
    set scaleY(value) {
        this.scale.y = value;
    }
    get hasCustomShader() {
        return this._hasCustomShader;
    }
    get customShaderKey() {
        return this._customShaderKey;
    }
    // @override
    positionChanged() {
        super.positionChanged();
        this.updateBoundary();
    }
    /** Called if the size vector is changed or replaced. */
    sizeChanged() {
        this.updateBoundary();
    }
    /** Called if the scale vector is changed or replaced */
    scaleChanged() {
        this.updateBoundary();
    }
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    updateBoundary() {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
    }
    get boundary() {
        return this._boundary;
    }
    get sizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.boundary.halfSize.clone().scaled(zoom, zoom);
    }
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    useCustomShader(key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    }
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    contains(x, y) {
        return this._boundary.containsPoint(new Vec2_1.default(x, y));
    }
    // @implemented
    debugRender() {
        Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
        super.debugRender();
    }
}
exports.default = CanvasNode;

},{"../DataTypes/Shapes/AABB":20,"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Utils/Color":105,"./GameNode":42}],42:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenableProperties = void 0;
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const Emitter_1 = __importDefault(require("../Events/Emitter"));
const Region_1 = require("../DataTypes/Interfaces/Region");
const AABB_1 = __importDefault(require("../DataTypes/Shapes/AABB"));
const TweenController_1 = __importDefault(require("../Rendering/Animations/TweenController"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const Color_1 = __importDefault(require("../Utils/Color"));
const Circle_1 = __importDefault(require("../DataTypes/Shapes/Circle"));
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
class GameNode {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    constructor() {
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1.default(0, 0);
        this._position.setOnChange(() => this.positionChanged());
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tweens = new TweenController_1.default(this);
        this.rotation = 0;
    }
    destroy() {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    }
    /*---------- POSITIONED ----------*/
    get position() {
        return this._position;
    }
    set position(pos) {
        this._position = pos;
        this._position.setOnChange(() => this.positionChanged());
        this.positionChanged();
    }
    get relativePosition() {
        return this.inRelativeCoordinates(this.position);
    }
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    inRelativeCoordinates(point) {
        let origin = this.scene.getViewTranslation(this);
        let zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    }
    /*---------- UNIQUE ----------*/
    get id() {
        return this._id;
    }
    set id(id) {
        // id can only be set once
        if (this._id === undefined) {
            this._id = id;
        }
        else {
            throw "Attempted to assign id to object that already has id.";
        }
    }
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    move(velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    }
    ;
    moveOnPath(speed, path) {
        if (this.frozen || path.isDone())
            return;
        this.path = path;
        let dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    }
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    finishMove() {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    }
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = new AABB_1.default();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if ((0, Region_1.isRegion)(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1.default.ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    }
    /** Removes this object from the physics system */
    removePhysics() {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1.default.ZERO;
        this.sweptRect = null;
    }
    /** Disables physics movement for this node */
    freeze() {
        this.frozen = true;
    }
    /** Reenables physics movement for this node */
    unfreeze() {
        this.frozen = false;
    }
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    disablePhysics() {
        this.active = false;
    }
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    enablePhysics() {
        this.active = true;
    }
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    setCollisionShape(collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    }
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    setTrigger(group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        let index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    }
    ;
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    setGroup(group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    }
    // @implemened
    getLastVelocity() {
        return this._velocity;
    }
    /*---------- ACTOR ----------*/
    get ai() {
        return this._ai;
    }
    set ai(ai) {
        if (!this._ai) {
            // If we haven't been previously had an ai, register us with the ai manager
            this.scene.getAIManager().registerActor(this);
        }
        this._ai = ai;
        this.aiActive = true;
    }
    // @implemented
    addAI(ai, options, type) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        // Question, how much do we want different type of AI to be handled the same, i.e. should GoapAI and AI similar methods and signatures for the sake of unity
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    }
    // @implemented
    setAIActive(active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    }
    /*---------- TWEENABLE PROPERTIES ----------*/
    set positionX(value) {
        this.position.x = value;
    }
    set positionY(value) {
        this.position.y = value;
    }
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
    */
    getScene() {
        return this.scene;
    }
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    setLayer(layer) {
        this.layer = layer;
    }
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
    */
    getLayer() {
        return this.layer;
    }
    /** Called if the position vector is modified or replaced */
    positionChanged() {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position.clone().add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    }
    ;
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    update(deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    }
    // @implemented
    debugRender() {
        // Draw the position of this GameNode
        Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
            if (this.isTrigger) {
                color = Color_1.default.MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1.default) {
                Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1.default) {
                Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    }
}
exports.default = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));

},{"../DataTypes/Interfaces/Region":15,"../DataTypes/Shapes/AABB":20,"../DataTypes/Shapes/Circle":21,"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Events/Emitter":29,"../Events/Receiver":33,"../Rendering/Animations/TweenController":75,"../Utils/Color":105}],43:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = __importDefault(require("./CanvasNode"));
const Color_1 = __importDefault(require("../Utils/Color"));
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
class Graphic extends CanvasNode_1.default {
    constructor() {
        super();
        this.color = Color_1.default.RED;
    }
    get alpha() {
        return this.color.a;
    }
    set alpha(a) {
        this.color.a = a;
    }
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    setColor(color) {
        this.color = color;
    }
    set colorR(r) {
        this.color.r = r;
    }
    get colorR() {
        return this.color.r;
    }
    set colorG(g) {
        this.color.g = g;
    }
    get colorG() {
        return this.color.g;
    }
    set colorB(b) {
        this.color.b = b;
    }
    get colorB() {
        return this.color.b;
    }
}
exports.default = Graphic;

},{"../Utils/Color":105,"./CanvasNode":41}],44:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Graphic_1 = __importDefault(require("../Graphic"));
const Line_1 = __importDefault(require("./Line"));
const Color_1 = __importDefault(require("../../Utils/Color"));
class CircleGraph extends Graphic_1.default {
    constructor(center, r) {
        super();
        this.center = center;
        this.r = r;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
        this.buildCircle();
        // Does this really have a meaning for lines?
    }
    buildCircle() {
        for (let i = 0; i <= 2 * Math.PI; i += 0.01) {
            let x = Math.sin(i) + this.r;
            let y = Math.cos(i) + this.r;
            let end = new Vec2_1.default(x, y);
            new Line_1.default(this.center, end);
        }
    }
    set center(pos) {
        this.position = pos;
    }
    get center() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = CircleGraph;

},{"../../DataTypes/Vec2":26,"../../Utils/Color":105,"../Graphic":43,"./Line":46}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
    GraphicType["PARTICLE"] = "PARTICLE";
    GraphicType["CIRCLE"] = "CIRCLE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));

},{}],46:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = __importDefault(require("../Graphic"));
class Line extends Graphic_1.default {
    constructor(start, end) {
        super();
        this.start = start;
        this.end = end;
        this.thickness = 2;
        // Does this really have a meaning for lines?
        this.size.set(5, 5);
    }
    set start(pos) {
        this.position = pos;
    }
    get start() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
}
exports.default = Line;

},{"../Graphic":43}],47:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __importDefault(require("./Point"));
/**
 * - Position X
- Velocity (speed and direction) X
- Color X
- Lifetime
- Age can be handled as lifetime
- Shape X
- Size X
- Transparency X
 */
class Particle extends Point_1.default {
    constructor(position, size, mass) {
        // Are we making this a circle?
        super(position);
        this.inUse = false;
        this.mass = mass;
    }
    setParticleActive(lifetime, position) {
        this.age = lifetime;
        this.inUse = true;
        this.visible = true;
        this.position = position;
    }
    decrementAge(decay) {
        this.age -= decay;
    }
    setParticleInactive() {
        this.inUse = false;
        this.visible = false;
    }
    set velY(y) {
        this.vel.y = y;
    }
    get velY() {
        return this.vel.y;
    }
}
exports.default = Particle;

},{"./Point":48}],48:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = __importDefault(require("../Graphic"));
/** A basic point to be drawn on the screen. */
class Point extends Graphic_1.default {
    constructor(position) {
        // Are we making this a circle?
        super();
        this.position = position;
        this.size.set(5, 5);
    }
}
exports.default = Point;

},{"../Graphic":43}],49:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = __importDefault(require("../Graphic"));
const Color_1 = __importDefault(require("../../Utils/Color"));
/** A basic rectangle to be drawn on the screen. */
class Rect extends Graphic_1.default {
    constructor(position, size) {
        super();
        this.position = position;
        this.size = size;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = Rect;

},{"../../Utils/Color":105,"../Graphic":43}],50:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __importDefault(require("./Sprite"));
const AnimationManager_1 = __importDefault(require("../../Rendering/Animations/AnimationManager"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
/** An sprite with specified animation frames. */
class AnimatedSprite extends Sprite_1.default {
    get cols() {
        return this.numCols;
    }
    get rows() {
        return this.numRows;
    }
    constructor(spritesheet) {
        super(spritesheet.name);
        this.numCols = spritesheet.columns;
        this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        this.animation = new AnimationManager_1.default(this);
        // Add the animations to the animated sprite
        for (let animation of spritesheet.animations) {
            this.animation.add(animation.name, animation);
        }
    }
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    getAnimationOffset(index) {
        return new Vec2_1.default((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
    }
}
exports.default = AnimatedSprite;

},{"../../DataTypes/Vec2":26,"../../Rendering/Animations/AnimationManager":72,"./Sprite":51}],51:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = __importDefault(require("../CanvasNode"));
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
/**
 * The representation of a sprite - an in-game image
 */
class Sprite extends CanvasNode_1.default {
    constructor(imageId) {
        super();
        this.imageId = imageId;
        let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
        this.size = new Vec2_1.default(image.width, image.height);
        this.imageOffset = Vec2_1.default.ZERO;
        this.invertX = false;
        this.invertY = false;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    setImageOffset(offset) {
        this.imageOffset = offset;
    }
}
exports.default = Sprite;

},{"../../DataTypes/Vec2":26,"../../ResourceManager/ResourceManager":89,"../CanvasNode":41}],52:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const CanvasNode_1 = __importDefault(require("./CanvasNode"));
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
class Tilemap extends CanvasNode_1.default {
    // TODO: Make this no longer be specific to Tiled
    constructor(tilemapData, layer, tilesets, scale) {
        super();
        this.tilesets = tilesets;
        this.tileSize = new Vec2_1.default(0, 0);
        this.name = layer.name;
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        let tilecount = 0;
        for (let tileset of tilesets) {
            tilecount += tileset.getTileCount() + 1;
        }
        this.collisionMap = new Array(tilecount);
        for (let i = 0; i < this.collisionMap.length; i++) {
            this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        this.parseTilemapData(tilemapData, layer);
        this.scale.set(scale.x, scale.y);
    }
    get name() { return this._name; }
    set name(name) { this._name = name; }
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    getTile(col, row) {
        let index = this.getTileIndex(col, row);
        if (index === -1) {
            return -1;
        }
        return this.data[index];
    }
    /**
     * Gets the index of the tile in the tilemaps backing array.
     * @param position the position in row-column format in the backing array of the tilemap
     * @returns the index of position in the tilemap
     */
    getTileIndex(col, row) {
        if (col < 0 || col >= this.numCols || row < 0 || row >= this.numRows) {
            return -1;
        }
        return row * this.numCols + col;
    }
    /**
     * Gets the column and row of a tile in the tilemap from the index of the tile
     * in the backing array.
     * @param index the index of the tile in the backing array
     * @return a Vec2 containing the column and row indices of the tile
     */
    getTileColRow(index) {
        let col = index % this.numCols;
        let row = Math.floor(index / this.numCols);
        return new Vec2_1.default(col, row);
    }
    /**
     * Sets the tile at the specified position to the given tile.
     * @param position the row and column of the tile in the backing array
     * @param tile the number of the tile to set
     */
    setTile(col, row, tile) {
        let index = this.getTileIndex(col, row);
        if (index !== -1) {
            this.data[index] = tile;
        }
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    getTilesets() {
        return this.tilesets;
    }
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    getDimensions() {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    // Methods for getting the size of a tile
    /**
     * Gets the raw size of the tiles, without any scaling or zooming.
     * @returns the size of the tiles in this tilemap
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    getScaledTileSize() {
        return this.getTileSize().scaled(this.scale.x, this.scale.y);
    }
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param col the specified column
     * @param row the specified row
     * @returns A flag representing whether or not the tile is collidable.
     */
    isTileCollidable(col, row) {
        if (col < 0 || col >= this.numCols || row < 0 || row >= this.numRows) {
            return false;
        }
        return this.collisionMap[this.getTile(col, row)];
    }
    /**
     * Adds this tilemap to the physics system
     */
    addPhysics() {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    }
}
exports.default = Tilemap;

},{"../DataTypes/Vec2":26,"./CanvasNode":41}],53:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Debug_1 = __importDefault(require("../../Debug/Debug"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const Tilemap_1 = __importDefault(require("../Tilemap"));
class IsometricTilemap extends Tilemap_1.default {
    getMinColRow(region) {
        return new Vec2_1.default(0, 0);
    }
    getMaxColRow(region) {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    getWorldPosition(col, row) {
        if (col < 0 || col > this.numCols || row < 0 || row > this.numRows) {
            return null;
        }
        let vpx = this.scene.getViewport().getHalfSize().x;
        let x = Math.floor(this.scale.x * this.tileSize.x / 2 * (col - row) + vpx);
        let y = Math.floor(this.scale.y * this.tileSize.y / 2 * (col + row));
        return new Vec2_1.default(x, y);
    }
    getTilemapPosition(x, y) {
        let vpx = this.scene.getViewport().getHalfSize().x;
        let col = Math.floor((x - vpx) / this.scale.x / this.tileSize.x + y / this.scale.y / this.tileSize.y);
        let row = Math.floor(y / this.scale.y / this.tileSize.y - (x - vpx) / this.scale.x / this.tileSize.x);
        if (col < 0 || col > this.numCols || row < 0 || row > this.numRows) {
            return null;
        }
        return new Vec2_1.default(col, row);
    }
    getTileCollider(col, row) {
        return;
    }
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    debugRender() {
        for (let tile = 0; tile < this.data.length; tile++) {
            let pos = this.getTileColRow(tile);
            Debug_1.default.drawPoint(this.getWorldPosition(pos.x, pos.y), Color_1.default.BLUE);
        }
    }
}
exports.default = IsometricTilemap;

},{"../../DataTypes/Vec2":26,"../../Debug/Debug":27,"../../Utils/Color":105,"../Tilemap":52}],54:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Tilemap_1 = __importDefault(require("../Tilemap"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Debug_1 = __importDefault(require("../../Debug/Debug"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const AABB_1 = __importDefault(require("../../DataTypes/Shapes/AABB"));
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
class OrthogonalTilemap extends Tilemap_1.default {
    getMinColRow(region) {
        return this.getTilemapPosition(region.topLeft.x, region.topLeft.y);
    }
    getMaxColRow(region) {
        return this.getTilemapPosition(region.bottomRight.x, region.bottomRight.y);
    }
    getTilemapPosition(x, y) {
        let col = Math.floor(x / this.tileSize.x / this.scale.x);
        let row = Math.floor(y / this.tileSize.y / this.scale.y);
        return new Vec2_1.default(col, row);
    }
    getWorldPosition(col, row) {
        let x = col * this.tileSize.x * this.scale.x;
        let y = row * this.tileSize.y * this.scale.y;
        return new Vec2_1.default(x, y);
    }
    getTileCollider(col, row) {
        let tileSize = this.getScaledTileSize();
        let centerX = col * tileSize.x + tileSize.x / 2;
        let centerY = row * tileSize.y + tileSize.y / 2;
        let center = new Vec2_1.default(centerX, centerY);
        let halfSize = tileSize.scaled(0.5);
        return new AABB_1.default(center, halfSize);
    }
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    // @override
    update(deltaT) { }
    // @override
    debugRender() {
        for (let i = 0; i < this.data.length; i++) {
            let cr = this.getTileColRow(i);
            if (this.isCollidable && this.isTileCollidable(cr.x, cr.y)) {
                let box = this.getTileCollider(cr.x, cr.y);
                Debug_1.default.drawBox(this.inRelativeCoordinates(box.center), box.halfSize.scale(this.scene.getViewScale()), false, Color_1.default.BLUE);
            }
        }
    }
}
exports.default = OrthogonalTilemap;

},{"../../DataTypes/Shapes/AABB":20,"../../DataTypes/Vec2":26,"../../Debug/Debug":27,"../../Utils/Color":105,"../Tilemap":52}],55:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AABB_1 = __importDefault(require("../../DataTypes/Shapes/AABB"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Debug_1 = __importDefault(require("../../Debug/Debug"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const Tilemap_1 = __importDefault(require("../Tilemap"));
class StaggeredIsometricTilemap extends Tilemap_1.default {
    getTilemapPosition(x, y) {
        let col = x / this.tileSize.x / this.scale.x;
        let row = Math.floor(y / this.tileSize.y / this.scale.y * 2);
        if (row % 2 !== 0) {
            col = (x - this.tileSize.x / this.scale.x / 2) / this.tileSize.x / this.scale.x;
        }
        return new Vec2_1.default(Math.floor(col), row);
    }
    getWorldPosition(col, row) {
        let x = col * this.tileSize.x * this.scale.x;
        let y = row * this.tileSize.y / 2 * this.scale.y;
        if (row % 2 !== 0) {
            x += this.tileSize.x * this.scale.x / 2;
        }
        return new Vec2_1.default(Math.floor(x), Math.floor(y));
    }
    getTileCollider(col, row) {
        let tileSize = this.getScaledTileSize();
        let centerX = col * tileSize.x + tileSize.x / 2;
        let centerY = row * tileSize.y / 2 + tileSize.y + tileSize.y / 2;
        if (row % 2 !== 0) {
            centerX += tileSize.x / 2;
        }
        let center = new Vec2_1.default(centerX, centerY);
        let halfSize = tileSize.scaled(0.5);
        return new AABB_1.default(center, halfSize);
    }
    getMinColRow(region) {
        return new Vec2_1.default(0, 0);
    }
    getMaxColRow(region) {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    debugRender() {
        for (let i = 0; i < this.data.length; i++) {
            let rc = this.getTileColRow(i);
            let box = this.getTileCollider(rc.x, rc.y);
            Debug_1.default.drawBox(this.inRelativeCoordinates(box.center), box.halfSize.scale(this.scene.getViewScale()), false, Color_1.default.BLUE);
        }
    }
}
exports.default = StaggeredIsometricTilemap;

},{"../../DataTypes/Shapes/AABB":20,"../../DataTypes/Vec2":26,"../../Debug/Debug":27,"../../Utils/Color":105,"../Tilemap":52}],56:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = __importDefault(require("./CanvasNode"));
const Color_1 = __importDefault(require("../Utils/Color"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Input_1 = __importDefault(require("../Input/Input"));
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
class UIElement extends CanvasNode_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.backgroundColor = new Color_1.default(0, 0, 0, 0);
        this.borderColor = new Color_1.default(0, 0, 0, 0);
        this.borderRadius = 5;
        this.borderWidth = 1;
        this.padding = Vec2_1.default.ZERO;
        this.onClick = null;
        this.onClickEventId = null;
        this.onRelease = null;
        this.onReleaseEventId = null;
        this.onEnter = null;
        this.onEnterEventId = null;
        this.onLeave = null;
        this.onLeaveEventId = null;
        this.isClicked = false;
        this.isEntered = false;
    }
    // @deprecated
    // @deprecated
    setPadding(padding) {
        this.padding.copy(padding);
    }
    update(deltaT) {
        super.update(deltaT);
        // See of this object was just clicked
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1.default.isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        let mousePos = Input_1.default.getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    }
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    calculateBackgroundColor() {
        return this.backgroundColor;
    }
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    calculateBorderColor() {
        return this.borderColor;
    }
}
exports.default = UIElement;

},{"../DataTypes/Vec2":26,"../Input/Input":34,"../Utils/Color":105,"./CanvasNode":41}],57:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Label_1 = __importDefault(require("./Label"));
const Color_1 = __importDefault(require("../../Utils/Color"));
/** A clickable button UIElement */
class Button extends Label_1.default {
    constructor(position, text) {
        super(position, text);
        this.backgroundColor = new Color_1.default(150, 75, 203);
        this.borderColor = new Color_1.default(41, 46, 30);
        this.textColor = new Color_1.default(255, 255, 255);
    }
    // @override
    calculateBackgroundColor() {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    }
}
exports.default = Button;

},{"../../Utils/Color":105,"./Label":58}],58:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAlign = exports.VAlign = void 0;
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const UIElement_1 = __importDefault(require("../UIElement"));
/** A basic text-containing label */
class Label extends UIElement_1.default {
    constructor(position, text) {
        super(position);
        this.text = text;
        this.textColor = new Color_1.default(0, 0, 0, 1);
        this.font = "Arial";
        this.fontSize = 30;
        this.hAlign = "center";
        this.vAlign = "center";
        this.borderWidth = 0;
        this.sizeAssigned = false;
    }
    // @deprecated
    setText(text) {
        this.text = text;
    }
    setSize(newSize) {
        this.size = newSize;
    }
    // @deprecated
    setTextColor(color) {
        this.textColor = color;
    }
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    setBorderWidth(num) {
        this.borderWidth = num;
    }
    setBorderColor(color) {
        this.borderColor = color;
    }
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    getFontString() {
        return this.fontSize + "px " + this.font;
    }
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    calculateTextColor() {
        return this.textColor.toStringRGBA();
    }
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    calculateTextWidth(ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    }
    setHAlign(align) {
        this.hAlign = align;
    }
    setVAlign(align) {
        this.vAlign = align;
    }
    setFontSize(size) {
        this.fontSize = size;
    }
    setFont(font) {
        this.font = font;
    }
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    calculateTextOffset(ctx) {
        let textWidth = this.calculateTextWidth(ctx);
        let offset = new Vec2_1.default(0, 0);
        let hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    }
    sizeChanged() {
        super.sizeChanged();
        this.sizeAssigned = true;
    }
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    autoSize(ctx) {
        let width = this.calculateTextWidth(ctx);
        let height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    }
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    handleInitialSizing(ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    }
    /** On the next render, size this element to it's current text using its current font size */
    sizeToText() {
        this.sizeAssigned = false;
    }
}
exports.default = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));

},{"../../DataTypes/Vec2":26,"../../Utils/Color":105,"../UIElement":56}],59:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Input_1 = __importDefault(require("../../Input/Input"));
const Color_1 = __importDefault(require("../../Utils/Color"));
const MathUtils_1 = __importDefault(require("../../Utils/MathUtils"));
const UIElement_1 = __importDefault(require("../UIElement"));
/** A slider UIElement */
class Slider extends UIElement_1.default {
    constructor(position, initValue) {
        super(position);
        this.value = initValue;
        this.nibColor = Color_1.default.RED;
        this.sliderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.TRANSPARENT;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.nibSize = new Vec2_1.default(10, 20);
        // Set a default size
        this.size.set(200, 20);
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    getValue() {
        return this.value;
    }
    /** A method called in response to the value changing */
    valueChanged() {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.isClicked) {
            let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
            this.value = MathUtils_1.default.clamp01(val);
            this.valueChanged();
        }
    }
}
exports.default = Slider;

},{"../../DataTypes/Vec2":26,"../../Input/Input":34,"../../Utils/Color":105,"../../Utils/MathUtils":108,"../UIElement":56}],60:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = __importDefault(require("../../Utils/Color"));
const Label_1 = __importDefault(require("./Label"));
const Input_1 = __importDefault(require("../../Input/Input"));
/** A text input UIElement */
class TextInput extends Label_1.default {
    constructor(position) {
        super(position, "");
        this.focused = false;
        this.cursorCounter = 0;
        // Give a default size to the x only
        this.size.set(200, this.fontSize);
        this.hAlign = "left";
        this.borderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.WHITE;
    }
    update(deltaT) {
        super.update(deltaT);
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            let keys = Input_1.default.getKeysJustPressed();
            let nums = "1234567890";
            let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            let letters = "qwertyuiopasdfghjklzxcvbnm";
            let mask = nums + specialChars + letters;
            keys = keys.filter(key => mask.includes(key));
            let shiftPressed = Input_1.default.isKeyPressed("shift");
            let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
            let spacePressed = Input_1.default.isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    }
}
exports.default = TextInput;

},{"../../Input/Input":34,"../../Utils/Color":105,"./Label":58}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));

},{}],62:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
class NavigationManager {
    constructor() {
        this.navigableEntities = new Map_1.default();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    addNavigableEntity(navName, nav) {
        this.navigableEntities.add(navName, nav);
    }
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @param direct If true, go direct from fromPosition to toPosition, don't use NavMesh
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    getPath(navName, fromPosition, toPosition) {
        let nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone());
    }
}
exports.default = NavigationManager;

},{"../DataTypes/Collections/Map":8}],63:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
class NavigationPath {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    constructor(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1.default.ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    isDone() {
        return this.path.isEmpty();
    }
    next() { return this.path.isEmpty() ? null : this.path.peek(); }
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    getMoveDirection(node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    }
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    handlePathProgress(node) {
        if (!this.path.isEmpty() && node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    }
    toString() {
        return this.path.toString();
    }
    distance() {
        return this.path.size();
    }
}
exports.default = NavigationPath;

},{"../DataTypes/Vec2":26}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
class Navmesh {
    /**
     * Creates a new Navmesh from the points in the speecified graph. Navigation is done using the
     * given NavigationStrategy.
     * @param graph the graph to construct a navmesh from
     * @param strategy a constructor for strategy to use to build paths for this navmesh
     */
    constructor(graph) {
        this._graph = graph;
        this._strategies = new Map();
        this._strategy = undefined;
    }
    get graph() { return this._graph; }
    setStrategy(strategy) { this._strategy = this._strategies.get(strategy); }
    // @implemented
    getNavigationPath(fromPosition, toPosition) {
        if (this._strategy === undefined) {
            throw new Error("Error.No pathfinding strategy set for this navmesh.");
        }
        return this._strategy.buildPath(toPosition, fromPosition);
    }
    registerStrategy(key, strategy) {
        this._strategies.set(key, strategy);
    }
}
exports.default = Navmesh;

},{}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An abstract navigation strategy for Wolfie2Ds navigation system. You can extend this class to create
 * your own strategy for constructing a NavigationPath for the navigation system.
 * @author PeteyLumpkins
 */
class NavigationStrategy {
    constructor(mesh) {
        this.mesh = mesh;
    }
    get mesh() { return this._mesh; }
    set mesh(mesh) { this._mesh = mesh; }
}
exports.default = NavigationStrategy;

},{}],66:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PhysicsManager_1 = __importDefault(require("./PhysicsManager"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const OrthogonalTilemap_1 = __importDefault(require("../Nodes/Tilemaps/OrthogonalTilemap"));
const AreaCollision_1 = __importDefault(require("../DataTypes/Physics/AreaCollision"));
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
class BasicPhysicsManager extends PhysicsManager_1.default {
    constructor(options) {
        super();
        this.staticNodes = new Array();
        this.dynamicNodes = new Array();
        this.tilemaps = new Array();
        this.collisionMasks = new Array(32);
        // Parse options
        this.parseOptions(options);
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    parseOptions(options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (let i = 0; i < options.groupNames.length; i++) {
                let group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                let collisionMask = 0;
                for (let j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    }
    // @override
    registerObject(node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    }
    // @override
    deregisterObject(node) {
        if (node.isStatic) {
            // Remove the node from the static list
            const index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            const index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    }
    // @override
    registerTilemap(tilemap) {
        this.tilemaps.push(tilemap);
    }
    // @override
    deregisterTilemap(tilemap) {
        const index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    }
    // @override
    update(deltaT) {
        for (let node of this.dynamicNodes) {
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            let overlaps = new Array();
            let groupIndex = node.group === -1 ? -1 : Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (let other of this.staticNodes) {
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (let other of this.dynamicNodes) {
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (let tilemap of this.tilemaps) {
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1.default) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort((a, b) => b.area - a.area);
            // Keep track of hits to use later
            let hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (let overlap of overlaps) {
                // Ignore nodes we don't interact with
                if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                const point = node.collisionShape.center;
                const delta = node._velocity;
                const padding = node.collisionShape.halfSize;
                const otherAABB = overlap.collider;
                const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    let tnearx = hit.nearTimes.x;
                    let tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (let overlap of overlaps) {
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group) && node.group != -1) {
                    // Get the bit that this group is represented by
                    let index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    }
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    collideWithOrthogonalTilemap(node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
        let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        let minIndex = tilemap.getMinColRow(node.sweptRect);
        let maxIndex = tilemap.getMaxColRow(node.sweptRect);
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Create a new collider for this tile
                    let collider = tilemap.getTileCollider(col, row);
                    // Calculate collision area between the node and the tile
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                    }
                }
            }
        }
    }
}
exports.default = BasicPhysicsManager;

},{"../DataTypes/Physics/AreaCollision":17,"../DataTypes/Vec2":26,"../Nodes/Tilemaps/OrthogonalTilemap":54,"./PhysicsManager":67}],67:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const Emitter_1 = __importDefault(require("../Events/Emitter"));
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
class PhysicsManager {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1.default();
        this.groupNames = new Array();
    }
    destroy() {
        this.receiver.destroy();
    }
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    setGroup(node, group) {
        node.group = this.groupMap.get(group);
    }
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    getGroupNumber(group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    }
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    getGroupNames(groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            let g = 1;
            let names = [];
            for (let i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    }
}
exports.default = PhysicsManager;
/** The default group name */
PhysicsManager.DEFAULT_GROUP = "Default";

},{"../DataTypes/Collections/Map":8,"../Events/Emitter":29,"../Events/Receiver":33}],68:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GameEventType_1 = require("../Events/GameEventType");
const Receiver_1 = __importDefault(require("../Events/Receiver"));
class PlaybackManager {
    constructor() {
        this.recording = false;
        this.playing = false;
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([GameEventType_1.GameEventType.START_RECORDING, GameEventType_1.GameEventType.STOP_RECORDING, GameEventType_1.GameEventType.PLAY_RECORDING]);
    }
    update(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
        if (this.recorder !== undefined) {
            this.recorder.update(deltaT);
            this.recording = this.recorder.active();
        }
        if (this.replayer !== undefined) {
            this.replayer.update(deltaT);
            this.playing = this.replayer.active();
        }
    }
    handleEvent(event) {
        switch (event.type) {
            case GameEventType_1.GameEventType.START_RECORDING: {
                this.handleStartRecordingEvent(event);
                break;
            }
            case GameEventType_1.GameEventType.STOP_RECORDING: {
                this.handleStopRecordingEvent();
                break;
            }
            case GameEventType_1.GameEventType.PLAY_RECORDING: {
                this.handlePlayRecordingEvent(event);
                break;
            }
        }
    }
    handleStartRecordingEvent(event) {
        let recording = event.data.get("recording");
        if (!this.playing && !this.recording && recording !== undefined) {
            this.lastRecording = recording;
            let Recorder = this.lastRecording.recorder();
            if (this.recorder === undefined || this.recorder.constructor !== Recorder) {
                this.recorder = new Recorder();
            }
            this.recorder.start(this.lastRecording);
            this.recording = this.recorder.active();
        }
    }
    handleStopRecordingEvent() {
        this.recorder.stop();
        this.recording = this.recorder.active();
    }
    handlePlayRecordingEvent(event) {
        if (!this.recording && this.lastRecording !== undefined) {
            let Replayer = this.lastRecording.replayer();
            if (this.replayer === undefined || this.replayer.constructor !== Replayer) {
                this.replayer = new Replayer();
            }
            this.replayer.start(this.lastRecording, event.data.get("onEnd"));
            this.playing = this.replayer.active();
        }
    }
}
exports.default = PlaybackManager;

},{"../Events/GameEventType":32,"../Events/Receiver":33}],69:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../../DataTypes/Collections/Map"));
/** */
class Registry extends Map_1.default {
}
exports.default = Registry;

},{"../../DataTypes/Collections/Map":8}],70:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const LabelShaderType_1 = __importDefault(require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType"));
const PointShaderType_1 = __importDefault(require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType"));
const RectShaderType_1 = __importDefault(require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType"));
const SpriteShaderType_1 = __importDefault(require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType"));
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Registry_1 = __importDefault(require("./Registry"));
/**
 * A registry that handles shaders
 */
class ShaderRegistry extends Registry_1.default {
    constructor() {
        super(...arguments);
        this.registryItems = new Array();
    }
    /**
     * Preloads all built-in shaders
     */
    preload() {
        // Get the resourceManager and queue all built-in shaders for preloading
        const rm = ResourceManager_1.default.getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (let item of this.registryItems) {
            const shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    }
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
        let shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    }
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    registerItem(key, constr) {
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    }
}
exports.default = ShaderRegistry;
// Shader names
ShaderRegistry.POINT_SHADER = "point";
ShaderRegistry.RECT_SHADER = "rect";
ShaderRegistry.SPRITE_SHADER = "sprite";
ShaderRegistry.LABEL_SHADER = "label";
class ShaderRegistryItem {
}
class ShaderPreload {
}

},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":84,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":85,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":87,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":88,"../../ResourceManager/ResourceManager":89,"./Registry":69}],71:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const ShaderRegistry_1 = __importDefault(require("./Registries/ShaderRegistry"));
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
class RegistryManager {
    static preload() {
        this.shaders.preload();
        this.registries.forEach((key) => this.registries.get(key).preload());
    }
    static addCustomRegistry(name, registry) {
        this.registries.add(name, registry);
    }
    static getRegistry(key) {
        return this.registries.get(key);
    }
}
exports.default = RegistryManager;
RegistryManager.shaders = new ShaderRegistry_1.default();
/** Additional custom registries to add to the registry manager */
RegistryManager.registries = new Map_1.default();

},{"../DataTypes/Collections/Map":8,"./Registries/ShaderRegistry":70}],72:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../../DataTypes/Collections/Map"));
const Emitter_1 = __importDefault(require("../../Events/Emitter"));
const AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
class AnimationManager {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    constructor(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1.default();
        this.onEndEvent = null;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    add(key, animation) {
        this.animations.add(key, animation);
    }
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    getIndex() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            // console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
            return 0;
        }
    }
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    isPlaying(key) {
        return this.currentAnimation === key && this.animationState === AnimationTypes_1.AnimationState.PLAYING;
    }
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    getIndexAndAdvanceAnimation() {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            let currentAnimation = this.animations.get(this.currentAnimation);
            let index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >= currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
            return 0;
        }
    }
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    endCurrentAnimation() {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, { owner: this.owner.id, animation: this.currentAnimation });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    }
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    playIfNotAlready(animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    }
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    play(animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    }
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    queue(animation, loop = false, onEnd) {
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    }
    /** Pauses the current animation */
    pause() {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    }
    /** Resumes the current animation if possible */
    resume() {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /** Stops the current animation. The animation cannot be resumed after this. */
    stop() {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    }
}
exports.default = AnimationManager;

},{"../../DataTypes/Collections/Map":8,"../../Events/Emitter":29,"./AnimationTypes":73}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
class AnimationData {
    constructor() {
        this.repeat = false;
    }
}
exports.AnimationData = AnimationData;
class TweenEffect {
}
exports.TweenEffect = TweenEffect;
class TweenData {
}
exports.TweenData = TweenData;

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ParticleSystemManager {
    constructor() {
        this.particleSystems = new Array();
    }
    static getInstance() {
        if (ParticleSystemManager.instance === null) {
            ParticleSystemManager.instance = new ParticleSystemManager();
        }
        return ParticleSystemManager.instance;
    }
    registerParticleSystem(system) {
        this.particleSystems.push(system);
    }
    deregisterParticleSystem(system) {
        let index = this.particleSystems.indexOf(system);
        this.particleSystems.splice(index, 1);
    }
    clearParticleSystems() {
        this.particleSystems = new Array();
    }
    update(deltaT) {
        for (let particleSystem of this.particleSystems) {
            particleSystem.update(deltaT);
        }
    }
}
exports.default = ParticleSystemManager;
ParticleSystemManager.instance = null;

},{}],75:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../../DataTypes/Collections/Map"));
const AnimationTypes_1 = require("./AnimationTypes");
const EaseFunctions_1 = __importDefault(require("../../Utils/EaseFunctions"));
const MathUtils_1 = __importDefault(require("../../Utils/MathUtils"));
const TweenManager_1 = __importDefault(require("./TweenManager"));
const Emitter_1 = __importDefault(require("../../Events/Emitter"));
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
class TweenController {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    constructor(owner) {
        this.owner = owner;
        this.tweens = new Map_1.default();
        this.emitter = new Emitter_1.default();
        // Give ourselves to the TweenManager
        TweenManager_1.default.getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    destroy() {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1.default.getInstance().deregisterTweenController(this);
    }
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    add(key, tween) {
        let typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    }
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    play(key, loop) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
        }
    }
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    pause(key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    }
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    resume(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    stop(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    }
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    end(key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            let tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                let data = { key: key, node: this.owner.id };
                // If it has onEnd event data, add each entry, as long as the key is not named 'key' or 'node'
                if (tween.onEndData) {
                    Object.keys(tween.onEndData).forEach(key => {
                        if (key !== "key" && key !== "node") {
                            data[key] = tween.onEndData[key];
                        }
                    });
                }
                this.emitter.fireEvent(tween.onEnd, data);
            }
        }
    }
    /**
     * Stops all currently playing tweens
     */
    stopAll() {
        this.tweens.forEach(key => this.stop(key));
    }
    update(deltaT) {
        this.tweens.forEach(key => {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (let effect of tween.effects) {
                        // Get the value from the ease function that corresponds to our progress
                        let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                        // Use the value to lerp the property
                        let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        this.owner[effect.property] = value;
                    }
                }
            }
        });
    }
}
exports.default = TweenController;

},{"../../DataTypes/Collections/Map":8,"../../Events/Emitter":29,"../../Utils/EaseFunctions":106,"../../Utils/MathUtils":108,"./AnimationTypes":73,"./TweenManager":76}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TweenManager {
    constructor() {
        this.tweenControllers = new Array();
    }
    static getInstance() {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    }
    registerTweenController(controller) {
        this.tweenControllers.push(controller);
    }
    deregisterTweenController(controller) {
        let index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    }
    clearTweenControllers() {
        this.tweenControllers = new Array();
    }
    update(deltaT) {
        for (let tweenController of this.tweenControllers) {
            tweenController.update(deltaT);
        }
    }
}
exports.default = TweenManager;
TweenManager.instance = null;

},{}],77:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = __importDefault(require("../Nodes/Graphic"));
const Point_1 = __importDefault(require("../Nodes/Graphics/Point"));
const Rect_1 = __importDefault(require("../Nodes/Graphics/Rect"));
const Sprite_1 = __importDefault(require("../Nodes/Sprites/Sprite"));
const UIElement_1 = __importDefault(require("../Nodes/UIElement"));
const GraphicRenderer_1 = __importDefault(require("./CanvasRendering/GraphicRenderer"));
const RenderingManager_1 = __importDefault(require("./RenderingManager"));
const TilemapRenderer_1 = __importDefault(require("./CanvasRendering/TilemapRenderer"));
const UIElementRenderer_1 = __importDefault(require("./CanvasRendering/UIElementRenderer"));
const Label_1 = __importDefault(require("../Nodes/UIElements/Label"));
const Button_1 = __importDefault(require("../Nodes/UIElements/Button"));
const Slider_1 = __importDefault(require("../Nodes/UIElements/Slider"));
const TextInput_1 = __importDefault(require("../Nodes/UIElements/TextInput"));
const AnimatedSprite_1 = __importDefault(require("../Nodes/Sprites/AnimatedSprite"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Line_1 = __importDefault(require("../Nodes/Graphics/Line"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
class CanvasRenderer extends RenderingManager_1.default {
    constructor() {
        super();
    }
    // @override
    setScene(scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    }
    // @override
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1.default(width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    }
    // @override
    render(visibleSet, tilemaps, uiLayers) {
        // Sort by depth, then by visible set by y-value
        visibleSet.sort((a, b) => {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return (a.boundary.bottom) - (b.boundary.bottom);
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        let tilemapIndex = 0;
        let tilemapLength = tilemaps.length;
        let visibleSetIndex = 0;
        let visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        let sortedUILayers = new Array();
        uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
        sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
        sortedUILayers.forEach(uiLayer => {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(node => {
                    if (node.visible) {
                        this.renderNode(node);
                    }
                });
        });
    }
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        let xScale = 1;
        let yScale = 1;
        if (node instanceof Sprite_1.default) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        let globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1.default) {
            Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1.default) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1.default) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    // @override
    renderSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world
                image draw start -> x, y
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderAnimatedSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        let animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world (given we moved)
                image draw start -> -w/2, -h/2
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1.default) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1.default) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    }
    // @override
    renderTilemap(tilemap) {
        this.tilemapRenderer.renderTilemap(tilemap);
    }
    // @override
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1.default) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1.default) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1.default) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    }
    clear(clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
}
exports.default = CanvasRenderer;

},{"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Nodes/Graphic":43,"../Nodes/Graphics/Line":46,"../Nodes/Graphics/Point":48,"../Nodes/Graphics/Rect":49,"../Nodes/Sprites/AnimatedSprite":50,"../Nodes/Sprites/Sprite":51,"../Nodes/UIElement":56,"../Nodes/UIElements/Button":57,"../Nodes/UIElements/Label":58,"../Nodes/UIElements/Slider":59,"../Nodes/UIElements/TextInput":60,"./CanvasRendering/GraphicRenderer":78,"./CanvasRendering/TilemapRenderer":79,"./CanvasRendering/UIElementRenderer":80,"./RenderingManager":81}],78:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
class GraphicRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    renderPoint(point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    }
    renderLine(line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    }
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    renderRect(rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    }
}
exports.default = GraphicRenderer;

},{"../../ResourceManager/ResourceManager":89}],79:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
class TilemapRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    renderTilemap(tilemap) {
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        let origin = this.scene.getViewTranslation(tilemap);
        let size = this.scene.getViewport().getHalfSize();
        let zoom = this.scene.getViewScale();
        let bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            let minColRow = tilemap.getMinColRow(this.scene.getViewport().getView());
            let maxColRow = tilemap.getMaxColRow(this.scene.getViewport().getView());
            for (let row = minColRow.y; row <= maxColRow.y; row++) {
                for (let col = minColRow.x; col <= maxColRow.x; col++) {
                    // Get the tile at this position
                    let tile = tilemap.getTile(col, row);
                    // Extract the rot/flip parameters if there are any
                    const mask = (0xE << 28);
                    const rotFlip = ((mask & tile) >> 28) & 0xF;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (let tileset of tilemap.getTilesets()) {
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tilemap, tileset, tile, col, row, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    renderTile(tilemap, tileset, tileIndex, tilemapCol, tilemapRow, origin, scale, zoom, rotFlip) {
        let image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the size of the tile to render
        let tileSize = tileset.getTileSize();
        let width = tileSize.x;
        let height = tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let imagePosition = tileset.getImageOffsetForTile(tileIndex);
        let left = imagePosition.x;
        let top = imagePosition.y;
        // Calculate the position in the world to render the tile
        let worldPosition = tilemap.getWorldPosition(tilemapCol, tilemapRow);
        let worldX = Math.floor((worldPosition.x - origin.x) * zoom);
        let worldY = Math.floor((worldPosition.y - origin.y) * zoom);
        // Calculate the size of the world to render the tile in
        let worldWidth = Math.ceil(width * scale.x * zoom);
        let worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            let scaleX = 1;
            let scaleY = 1;
            let shearX = 0;
            let shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    }
    getOrthogonalTileDrawPos(map, set, col, row) {
        let imgsize = set.getTileSize().mult(map.scale);
        let mapsize = map.getScaledTileSize();
        return map.getWorldPosition(col, row).sub(imgsize.sub(mapsize));
    }
    getIsometricTileDrawPos(map, set, col, row) {
        let size = set.getTileSize();
        let drawPos = map.getScaledTileSize().sub(new Vec2_1.default(size.x * map.scale.x, size.y * map.scale.y));
        drawPos.inc(-size.x * map.scale.x / 2, 0);
        drawPos.add(map.getWorldPosition(col, row));
        return drawPos;
    }
}
exports.default = TilemapRenderer;

},{"../../DataTypes/Vec2":26,"../../ResourceManager/ResourceManager":89}],80:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const MathUtils_1 = __importDefault(require("../../Utils/MathUtils"));
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
class UIElementRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a label
     * @param label The label to render
     */
    renderLabel(label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        let offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a button
     * @param button The button to render
     */
    renderButton(button) {
        this.renderLabel(button);
    }
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    renderSlider(slider) {
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        let sliderSize = new Vec2_1.default(slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    renderTextInput(textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    }
}
exports.default = UIElementRenderer;

},{"../../DataTypes/Vec2":26,"../../ResourceManager/ResourceManager":89,"../../Utils/MathUtils":108}],81:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
/**
 * An abstract framework to put all rendering in once place in the application
 */
class RenderingManager {
    constructor() {
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    setScene(scene) {
        this.scene = scene;
    }
}
exports.default = RenderingManager;

},{"../ResourceManager/ResourceManager":89}],82:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const Graphic_1 = __importDefault(require("../Nodes/Graphic"));
const Point_1 = __importDefault(require("../Nodes/Graphics/Point"));
const Rect_1 = __importDefault(require("../Nodes/Graphics/Rect"));
const AnimatedSprite_1 = __importDefault(require("../Nodes/Sprites/AnimatedSprite"));
const Sprite_1 = __importDefault(require("../Nodes/Sprites/Sprite"));
const UIElement_1 = __importDefault(require("../Nodes/UIElement"));
const Label_1 = __importDefault(require("../Nodes/UIElements/Label"));
const ShaderRegistry_1 = __importDefault(require("../Registry/Registries/ShaderRegistry"));
const RegistryManager_1 = __importDefault(require("../Registry/RegistryManager"));
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const ParallaxLayer_1 = __importDefault(require("../Scene/Layers/ParallaxLayer"));
const RenderingManager_1 = __importDefault(require("./RenderingManager"));
class WebGLRenderer extends RenderingManager_1.default {
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1.default.ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        let textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    }
    render(visibleSet, tilemaps, uiLayers) {
        for (let node of visibleSet) {
            this.renderNode(node);
        }
        uiLayers.forEach(key => {
            if (!uiLayers.get(key).isHidden())
                uiLayers.get(key).getItems().forEach(node => this.renderNode(node));
        });
    }
    clear(color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1.default) {
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
    }
    renderSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderAnimatedSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    }
    renderTilemap(tilemap) {
        throw new Error("Method not implemented.");
    }
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
            let options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            let globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            let offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    renderCustom(node) {
        let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
        let options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    }
    addOptions(options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        let layer = node.getLayer();
        let parallax = new Vec2_1.default(1, 1);
        if (layer instanceof ParallaxLayer_1.default) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    }
}
exports.default = WebGLRenderer;

},{"../DataTypes/Vec2":26,"../Nodes/Graphic":43,"../Nodes/Graphics/Point":48,"../Nodes/Graphics/Rect":49,"../Nodes/Sprites/AnimatedSprite":50,"../Nodes/Sprites/Sprite":51,"../Nodes/UIElement":56,"../Nodes/UIElements/Label":58,"../Registry/Registries/ShaderRegistry":70,"../Registry/RegistryManager":71,"../ResourceManager/ResourceManager":89,"../Scene/Layers/ParallaxLayer":94,"./RenderingManager":81}],83:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
class ShaderType {
    constructor(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    getOptions(node) { return {}; }
}
exports.default = ShaderType;

},{"../../ResourceManager/ResourceManager":89}],84:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = __importDefault(require("../../../DataTypes/Mat4x4"));
const Vec2_1 = __importDefault(require("../../../DataTypes/Vec2"));
const ResourceManager_1 = __importDefault(require("../../../ResourceManager/ResourceManager"));
const QuadShaderType_1 = __importDefault(require("./QuadShaderType"));
/** */
class LabelShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const backgroundColor = options.backgroundColor.toWebGL();
        const borderColor = options.borderColor.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = LabelShaderType;

},{"../../../DataTypes/Mat4x4":16,"../../../DataTypes/Vec2":26,"../../../ResourceManager/ResourceManager":89,"./QuadShaderType":86}],85:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const RenderingUtils_1 = __importDefault(require("../../../Utils/RenderingUtils"));
const ShaderType_1 = __importDefault(require("../ShaderType"));
class PointShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
    }
    initBufferObject() {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
        let color = RenderingUtils_1.default.toWebGLColor(options.color);
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = position;
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    }
    getOptions(point) {
        let options = {
            position: point.position,
            color: point.color,
            pointSize: point.size,
        };
        return options;
    }
}
exports.default = PointShaderType;

},{"../../../Utils/RenderingUtils":109,"../ShaderType":83}],86:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = __importDefault(require("../../../DataTypes/Mat4x4"));
const ShaderType_1 = __importDefault(require("../ShaderType"));
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
class QuadShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.scale = Mat4x4_1.default.IDENTITY;
        this.rotation = Mat4x4_1.default.IDENTITY;
        this.translation = Mat4x4_1.default.IDENTITY;
    }
}
exports.default = QuadShaderType;

},{"../../../DataTypes/Mat4x4":16,"../ShaderType":83}],87:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = __importDefault(require("../../../DataTypes/Mat4x4"));
const Vec2_1 = __importDefault(require("../../../DataTypes/Vec2"));
const ResourceManager_1 = __importDefault(require("../../../ResourceManager/ResourceManager"));
const QuadShaderType_1 = __importDefault(require("./QuadShaderType"));
/** */
class RectShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const color = options.color.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /*
        So as it turns out, WebGL has an issue with non-square quads.
        It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
        To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
        A diagram of the solution follows.

        There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
        The offset in the vertical direction is therefore 0.5, as it is normally.
        However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
        All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.

        So now we have our rect, in a space scaled with respect to the largest dimension.
        Rotations work as you would expect, even for long rectangles.

                    0.5
            __ __ __ __ __ __ __
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
        -0.5|_ _|88888888888|_ _|0.5
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
            |___|88888888888|___|
                    -0.5

        The getVertices function below does as described, and converts the range
    */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = RectShaderType;

},{"../../../DataTypes/Mat4x4":16,"../../../DataTypes/Vec2":26,"../../../ResourceManager/ResourceManager":89,"./QuadShaderType":86}],88:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = __importDefault(require("../../../DataTypes/Mat4x4"));
const Vec2_1 = __importDefault(require("../../../DataTypes/Vec2"));
const AnimatedSprite_1 = __importDefault(require("../../../Nodes/Sprites/AnimatedSprite"));
const ResourceManager_1 = __importDefault(require("../../../ResourceManager/ResourceManager"));
const QuadShaderType_1 = __importDefault(require("./QuadShaderType"));
/** A shader for sprites and animated sprites */
class SpriteShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        const texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        const u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        const u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h, scale) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x, y, 0.0, 0.0,
            -x, -y, 0.0, 1.0,
            x, y, 1.0, 0.0,
            x, -y, 1.0, 1.0
        ]);
    }
    getOptions(sprite) {
        let texShift;
        let texScale;
        if (sprite instanceof AnimatedSprite_1.default) {
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
            texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        let options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift,
            texScale
        };
        return options;
    }
}
exports.default = SpriteShaderType;

},{"../../../DataTypes/Mat4x4":16,"../../../DataTypes/Vec2":26,"../../../Nodes/Sprites/AnimatedSprite":50,"../../../ResourceManager/ResourceManager":89,"./QuadShaderType":86}],89:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const Queue_1 = __importDefault(require("../DataTypes/Collections/Queue"));
const StringUtils_1 = __importDefault(require("../Utils/StringUtils"));
const AudioManager_1 = __importDefault(require("../Sound/AudioManager"));
const WebGLProgramType_1 = __importDefault(require("../DataTypes/Rendering/WebGLProgramType"));
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
class ResourceManager {
    constructor() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1.default();
        this.images = new Map_1.default();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
        this.spritesheets = new Map_1.default();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1.default();
        this.tilemaps = new Map_1.default();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1.default();
        this.audioBuffers = new Map_1.default();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1.default();
        this.jsonObjects = new Map_1.default();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
        this.gl_ShaderPrograms = new Map_1.default();
        this.gl_Textures = new Map_1.default();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1.default();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    ;
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    }
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    useWebGL(flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    }
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    image(key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepImage(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    getImage(key) {
        let image = this.images.get(key);
        if (image === undefined) {
            throw `There is no image associated with key "${key}"`;
        }
        return image;
    }
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    spritesheet(key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepSpritesheet(key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    }
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    getSpritesheet(key) {
        return this.spritesheets.get(key);
    }
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    audio(key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepAudio(key) {
        this.keepResource(key, ResourceType.AUDIO);
    }
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    getAudio(key) {
        return this.audioBuffers.get(key);
    }
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param path The path to the tilemap to load
     */
    tilemap(key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepTilemap(key) {
        this.keepResource(key, ResourceType.TILEMAP);
    }
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    getTilemap(key) {
        return this.tilemaps.get(key);
    }
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    object(key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepObject(key) {
        this.keepResource(key, ResourceType.JSON);
    }
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    getObject(key) {
        return this.jsonObjects.get(key);
    }
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    loadResourcesFromQueue(callback) {
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(() => {
            console.log("Loaded Tilemaps");
            this.loadSpritesheetsFromQueue(() => {
                console.log("Loaded Spritesheets");
                this.loadImagesFromQueue(() => {
                    console.log("Loaded Images");
                    this.loadAudioFromQueue(() => {
                        console.log("Loaded Audio");
                        this.loadObjectsFromQueue(() => {
                            console.log("Loaded Objects");
                            if (this.gl_WebGLActive) {
                                this.gl_LoadShadersFromQueue(() => {
                                    console.log("Loaded Shaders");
                                    this.finishLoading(callback);
                                });
                            }
                            else {
                                this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    }
    finishLoading(callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    }
    /* ######################################## UNLOAD FUNCTION ########################################*/
    keepResource(key, type) {
        console.log("Keep resource...");
        for (let i = 0; i < this.resourcesToUnload.length; i++) {
            let resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                let resourceToMove = this.resourcesToUnload.splice(i, 1);
                this.resourcesToKeep.push(...resourceToMove);
                return;
            }
        }
    }
    /**
     * Deletes references to all resources in the resource manager
     */
    unloadAllResources() {
        this.loading = false;
        this.justLoaded = false;
        for (let resource of this.resourcesToUnload) {
            // Unload the resource
            this.unloadResource(resource);
        }
    }
    unloadResource(resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images.delete(resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures.delete(resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps.delete(resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets.delete(resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers.delete(resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects.delete(resource.key);
                break;
            /*case ResourceType.SHADER:
                this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                this.gl_ShaderPrograms.delete(resource.key);
                break;*/
        }
        // Delete any dependencies
        for (let dependency of resource.dependencies) {
            this.unloadResource(dependency);
        }
    }
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    loadTilemapsFromQueue(onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
        this.loadTextFile(pathToTilemapJSON, (fileText) => {
            let tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.tilemaps.add(key, tilemapObject);
            let resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (let tileset of tilemapObject.tilesets) {
                if (tileset.image) {
                    let key = tileset.image;
                    let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                    this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (let tile of tileset.tiles) {
                        let key = tile.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingTilemap(callbackIfLast);
        });
    }
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    finishLoadingTilemap(callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    }
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    loadSpritesheetsFromQueue(onFinishLoading) {
        this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
        this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
            let spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.spritesheets.add(key, spritesheet);
            let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
            this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingSpritesheet(callbackIfLast);
        });
    }
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    finishLoadingSpritesheet(callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    }
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    loadImagesFromQueue(onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            let image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    }
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    loadImage(key, path, isDependency, callbackIfLast) {
        var image = new Image();
        image.onload = () => {
            // Add to loaded images
            this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (this.gl_WebGLActive) {
                this.createWebGLTexture(key, image);
            }
            // Finish image load
            this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    }
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    finishLoadingImage(callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    }
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    loadAudioFromQueue(onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            let audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    }
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    loadAudio(key, path, callbackIfLast) {
        let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
        let request = new XMLHttpRequest();
        request.open('GET', path, true);
        request.responseType = 'arraybuffer';
        request.onload = () => {
            audioCtx.decodeAudioData(request.response, (buffer) => {
                // Add to list of audio buffers
                this.audioBuffers.add(key, buffer);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                this.finishLoadingAudio(callbackIfLast);
            }, (error) => {
                throw "Error loading sound";
            });
        };
        request.send();
    }
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    finishLoadingAudio(callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    }
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    loadObjectsFromQueue(onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            let obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    loadObject(key, path, callbackIfLast) {
        this.loadTextFile(path, (fileText) => {
            let obj = JSON.parse(fileText);
            this.jsonObjects.add(key, obj);
            this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            this.finishLoadingObject(callbackIfLast);
        });
    }
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    finishLoadingObject(callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    }
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    getTexture(key) {
        return this.gl_Textures.get(key);
    }
    getShaderProgram(key) {
        return this.gl_ShaderPrograms.get(key).program;
    }
    getBuffer(key) {
        return this.gl_Buffers.get(key);
    }
    createWebGLTexture(imageKey, image) {
        // Get the texture ID
        const textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        const texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    }
    getTextureID(id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0: return this.gl.TEXTURE0;
            case 1: return this.gl.TEXTURE1;
            case 2: return this.gl.TEXTURE2;
            case 3: return this.gl.TEXTURE3;
            case 4: return this.gl.TEXTURE4;
            case 5: return this.gl.TEXTURE5;
            case 6: return this.gl.TEXTURE6;
            case 7: return this.gl.TEXTURE7;
            case 8: return this.gl.TEXTURE8;
            default: return this.gl.TEXTURE9;
        }
    }
    createBuffer(key) {
        if (this.gl_WebGLActive) {
            let buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    }
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    shader(key, vShaderFilepath, fShaderFilepath) {
        let splitPath = vShaderFilepath.split(".");
        let end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
        }
        let paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepShader(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    gl_LoadShadersFromQueue(onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    }
    gl_LoadShader(key, vpath, fpath, callbackIfLast) {
        this.loadTextFile(vpath, (vFileText) => {
            const vShader = vFileText;
            this.loadTextFile(fpath, (fFileText) => {
                const fShader = fFileText;
                // Extract the program and shaders
                const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                // Create a wrapper type
                const programWrapper = new WebGLProgramType_1.default();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                this.gl_ShaderPrograms.add(key, programWrapper);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    }
    gl_FinishLoadingShader(callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    }
    createShaderProgram(vShaderSource, fShaderSource) {
        const vertexShader = this.loadVertexShader(vShaderSource);
        const fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        const program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            const error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    }
    loadVertexShader(shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    }
    loadFragmentShader(shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    }
    loadShader(type, shaderSource) {
        const shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            const error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    }
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    loadTextFile(textFilePath, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', textFilePath, true);
        xobj.onreadystatechange = function () {
            if ((xobj.readyState == 4) && (xobj.status == 200)) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
    /* ########## LOADING BAR INFO ########## */
    getLoadPercent() {
        return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
            + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
            + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
            + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
            / this.loadonly_typesToLoad;
    }
    update(deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    }
}
exports.default = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
class ResourceReference {
    constructor(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    addDependency(resource) {
        this.dependencies.push(resource);
    }
}
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
class KeyPathPair {
    constructor() {
        this.isDependency = false;
    }
}
class KeyPath_Shader {
}

},{"../DataTypes/Collections/Map":8,"../DataTypes/Collections/Queue":9,"../DataTypes/Rendering/WebGLProgramType":19,"../Sound/AudioManager":102,"../Utils/StringUtils":110}],90:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __importDefault(require("../../Nodes/Sprites/Sprite"));
const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
const Point_1 = __importDefault(require("../../Nodes/Graphics/Point"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const Button_1 = __importDefault(require("../../Nodes/UIElements/Button"));
const Label_1 = __importDefault(require("../../Nodes/UIElements/Label"));
const Slider_1 = __importDefault(require("../../Nodes/UIElements/Slider"));
const TextInput_1 = __importDefault(require("../../Nodes/UIElements/TextInput"));
const Rect_1 = __importDefault(require("../../Nodes/Graphics/Rect"));
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const Line_1 = __importDefault(require("../../Nodes/Graphics/Line"));
const Particle_1 = __importDefault(require("../../Nodes/Graphics/Particle"));
const Circle_1 = __importDefault(require("../../Nodes/Graphics/Circle"));
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class CanvasNodeFactory {
    constructor() {
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = this.buildTextInput(options);
                    break;
                default:
                    throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
            }
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let instance = new Sprite_1.default(key);
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = (constr, key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let spritesheet = this.resourceManager.getSpritesheet(key);
            let instance = new constr(spritesheet);
            // Add instance fo scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = this.buildRect(options);
                    break;
                case GraphicTypes_1.GraphicType.PARTICLE:
                    instance = this.buildParticle(options);
                    break;
                case GraphicTypes_1.GraphicType.CIRCLE:
                    instance = this.buildCircle(options);
                    break;
                default:
                    throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
            }
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    init(scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /* ---------- BUILDERS ---------- */
    buildButton(options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1.default(options.position, options.text);
    }
    buildLabel(options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1.default(options.position, options.text);
    }
    buildSlider(options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
        let initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1.default(options.position, initValue);
    }
    buildTextInput(options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
        return new TextInput_1.default(options.position);
    }
    buildPoint(options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
        return new Point_1.default(options.position);
    }
    buildParticle(options) {
        this.checkIfPropExists("Particle", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Particle", options, "size", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Particle", options, "mass", "number", "number");
        //Changed for testing
        return new Particle_1.default(options.position, options.size, options.mass);
    }
    buildLine(options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
        return new Line_1.default(options.start, options.end);
    }
    buildRect(options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
        return new Rect_1.default(options.position, options.size);
    }
    buildCircle(options) {
        // this.checkIfPropExists("Rect", options, "position", Vec2, "Vec2");
        // this.checkIfPropExists("Rect", options, "size", Vec2, "Vec2");
        return new Circle_1.default(options.center, options.r);
    }
    /* ---------- ERROR HANDLING ---------- */
    checkIfPropExists(objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
        }
        else {
            // Check that the property has the correct type
            if ((typeof type) === "string") {
                if (!(typeof options[prop] === type)) {
                    throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
            else {
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
            }
        }
    }
}
exports.default = CanvasNodeFactory;

},{"../../DataTypes/Vec2":26,"../../Nodes/Graphics/Circle":44,"../../Nodes/Graphics/GraphicTypes":45,"../../Nodes/Graphics/Line":46,"../../Nodes/Graphics/Particle":47,"../../Nodes/Graphics/Point":48,"../../Nodes/Graphics/Rect":49,"../../Nodes/Sprites/Sprite":51,"../../Nodes/UIElements/Button":57,"../../Nodes/UIElements/Label":58,"../../Nodes/UIElements/Slider":59,"../../Nodes/UIElements/TextInput":60,"../../Nodes/UIElements/UIElementTypes":61,"../../ResourceManager/ResourceManager":89}],91:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNodeFactory_1 = __importDefault(require("./CanvasNodeFactory"));
const TilemapFactory_1 = __importDefault(require("./TilemapFactory"));
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
class FactoryManager {
    constructor(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1.default();
        this.tilemapFactory = new TilemapFactory_1.default();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    uiElement(type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    }
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    sprite(key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    }
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    animatedSprite(constr, key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(constr, key, layerName);
    }
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    graphic(type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    }
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    tilemap(key, scale) {
        return this.tilemapFactory.add(key, scale);
    }
}
exports.default = FactoryManager;

},{"./CanvasNodeFactory":90,"./TilemapFactory":92}],92:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilemapOrientation = void 0;
const ResourceManager_1 = __importDefault(require("../../ResourceManager/ResourceManager"));
const OrthogonalTilemap_1 = __importDefault(require("../../Nodes/Tilemaps/OrthogonalTilemap"));
const Tileset_1 = __importDefault(require("../../DataTypes/Tilesets/Tileset"));
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const PositionGraph_1 = __importDefault(require("../../DataTypes/Graphs/PositionGraph"));
const Navmesh_1 = __importDefault(require("../../Pathfinding/Navmesh"));
const IsometricTilemap_1 = __importDefault(require("../../Nodes/Tilemaps/IsometricTilemap"));
const StaggeredIsometricTilemap_1 = __importDefault(require("../../Nodes/Tilemaps/StaggeredIsometricTilemap"));
// @ignorePage
var TilemapOrientation;
(function (TilemapOrientation) {
    TilemapOrientation["ORTHOGONAL"] = "orthogonal";
    TilemapOrientation["ISOMETRIC"] = "isometric";
    TilemapOrientation["STAGGERED_ISOMETRIC"] = "staggered";
})(TilemapOrientation = exports.TilemapOrientation || (exports.TilemapOrientation = {}));
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class TilemapFactory {
    constructor() {
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = (key, scale = new Vec2_1.default(1, 1)) => {
            // Get Tilemap Data
            let tilemapData = this.resourceManager.getTilemap(key);
            // Set the constructor for this tilemap to either be orthographic or isometric
            let constr;
            switch (tilemapData.orientation) {
                case TilemapOrientation.ORTHOGONAL: {
                    constr = OrthogonalTilemap_1.default;
                    break;
                }
                case TilemapOrientation.ISOMETRIC: {
                    constr = IsometricTilemap_1.default;
                    break;
                }
                case TilemapOrientation.STAGGERED_ISOMETRIC: {
                    constr = StaggeredIsometricTilemap_1.default;
                    break;
                }
                default: {
                    throw new Error(`Unknown Tilemap Orientation "${tilemapData.orientation}"`);
                }
            }
            // Initialize the return value array
            let sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            let tilesets = new Array();
            let collectionTiles = new Array();
            for (let tileset of tilemapData.tilesets) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1.default(tileset));
                }
                else {
                    tileset.tiles.forEach(tile => tile.id += tileset.firstgid);
                    collectionTiles.push(...tileset.tiles);
                }
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (let layer of tilemapData.layers) {
                let sceneLayer;
                let isParallaxLayer = false;
                let depth = 0;
                if (layer.properties) {
                    for (let prop of layer.properties) {
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                }
                else {
                    sceneLayer = this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    let tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = this.scene.generateId();
                    tilemap.setScene(this.scene);
                    // Add tilemap to scene
                    this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (let item of layer.properties) {
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    let isNavmeshPoints = false;
                    let navmeshName;
                    let edges;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        let g = new PositionGraph_1.default();
                        for (let obj of layer.objects) {
                            g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                        }
                        for (let edge of edges) {
                            g.addEdge(edge.from, edge.to);
                        }
                        this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (let obj of layer.objects) {
                        // Check if obj is collidable
                        let hasPhysics = false;
                        let isCollidable = false;
                        let isTrigger = false;
                        let onEnter = null;
                        let onExit = null;
                        let triggerGroup = null;
                        let group = "";
                        if (obj.properties) {
                            for (let prop of obj.properties) {
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        let sprite;
                        // Check if obj is a tile from a tileset
                        for (let tileset of tilesets) {
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                let imageKey = tileset.getImageKey();
                                let offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = this.scene.add.sprite(imageKey, layer.name);
                                let size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (let tile of collectionTiles) {
                                if (obj.gid === tile.id) {
                                    let imageKey = tile.image;
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    init(scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
}
exports.default = TilemapFactory;

},{"../../DataTypes/Graphs/PositionGraph":14,"../../DataTypes/Tilesets/Tileset":25,"../../DataTypes/Vec2":26,"../../Nodes/Tilemaps/IsometricTilemap":53,"../../Nodes/Tilemaps/OrthogonalTilemap":54,"../../Nodes/Tilemaps/StaggeredIsometricTilemap":55,"../../Pathfinding/Navmesh":64,"../../ResourceManager/ResourceManager":89}],93:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("../Utils/MathUtils"));
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
class Layer {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    getName() {
        return this.name;
    }
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    setPaused(pauseValue) {
        this.paused = pauseValue;
    }
    /**
     * Returns whether or not the layer is paused
     */
    isPaused() {
        return this.paused;
    }
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    setAlpha(alpha) {
        this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
    }
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    setHidden(hidden) {
        this.hidden = hidden;
    }
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    isHidden() {
        return this.hidden;
    }
    /** Pauses this scene and hides it */
    disable() {
        this.paused = true;
        this.hidden = true;
    }
    /** Unpauses this layer and makes it visible */
    enable() {
        this.paused = false;
        this.hidden = false;
    }
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    setYSort(ySort) {
        this.ySort = ySort;
    }
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    getYSort() {
        return this.ySort;
    }
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    setDepth(depth) {
        this.depth = depth;
    }
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    getDepth() {
        return this.depth;
    }
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    addNode(node) {
        this.items.push(node);
        node.setLayer(this);
    }
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    removeNode(node) {
        // Find and remove the node
        let index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    }
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    getItems() {
        return this.items;
    }
}
exports.default = Layer;

},{"../Utils/MathUtils":108}],94:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = __importDefault(require("../Layer"));
/**
 * An extension of a Layer that has a parallax value.
 */
class ParallaxLayer extends Layer_1.default {
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    constructor(scene, name, parallax) {
        super(scene, name);
        this.parallax = parallax;
    }
}
exports.default = ParallaxLayer;

},{"../Layer":93}],95:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../DataTypes/Vec2"));
const ParallaxLayer_1 = __importDefault(require("./ParallaxLayer"));
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
class UILayer extends ParallaxLayer_1.default {
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    constructor(scene, name) {
        super(scene, name, Vec2_1.default.ZERO);
    }
}
exports.default = UILayer;

},{"../../DataTypes/Vec2":26,"./ParallaxLayer":94}],96:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = __importDefault(require("./Layer"));
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const BasicPhysicsManager_1 = __importDefault(require("../Physics/BasicPhysicsManager"));
const SceneGraphArray_1 = __importDefault(require("../SceneGraph/SceneGraphArray"));
const FactoryManager_1 = __importDefault(require("./Factories/FactoryManager"));
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const Emitter_1 = __importDefault(require("../Events/Emitter"));
const NavigationManager_1 = __importDefault(require("../Pathfinding/NavigationManager"));
const AIManager_1 = __importDefault(require("../AI/AIManager"));
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const ParallaxLayer_1 = __importDefault(require("./Layers/ParallaxLayer"));
const UILayer_1 = __importDefault(require("./Layers/UILayer"));
const CanvasNode_1 = __importDefault(require("../Nodes/CanvasNode"));
const SceneOptions_1 = __importDefault(require("./SceneOptions"));
const Debug_1 = __importDefault(require("../Debug/Debug"));
const TimerManager_1 = __importDefault(require("../Timing/TimerManager"));
const TweenManager_1 = __importDefault(require("../Rendering/Animations/TweenManager"));
const ParticleSystemManager_1 = __importDefault(require("../Rendering/Animations/ParticleSystemManager"));
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
class Scene {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    constructor(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1.default(500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
        this.layers = new Map_1.default();
        this.uiLayers = new Map_1.default();
        this.parallaxLayers = new Map_1.default();
        this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
        this.navManager = new NavigationManager_1.default();
        this.aiManager = new AIManager_1.default();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1.default(this, this.tilemaps);
        this.load = ResourceManager_1.default.getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1.default.getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    initScene(init) { }
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    loadScene() { }
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    startScene() { }
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    updateScene(deltaT) { }
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    unloadScene() { }
    update(deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1.default.getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(tilemap => {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1.default.getInstance().update(deltaT);
        // Update all particle systems
        ParticleSystemManager_1.default.getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    }
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    render() {
        // Get the visible set of nodes
        let visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(key => {
            let pLayer = this.parallaxLayers.get(key);
            for (let node of pLayer.getItems()) {
                if (node instanceof CanvasNode_1.default) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        let nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
        Debug_1.default.setNodes(nodes);
    }
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    setRunning(running) {
        this.running = running;
    }
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    isRunning() {
        return this.running;
    }
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    remove(node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1.default) {
            this.sceneGraph.removeNode(node);
        }
    }
    /** Destroys this scene and all nodes in it */
    destroy() {
        for (let node of this.sceneGraph.getAllNodes()) {
            node.destroy();
        }
        for (let tilemap of this.tilemaps) {
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    }
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    addLayer(name, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new Layer_1.default(this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    addParallaxLayer(name, parallax, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new ParallaxLayer_1.default(this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    addUILayer(name) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new UILayer_1.default(this, name);
        this.uiLayers.add(name, layer);
        return layer;
    }
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    getLayer(name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw `Requested layer ${name} does not exist.`;
        }
    }
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    isParallaxLayer(name) {
        return this.parallaxLayers.has(name);
    }
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    isUILayer(name) {
        return this.uiLayers.has(name);
    }
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    getViewTranslation(node) {
        let layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    }
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
    */
    getViewScale() {
        return this.viewport.getZoomLevel();
    }
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    getViewport() {
        return this.viewport;
    }
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    getWorldSize() {
        return this.worldSize;
    }
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    getSceneGraph() {
        return this.sceneGraph;
    }
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    getPhysicsManager() {
        return this.physicsManager;
    }
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    getNavigationManager() {
        return this.navManager;
    }
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    getAIManager() {
        return this.aiManager;
    }
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    generateId() {
        return this.sceneManager.generateId();
    }
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    getTilemap(name) {
        for (let tilemap of this.tilemaps) {
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    }
}
exports.default = Scene;

},{"../AI/AIManager":1,"../DataTypes/Collections/Map":8,"../DataTypes/Vec2":26,"../Debug/Debug":27,"../Events/Emitter":29,"../Events/Receiver":33,"../Nodes/CanvasNode":41,"../Pathfinding/NavigationManager":62,"../Physics/BasicPhysicsManager":66,"../Rendering/Animations/ParticleSystemManager":74,"../Rendering/Animations/TweenManager":76,"../ResourceManager/ResourceManager":89,"../SceneGraph/SceneGraphArray":100,"../Timing/TimerManager":104,"./Factories/FactoryManager":91,"./Layer":93,"./Layers/ParallaxLayer":94,"./Layers/UILayer":95,"./SceneOptions":98}],97:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const GameEventType_1 = require("../Events/GameEventType");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
class SceneManager {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    constructor(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe(GameEventType_1.GameEventType.CHANGE_SCENE);
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    changeToScene(constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    }
    doSceneChange() {
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(() => {
            console.log("Starting Scene");
            this.currentScene.startScene();
            this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    }
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    generateId() {
        return this.idCounter++;
    }
    /**
     * Renders the current Scene
     */
    render() {
        if (this.currentScene) {
            this.currentScene.render();
        }
    }
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    update(deltaT) {
        while (this.receiver.hasNextEvent()) {
            let ev = this.receiver.getNextEvent();
            if (ev.type === GameEventType_1.GameEventType.CHANGE_SCENE)
                this.changeToScene(ev.data.get("scene"), ev.data.get("init"));
        }
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    }
}
exports.default = SceneManager;

},{"../Events/GameEventType":32,"../Events/Receiver":33,"../ResourceManager/ResourceManager":89}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
class SceneOptions {
    static parse(options) {
        let sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    }
}
exports.default = SceneOptions;

},{}],99:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
class SceneGraph {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    addNode(node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    }
    ;
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    removeNode(node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    }
    ;
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    getNode(id) {
        return this.nodeMap[id];
    }
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    getNodesAt(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    }
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    getAllNodes() {
        let arr = new Array();
        for (let i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    }
}
exports.default = SceneGraph;

},{"../DataTypes/Vec2":26}],100:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const SceneGraph_1 = __importDefault(require("./SceneGraph"));
const Stats_1 = __importDefault(require("../Debug/Stats"));
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
class SceneGraphArray extends SceneGraph_1.default {
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        super(viewport, scene);
        this.nodeList = new Array();
    }
    // @override
    addNodeSpecific(node, id) {
        this.nodeList.push(node);
    }
    // @override
    removeNodeSpecific(node, id) {
        let index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    }
    // @override
    getNodesAtCoords(x, y) {
        let results = [];
        for (let node of this.nodeList) {
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    }
    // @override
    getNodesInRegion(boundary) {
        let t0 = performance.now();
        let results = [];
        for (let node of this.nodeList) {
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgquery", (t1 - t0));
        return results;
    }
    update(deltaT) {
        let t0 = performance.now();
        for (let node of this.nodeList) {
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgupdate", (t1 - t0));
    }
    render(ctx) { }
    // @override
    getVisibleSet() {
        let visibleSet = new Array();
        for (let node of this.nodeList) {
            if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    }
}
exports.default = SceneGraphArray;

},{"../Debug/Stats":28,"./SceneGraph":99}],101:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../DataTypes/Vec2"));
const MathUtils_1 = __importDefault(require("../Utils/MathUtils"));
const Queue_1 = __importDefault(require("../DataTypes/Collections/Queue"));
const AABB_1 = __importDefault(require("../DataTypes/Shapes/AABB"));
const Input_1 = __importDefault(require("../Input/Input"));
const ParallaxLayer_1 = __importDefault(require("../Scene/Layers/ParallaxLayer"));
const UILayer_1 = __importDefault(require("../Scene/Layers/UILayer"));
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
class Viewport {
    constructor(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        let postion = new Vec2_1.default(25, 450);
        this.view = new AABB_1.default(postion);
        this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.lastPositions = new Queue_1.default();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1.default.ZERO;
        this.focus = Vec2_1.default.ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    enableZoom() {
        this.scrollZoomEnabled = true;
    }
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    getCenter() {
        return this.view.center;
    }
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    getOrigin() {
        return new Vec2_1.default(this.view.left, this.view.top);
    }
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    getView() {
        return this.view;
    }
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    setCenter(vecOrX, y = null) {
        let pos;
        if (vecOrX instanceof Vec2_1.default) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1.default(vecOrX, y);
        }
        this.view.center = pos;
    }
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    getHalfSize() {
        return this.view.getHalfSize();
    }
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    setSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
        }
    }
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    setHalfSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
        }
    }
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    setCanvasSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1.default(vecOrX, y);
        }
    }
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    setZoomLevel(zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    }
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    getZoomLevel() {
        return this.canvasSize.x / this.view.hw / 2;
    }
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    setSmoothingFactor(smoothingFactor) {
        if (smoothingFactor < 1)
            smoothingFactor = 1;
        this.smoothingFactor = smoothingFactor;
    }
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    setFocus(focus) {
        this.focus.copy(focus);
    }
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    includes(node) {
        let parallax = node.getLayer() instanceof ParallaxLayer_1.default || node.getLayer() instanceof UILayer_1.default ? node.getLayer().parallax : new Vec2_1.default(1, 1);
        let center = this.view.center.clone();
        this.view.center.mult(parallax);
        let overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    }
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    setBounds(lowerX, lowerY, upperX, upperY) {
        let hwidth = (upperX - lowerX) / 2;
        let hheight = (upperY - lowerY) / 2;
        let x = lowerX + hwidth;
        let y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    }
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    follow(node) {
        this.following = node;
    }
    updateView() {
        if (this.lastPositions.getSize() > this.smoothingFactor) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        let pos = Vec2_1.default.ZERO;
        this.lastPositions.forEach(position => pos.add(position));
        pos.scale(1 / this.lastPositions.getSize());
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    }
    update(deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1.default.didJustScroll()) {
                let currentSize = this.view.getHalfSize().clone();
                if (Input_1.default.getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    let factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    let factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    }
}
exports.default = Viewport;

},{"../DataTypes/Collections/Queue":9,"../DataTypes/Shapes/AABB":20,"../DataTypes/Vec2":26,"../Input/Input":34,"../Scene/Layers/ParallaxLayer":94,"../Scene/Layers/UILayer":95,"../Utils/MathUtils":108}],102:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
const Map_1 = __importDefault(require("../DataTypes/Collections/Map"));
const Receiver_1 = __importDefault(require("../Events/Receiver"));
const ResourceManager_1 = __importDefault(require("../ResourceManager/ResourceManager"));
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
class AudioManager {
    constructor() {
        this.initAudio();
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL
        ]);
        this.currentSounds = new Map_1.default();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    }
    /**
     * Initializes the webAudio context
     */
    initAudio() {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
            this.audioCtx = new AudioContext();
            console.log('Web Audio API successfully loaded');
        }
        catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    }
    initGainNodes() {
        for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    }
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    getAudioContext() {
        return this.audioCtx;
    }
    /*
        According to the MDN, create a new sound for every call:

        An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
        if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
        actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
        "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
        hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
        until sometime after the sound has finished playing.
    */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    createSound(key, holdReference, channel, options) {
        // Get audio buffer
        let buffer = ResourceManager_1.default.getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        const nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (let i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    }
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    playSound(key, loop, holdReference, channel, options) {
        let sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    }
    /**
     * Stop the sound specified by the key
     */
    stopSound(key) {
        let sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds.delete(key);
        }
    }
    muteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    }
    unmuteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    }
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    static setVolume(channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        const am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    }
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    getChannelGainNode(channel) {
        return this.gainNodes[channel];
    }
    update(deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === GameEventType_1.GameEventType.PLAY_SOUND || event.type === GameEventType_1.GameEventType.PLAY_MUSIC || event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                let soundKey = event.data.get("key");
                let loop = event.data.get("loop");
                let holdReference = event.data.get("holdReference");
                let channel = AudioChannelType.DEFAULT;
                if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event.data.has("channel")) {
                    channel = event.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event.data);
            }
            if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                let soundKey = event.data.get("key");
                this.stopSound(soundKey);
            }
            if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event.data.get("channel"));
            }
            if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event.data.get("channel"));
            }
        }
    }
}
exports.default = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;

},{"../DataTypes/Collections/Map":8,"../Events/GameEventType":32,"../Events/Receiver":33,"../ResourceManager/ResourceManager":89}],103:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimerState = void 0;
const MathUtils_1 = __importDefault(require("../Utils/MathUtils"));
const TimerManager_1 = __importDefault(require("./TimerManager"));
/** */
class Timer {
    constructor(time, onEnd, loop = false) {
        // Register this timer
        TimerManager_1.default.getInstance().addTimer(this);
        this.totalTime = time;
        this.timeLeft = 0;
        this.onEnd = onEnd;
        this.loop = loop;
        this.state = TimerState.STOPPED;
        this.numRuns = 0;
    }
    isStopped() {
        return this.state === TimerState.STOPPED;
    }
    isPaused() {
        return this.state === TimerState.PAUSED;
    }
    /**
     * Returns whether or not this timer has been run before
     * @returns true if it has been run at least once (after the latest reset), and false otherwise
     */
    hasRun() {
        return this.numRuns > 0;
    }
    start(time) {
        if (time !== undefined) {
            this.totalTime = time;
        }
        this.state = TimerState.ACTIVE;
        this.timeLeft = this.totalTime;
    }
    /** Resets this timer. Sets the progress back to zero, and sets the number of runs back to zero */
    reset() {
        this.timeLeft = this.totalTime;
        this.numRuns = 0;
    }
    pause() {
        this.state = TimerState.PAUSED;
    }
    update(deltaT) {
        if (this.state === TimerState.ACTIVE) {
            this.timeLeft -= deltaT * 1000;
            if (this.timeLeft <= 0) {
                this.timeLeft = MathUtils_1.default.clampLow0(this.timeLeft);
                this.end();
            }
        }
    }
    end() {
        // Update the state
        this.state = TimerState.STOPPED;
        this.numRuns += 1;
        // Call the end function if there is one
        if (this.onEnd) {
            this.onEnd();
        }
        // Loop if we want to
        if (this.loop) {
            this.state = TimerState.ACTIVE;
            this.timeLeft = this.totalTime;
        }
    }
    toString() {
        return "Timer: " + this.state + " - Time Left: " + this.timeLeft + "ms of " + this.totalTime + "ms";
    }
}
exports.default = Timer;
var TimerState;
(function (TimerState) {
    TimerState["ACTIVE"] = "ACTIVE";
    TimerState["PAUSED"] = "PAUSED";
    TimerState["STOPPED"] = "STOPPED";
})(TimerState = exports.TimerState || (exports.TimerState = {}));

},{"../Utils/MathUtils":108,"./TimerManager":104}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TimerManager {
    constructor() {
        this.timers = new Array();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    }
    addTimer(timer) {
        this.timers.push(timer);
    }
    clearTimers() {
        this.timers = new Array();
    }
    update(deltaT) {
        this.timers.forEach(timer => timer.update(deltaT));
    }
}
exports.default = TimerManager;

},{}],105:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("./MathUtils"));
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
class Color {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Transparent color
     * @returns rgba(0, 0, 0, 0)
     */
    static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
    }
    static get FOG_OF_WAR_TRANSPARENT() {
        return new Color(0, 0, 0, 0.01);
    }
    static get FOG_OF_WAR_BLACK() {
        return new Color(0, 0, 0, 0.99);
    }
    /**
     * Red color
     * @returns rgb(255, 0, 0)
     */
    static get RED() {
        return new Color(255, 0, 0, 1);
    }
    /**
     * Green color
     * @returns rgb(0, 255, 0)
     */
    static get GREEN() {
        return new Color(0, 255, 0, 1);
    }
    /**
     * Blue color
     * @returns rgb(0, 0, 255)
     */
    static get BLUE() {
        return new Color(0, 0, 255, 1);
    }
    /**
     * Yellow color
     * @returns rgb(255, 255, 0)
     */
    static get YELLOW() {
        return new Color(255, 255, 0, 1);
    }
    /**
     * Magenta color
     * @returns rgb(255, 0, 255)
     */
    static get MAGENTA() {
        return new Color(255, 0, 255, 1);
    }
    /**
     * Cyan color
     * @returns rgb(0, 255, 255)
     */
    static get CYAN() {
        return new Color(0, 255, 255, 1);
    }
    /**
     * White color
     * @returns rgb(255, 255, 255)
     */
    static get WHITE() {
        return new Color(255, 255, 255, 1);
    }
    /**
     * Black color
     * @returns rgb(0, 0, 0)
     */
    static get BLACK() {
        return new Color(0, 0, 0, 1);
    }
    /**
     * Orange color
     * @returns rgb(255, 100, 0)
     */
    static get ORANGE() {
        return new Color(255, 100, 0, 1);
    }
    static get PURPLE() {
        return new Color(112, 90, 248, 1);
    }
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    set(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    lighten() {
        return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    darken() {
        return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    isEqual(color) {
        if (color.a == this.a && color.r == this.r && color.g == this.g && color.b == this.b)
            return true;
        else
            false;
    }
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    toString() {
        return "#" + MathUtils_1.default.toHex(this.r, 2) + MathUtils_1.default.toHex(this.g, 2) + MathUtils_1.default.toHex(this.b, 2);
    }
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    toStringRGB() {
        return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
    }
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    toStringRGBA() {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
    }
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    toWebGL() {
        return new Float32Array([
            this.r / 255,
            this.g / 255,
            this.b / 255,
            this.a
        ]);
    }
    static fromStringHex(str) {
        let i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
        let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
        let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    }
}
exports.default = Color;

},{"./MathUtils":108}],106:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseFunctionType = void 0;
class EaseFunctions {
    static easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }
    static easeOutInSine(x) {
        return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    }
    static easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    static easeInSine(x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    }
    static easeInOutQuint(x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    }
    static easeInOutQuad(x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    static easeOutInQuad(x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    }
    static easeOutIn_OutPow(x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    }
    static easeOutIn_InPow(x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    }
}
exports.default = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));

},{}],107:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BinaryHeapSet_1 = __importDefault(require("../DataTypes/Collections/BinaryHeapSet"));
/** A class to provides some utility functions for graphs */
class GraphUtils {
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    static djikstra(g, start) {
        let i; // Counter
        let p; // Pointer to edgenode
        let inTree = new Array(g.numVertices);
        let distance = new Array(g.numVertices);
        let parent = new Array(g.numVertices);
        let v; // Current vertex to process
        let w; // Candidate for next vertex
        let weight; // Edge weight
        let dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    }
    /**
     * An implementation of the A* algorithm
     * @param g the graph to search
     * @param start the node in the graph, g, to start searching from
     * @param goal the node in the graph, g, that A* should try to reach
     * @param heuristic the heuristic function used to calculate the f-score of a node in the graph, g
     * @return if a path between start and goal exists, an array of nodes representing the path from start
     * to goal found by A*; otherwise null
     */
    static astar(g, start, goal, heuristic) {
        // Construct a new map of the gScores - start gets a gScore of 0
        let gScore = new Map();
        gScore.set(start, 0);
        // Construct a new map of the fScores - f(n) = g(n) + h(n)
        let fScore = new Map();
        fScore.set(start, heuristic(start));
        // Construct a new map to hold the path from start to goal
        let cameFrom = new Map();
        // The open-set of nodes to be explored. Starts off with just starting node
        let openSet = new BinaryHeapSet_1.default((e1, e2) => {
            let e1fScore = fScore.has(e1) ? fScore.get(e1) : Number.POSITIVE_INFINITY;
            let e2fScore = fScore.has(e2) ? fScore.get(e2) : Number.POSITIVE_INFINITY;
            if (e1fScore < e2fScore)
                return 1;
            return 0;
        });
        openSet.push(start);
        // While there are elements in the openSet - explore the nodes
        while (!openSet.isEmpty()) {
            let current = openSet.peek();
            // If the next node is the goal - return the path
            if (current === goal) {
                let res = GraphUtils.astarPathBuilder(cameFrom, current);
                return res;
            }
            // Otherwise - remove the current node from the openSet and explore it's neighbors
            openSet.pop();
            // Iterate through the current node's edge list
            let edge = g.edges[current];
            while (edge !== null && edge !== undefined) {
                // Get the neighbor node from the edge
                let neighbor = edge.y;
                // Get tentative gscore
                let tentative_gscore = gScore.get(current) + edge.weight;
                // Get neighbors gscore - if neighbor doesn't have a gscore, default is positive infinity
                let neighbor_gscore = gScore.has(neighbor) ? gScore.get(neighbor) : Number.POSITIVE_INFINITY;
                if (tentative_gscore < neighbor_gscore) {
                    cameFrom.set(neighbor, current);
                    gScore.set(neighbor, tentative_gscore);
                    fScore.set(neighbor, tentative_gscore + heuristic(neighbor));
                    // If the openSet already contains the neighbor, then restore the heap about the neighbor
                    if (openSet.has(neighbor)) {
                        openSet.restore(neighbor);
                        // Otherwise, the openSet doesn't contain the neighbor, so we add the neighbor to the openSet
                    }
                    else {
                        openSet.push(neighbor);
                    }
                }
                edge = edge.next;
            }
        }
        return null;
    }
    static astarPathBuilder(cameFrom, current) {
        let path = new Array();
        path.push(current);
        while (cameFrom.has(current)) {
            current = cameFrom.get(current);
            path.push(current);
        }
        path.reverse();
        return path;
    }
}
exports.default = GraphUtils;

},{"../DataTypes/Collections/BinaryHeapSet":7}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class containing some utility functions for math operations */
class MathUtils {
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    static sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    static between(a, b, x, exclusive) {
        if (exclusive) {
            return (a < x) && (x < b);
        }
        else {
            return (a <= x) && (x <= b);
        }
    }
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    static clamp(x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    }
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    static clamp01(x) {
        return MathUtils.clamp(x, 0, 1);
    }
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    static clampLow(x, min) {
        return x < min ? min : x;
    }
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    static clampLow0(x) {
        return MathUtils.clampLow(x, 0);
    }
    static clampMagnitude(v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    }
    static changeRange(x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    }
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    static lerp(a, b, t) {
        return a + t * (b - a);
    }
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    static invLerp(a, b, value) {
        return (value - a) / (b - a);
    }
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    static floorToPlace(num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        let factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    }
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    static fromHex(str) {
        return parseInt(str, 16);
    }
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    static toHex(num, minLength = null) {
        let factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        let hexStr = "";
        while (factor >= 1) {
            let digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    }
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    static toHexDigit(num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    }
}
exports.default = MathUtils;

},{}],109:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = __importDefault(require("./MathUtils"));
class RenderingUtils {
    static toWebGLCoords(point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
        ]);
    }
    static toWebGLScale(size, worldSize) {
        return new Float32Array([
            2 * size.x / worldSize.x,
            2 * size.y / worldSize.y,
        ]);
    }
    static toWebGLColor(color) {
        return new Float32Array([
            MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
            color.a
        ]);
    }
}
exports.default = RenderingUtils;

},{"./MathUtils":108}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Some utility functions for dealing with strings */
class StringUtils {
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    static getPathFromFilePath(filePath) {
        let splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    }
}
exports.default = StringUtils;

},{}],111:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Timer_1 = __importDefault(require("../../../../Wolfie2D/Timing/Timer"));
const NPCAction_1 = __importDefault(require("./NPCAction"));
const ProjectEvents_1 = require("../../../ProjectEvents");
class AttackEnemy extends NPCAction_1.default {
    constructor(parent, actor) {
        super(parent, actor);
        this._target = null;
        this.timer = new Timer_1.default(2000);
    }
    performAction(target) {
        this.timer.isStopped() ? console.log("weapon cooling down!") : console.log("weapon ready");
        if (this.timer.isStopped()) {
            if (this.actor.isColliding)
                this.actor.animation.play("ATTACK");
            this.emitter.fireEvent(ProjectEvents_1.BattlerEvents.MONSTER_ATTACK);
            this.timer.start();
        }
        this.finished();
    }
    onEnter(options) {
        super.onEnter(options);
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
    }
    onExit() {
        return super.onExit();
    }
}
exports.default = AttackEnemy;

},{"../../../../Wolfie2D/Timing/Timer":103,"../../../ProjectEvents":146,"./NPCAction":113}],112:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const NPCAction_1 = __importDefault(require("./NPCAction"));
/**
 * An Idle action for the NPCGoapAI. Basically a default action for all of the NPCs
 * to do nothing.
 */
class IdleAction extends NPCAction_1.default {
    performAction(target) {
        this.finished();
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
}
exports.default = IdleAction;

},{"./NPCAction":113}],113:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GoapAction_1 = __importDefault(require("../../../../Wolfie2D/AI/Goap/GoapAction"));
const BasicFinder_1 = __importDefault(require("../../../GameSystems/Searching/BasicFinder"));
/**
 * An abstract GoapAction for an NPC. All NPC actions consist of doing three things:
 *
 *  1. Selecting some target/location
 *  2. Going to or moving within range of the selected target
 *  3. Doing something at the target location
 *
 * The abstract NPC action takes care of the first two parts (selecting the target and moving to the target location). All
 * concrete implementations of the NPCAction will have to implement the abstract method performAction() which
 * gets called when the NPC reaches the target location.
 */
class NPCAction extends GoapAction_1.default {
    constructor(parent, actor) {
        super(parent, actor);
        this.targetFinder = new BasicFinder_1.default();
        this.targets = [];
        this.target = null;
        this.path = null;
    }
    onEnter(options) {
        // Select the target location where the NPC should perform the action
        // console.log(this.actor.inventory);
        this.target = this.targetFinder.find(this.targets);
        // If we found a target, set the NPCs target to the target and find a path to the target
        // console.log(this.target);
        if (this.target !== null) {
            // Set the actors current target to be the target for this action
            this.actor.setTarget(this.target);
            // Construct a path from the actor to the target
            this.path = this.actor.getPath(this.actor.position, this.target.position);
            // console.log(this.target);
        }
    }
    update(deltaT) {
        // console.log(this.path.distance());
        if (this.path.distance() > 50) {
            this.onEnter(null);
            return;
        }
        if (this.path == null) {
            this.onEnter(null);
            return;
        }
        if (this.path.isDone()) {
            this.performAction(this.target);
            return;
        }
        else {
            this.actor.moveOnPath(1, this.path);
            return;
        }
    }
    onExit() {
        // Clear the actor's current target
        this.actor.clearTarget();
        // Clear the reference to the target and the path in the action
        this.target = null;
        this.path = null;
        return {};
    }
    safeExit() {
        this.actor.clearTarget();
        this.target = null;
        this.path = null;
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                throw new Error(`Unhandled event caught in NPCAction! Event type: ${event.type}`);
            }
        }
    }
    get targetFinder() { return this._targetFinder; }
    set targetFinder(finder) { this._targetFinder = finder; }
    get targets() { return this._targets; }
    set targets(targets) { this._targets = targets; }
    get target() { return this._target; }
    set target(target) { this._target = target; }
    set path(path) { this._path = path; }
    get path() { return this._path; }
}
exports.default = NPCAction;

},{"../../../../Wolfie2D/AI/Goap/GoapAction":2,"../../../GameSystems/Searching/BasicFinder":137}],114:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachineGoapAI_1 = __importDefault(require("../../../Wolfie2D/AI/Goap/StateMachineGoapAI"));
const ProjectEvents_1 = require("../../ProjectEvents");
/**
 * An abstract implementation of behavior for an NPC. Each concrete implementation of the
 * NPCBehavior class should define some new behavior for an NPCActor.
 */
class NPCBehavior extends StateMachineGoapAI_1.default {
    initializeAI(owner, options) {
        this.owner = owner;
        this.receiver.subscribe(ProjectEvents_1.ItemEvent.LASERGUN_FIRED);
        this.receiver.subscribe(ProjectEvents_1.BattlerEvents.MONSTER_ATTACK);
    }
    activate(options) { }
    update(deltaT) {
        super.update(deltaT);
    }
    /**
     * @param event the game event
     */
    handleEvent(event) {
        switch (event.type) {
            case ProjectEvents_1.ItemEvent.LASERGUN_FIRED: {
                console.log("Catching and handling lasergun fired event!!!");
                this.handleLasergunFired(event.data.get("actorId"), event.data.get("to"), event.data.get("from"));
                break;
            }
            case ProjectEvents_1.BattlerEvents.MONSTER_ATTACK: {
                console.log("MONSTER ATTACK");
                break;
            }
            default: {
                super.handleEvent(event);
                break;
            }
        }
    }
    handleLasergunFired(actorId, to, from) {
        if (actorId !== this.owner.id) {
            this.owner.health -= this.owner.collisionShape.getBoundingRect().intersectSegment(to, from) ? 1 : 0;
        }
    }
}
exports.default = NPCBehavior;

},{"../../../Wolfie2D/AI/Goap/StateMachineGoapAI":5,"../../ProjectEvents":146}],115:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BasicFinder_1 = __importDefault(require("../../../GameSystems/Searching/BasicFinder"));
const NPCBehavior_1 = __importDefault(require("../NPCBehavior"));
const HW4Filters_1 = require("../../../GameSystems/Searching/HW4Filters");
const TargetExists_1 = require("../NPCStatuses/TargetExists");
const FalseStatus_1 = __importDefault(require("../NPCStatuses/FalseStatus"));
const AttackEnemy_1 = __importDefault(require("../NPCActions/AttackEnemy"));
const HW4Reducers_1 = require("../../../GameSystems/Searching/HW4Reducers");
const GotoAction_1 = __importDefault(require("../NPCActions/GotoAction"));
class SlimeBehavior extends NPCBehavior_1.default {
    initializeAI(owner, options) {
        super.initializeAI(owner, options);
        this.target = options.target;
        this.range = options.range;
        this.initializeStatuses();
        this.initializeActions();
        this.goal = SlimeStatuses.GOAL;
        this.initialize();
    }
    initializeStatuses() {
        let scene = this.owner.getScene();
        let enemyBattlerFinder = new BasicFinder_1.default(null, (0, HW4Filters_1.BattlerActiveFilter)(), (0, HW4Filters_1.EnemyFilter)(this.owner), (0, HW4Filters_1.RangeFilter)(this.target, 0, this.range * this.range));
        let enemyAtGuardPosition = new TargetExists_1.TargetExists(scene.getBattlers(), enemyBattlerFinder);
        this.addStatus(SlimeStatuses.ENEMY_IN_GUARD_POSITION, enemyAtGuardPosition);
        this.addStatus(SlimeStatuses.GOAL, new FalseStatus_1.default());
    }
    initializeActions() {
        let scene = this.owner.getScene();
        let attackEnemy = new AttackEnemy_1.default(this, this.owner);
        attackEnemy.targets = scene.getBattlers();
        attackEnemy.targetFinder = new BasicFinder_1.default((0, HW4Reducers_1.ClosestPositioned)(this.owner), (0, HW4Filters_1.BattlerActiveFilter)(), (0, HW4Filters_1.EnemyFilter)(this.owner), (0, HW4Filters_1.RangeFilter)(this.target, 0, this.range * this.range));
        attackEnemy.addPrecondition(SlimeStatuses.ENEMY_IN_GUARD_POSITION);
        attackEnemy.addEffect(SlimeStatuses.GOAL);
        attackEnemy.cost = 1;
        this.addState(SlimeActions.ATTACK, attackEnemy);
        let slime = new GotoAction_1.default(this, this.owner);
        slime.targets = [this.target];
        slime.targetFinder = new BasicFinder_1.default();
        slime.addEffect(SlimeStatuses.GOAL);
        slime.cost = 1000;
        this.addState(SlimeActions.GUARD, slime);
    }
    addState(stateName, state) {
        super.addState(stateName, state);
    }
    addStatus(statusName, status) {
        super.addStatus(statusName, status);
    }
    handleEvent(event) {
        switch (event.type) {
            default: {
                super.handleEvent(event);
                break;
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
    }
}
exports.default = SlimeBehavior;
const SlimeStatuses = {
    ENEMY_IN_GUARD_POSITION: "enemy-at-guard-position",
    GOAL: "goal"
};
const SlimeActions = {
    IDLE: "idle",
    ATTACK: "attack",
    GUARD: "guard"
};

},{"../../../GameSystems/Searching/BasicFinder":137,"../../../GameSystems/Searching/HW4Filters":138,"../../../GameSystems/Searching/HW4Reducers":139,"../NPCActions/AttackEnemy":111,"../NPCActions/GotoAction":112,"../NPCBehavior":114,"../NPCStatuses/FalseStatus":116,"../NPCStatuses/TargetExists":117}],116:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const GoapState_1 = __importDefault(require("../../../../Wolfie2D/AI/Goap/GoapState"));
class FalseStatus extends GoapState_1.default {
    isSatisfied() {
        return false;
    }
}
exports.default = FalseStatus;

},{"../../../../Wolfie2D/AI/Goap/GoapState":4}],117:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TargetExists = void 0;
const GoapState_1 = __importDefault(require("../../../../Wolfie2D/AI/Goap/GoapState"));
class TargetExists extends GoapState_1.default {
    constructor(targets, finder) {
        super();
        this.finder = finder;
        this.targets = targets;
    }
    isSatisfied() {
        return this.finder.find(this.targets) !== null;
    }
}
exports.TargetExists = TargetExists;

},{"../../../../Wolfie2D/AI/Goap/GoapState":4}],118:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachineAI_1 = __importDefault(require("../../../Wolfie2D/AI/StateMachineAI"));
const PlayerController_1 = __importDefault(require("./PlayerController"));
const PlayerState_1 = require("./PlayerStates/PlayerState");
const ProjectEvents_1 = require("../../ProjectEvents");
const Timer_1 = __importDefault(require("../../../Wolfie2D/Timing/Timer"));
const PlayerStatsArray_1 = require("../../PlayerStatsArray");
const MathUtils_1 = __importDefault(require("../../../Wolfie2D/Utils/MathUtils"));
/**
 * The AI that controls the player. The players AI has been configured as a Finite State Machine (FSM)
 * with 4 states; Idle, Moving, shielding, and Dead.
 */
class PlayerAI extends StateMachineAI_1.default {
    constructor() {
        super(...arguments);
        this.isInvincible = false;
        //stats of AI
        this.currentStatValue = 10;
        this.statNames = PlayerStatsArray_1.PlayerStatsArray;
        this.minStatValue = 0;
        this.maxStatValue = 10;
        this.currentStat = {};
        this.handleinvincibleTimeEnd = () => {
            this.isInvincible = false;
            // TO DO
            // Play Idle animation
        };
    }
    initializeAI(owner, opts) {
        this.owner = owner;
        this.controller = new PlayerController_1.default(owner);
        // Add the players states to it's StateMachine
        this.addState(PlayerState_1.PlayerStateType.IDLE, new PlayerState_1.Idle(this, this.owner));
        this.addState(PlayerState_1.PlayerStateType.MOVING, new PlayerState_1.Moving(this, this.owner));
        this.addState(PlayerState_1.PlayerStateType.SHIELDING, new PlayerState_1.Shielding(this, this.owner));
        this.addState(PlayerState_1.PlayerStateType.ATTACKING, new PlayerState_1.Attacking(this, this.owner));
        // Initialize the players state to Idle
        this.initialize(PlayerState_1.PlayerStateType.IDLE);
        this.receiver.subscribe(ProjectEvents_1.BattlerEvents.PRINCE_DEAD);
        this.receiver.subscribe(ProjectEvents_1.BattlerEvents.PRINCE_HIT);
        this.invincibleTime = new Timer_1.default(1000, this.handleinvincibleTimeEnd, false);
        this.activate(null);
    }
    activate(options) {
        for (const name of this.statNames) {
            this.currentStat[name] = this.currentStatValue; // Set default value for each stat
            if (name !== 'currentHealth') {
                this.currentStat[name] = 0;
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
        // If the player is out of hp - play the death animation
        this.currentStat['currentShield'] = MathUtils_1.default.clamp(this.currentStat['currentShield'] + deltaT * 3, this.minStatValue, this.maxStatValue);
    }
    destroy() { }
    handleEvent(event) {
        switch (event.type) {
            case ProjectEvents_1.BattlerEvents.PRINCE_HIT: {
                this.handlePrinceHit();
                break;
            }
            case ProjectEvents_1.BattlerEvents.PRINCE_DEAD: {
                console.log("dead");
                break;
            }
        }
    }
    // TO DO play hit animation
    handlePrinceHit() {
        if (!this.isInvincible) {
            this.isInvincible = true;
            this.invincibleTime.start();
            if (this.currentStat["currentHealth"] <= this.minStatValue) {
                this.emitter.fireEvent(ProjectEvents_1.BattlerEvents.PRINCE_DEAD);
                return;
            }
        }
    }
}
exports.default = PlayerAI;

},{"../../../Wolfie2D/AI/StateMachineAI":6,"../../../Wolfie2D/Timing/Timer":103,"../../../Wolfie2D/Utils/MathUtils":108,"../../PlayerStatsArray":145,"../../ProjectEvents":146,"./PlayerController":119,"./PlayerStates/PlayerState":124}],119:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonsterAnimations = exports.PlayerAnimations = exports.UseItemInput = exports.PlayerInput = void 0;
const Vec2_1 = __importDefault(require("../../../Wolfie2D/DataTypes/Vec2"));
const Input_1 = __importDefault(require("../../../Wolfie2D/Input/Input"));
/**
 * Strings used in the key binding for the player
 */
var PlayerInput;
(function (PlayerInput) {
    PlayerInput["MOVE_UP"] = "MOVE_UP";
    PlayerInput["MOVE_DOWN"] = "MOVE_DOWN";
    PlayerInput["MOVE_LEFT"] = "MOVE_LEFT";
    PlayerInput["MOVE_RIGHT"] = "MOVE_RIGHT";
    PlayerInput["ATTACKING"] = "ATTACKING";
    PlayerInput["SHIELDING"] = "SHIELDING";
    PlayerInput["ULTIMATE"] = "ULTIMATE";
    PlayerInput["PICKUP_ITEM"] = "PICKUP_ITEM";
    PlayerInput["DROP_ITEM"] = "DROP_ITEM";
})(PlayerInput = exports.PlayerInput || (exports.PlayerInput = {}));
var UseItemInput;
(function (UseItemInput) {
    UseItemInput["USE_ITEM1"] = "USE_ITEM1";
    UseItemInput["USE_ITEM2"] = "USE_ITEM2";
    UseItemInput["USE_ITEM3"] = "USE_ITEM3";
    UseItemInput["USE_ITEM4"] = "USE_ITEM4";
    UseItemInput["USE_ITEM5"] = "USE_ITEM5";
})(UseItemInput = exports.UseItemInput || (exports.UseItemInput = {}));
exports.PlayerAnimations = {
    IDLE: "IDLE",
    ATTACKING: "ATTACKING",
    MOVING: "MOVING",
    SHIELDING: "SHIELDING",
    DYING: "DYING",
    DEAD: "DEAD",
    HIT: "HIT"
};
exports.MonsterAnimations = {
    IDLE: "IDLE",
    ATTACKING: "ATTACKING",
    MOVING: "MOVING",
    DYING: "DYING:",
    DEAD: "DEAD",
    HIT: "HIT"
};
/**
 * The PlayerController class handles processing the input recieved from the user and exposes
 * a set of methods to make dealing with the user input a bit simpler.
 */
class PlayerController {
    constructor(owner) {
        this.owner = owner;
    }
    /**
     * Gets the direction the player should move based on input from the keyboard.
     * @returns a Vec2 indicating the direction the player should move.
     */
    get moveDir() {
        let dir = Vec2_1.default.ZERO;
        dir.y = (Input_1.default.isPressed(PlayerInput.MOVE_UP) ? -1 : 0) + (Input_1.default.isPressed(PlayerInput.MOVE_DOWN) ? 1 : 0);
        dir.x = (Input_1.default.isPressed(PlayerInput.MOVE_LEFT) ? -1 : 0) + (Input_1.default.isPressed(PlayerInput.MOVE_RIGHT) ? 1 : 0);
        return dir.normalize();
    }
    /**
     * Gets the direction the player should be facing based on the position of the
     * mouse around the player
     * @return a Vec2 representing the direction the player should face.
     */
    get faceDir() { return this.owner.position.dirTo(Input_1.default.getGlobalMousePosition()); }
    /**
     * Gets the rotation of the players sprite based on the direction the player
     * should be facing.
     * @return a number representing how much the player should be rotated
     */
    get rotation() { return Vec2_1.default.UP.angleToCCW(this.faceDir); }
    /**
     * Checks if the player is attempting to use a held item or not.
     * @return true if the player is attempting to use a held item; false otherwise
     */
    get useItem() { return Input_1.default.isMouseJustPressed(); }
    /**
     * Checks if the player is attempting to pick up an item or not.
     * @return true if the player is attempting to pick up an item; false otherwise.
     */
    get pickingUp() { return Input_1.default.isJustPressed(PlayerInput.PICKUP_ITEM); }
    get attacking() { return Input_1.default.isJustPressed(PlayerInput.ATTACKING); }
    get shielding() { return Input_1.default.isJustPressed(PlayerInput.SHIELDING); }
    get ultimate() { return Input_1.default.isJustPressed(PlayerInput.ULTIMATE); }
    /**
     * Checks if the player is attempting to drop their held item or not.
     * @return true if the player is attempting to drop their held item; false otherwise.
     */
    get dropping() { return Input_1.default.isJustPressed(PlayerInput.DROP_ITEM); }
}
exports.default = PlayerController;

},{"../../../Wolfie2D/DataTypes/Vec2":26,"../../../Wolfie2D/Input/Input":34}],120:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerController_1 = require("../PlayerController");
const PlayerState_1 = __importStar(require("./PlayerState"));
class Attacking extends PlayerState_1.default {
    onEnter(options) {
        this.parent.owner.animation.play(PlayerController_1.PlayerAnimations.ATTACKING, false);
    }
    update(deltaT) {
        super.update(deltaT);
        if (!this.parent.owner.animation.isPlaying(PlayerController_1.PlayerAnimations.ATTACKING)) {
            this.finished(PlayerState_1.PlayerStateType.IDLE);
        }
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
    onExit() {
        return {};
    }
}
exports.default = Attacking;

},{"../PlayerController":119,"./PlayerState":124}],121:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerState_1 = __importDefault(require("./PlayerState"));
/**
 * The Dead state for the PlayerAI. While the player is in the "Dead" state, the player does not
 * get updated and all incoming events to the PlayerAI are ignored.
 */
class Dead extends PlayerState_1.default {
    /**
     * When the PlayerAI enters the dead state, an event is fired to alert the system
     * that the player is officially dead.
     */
    onEnter(options) {
        //this.emitter.fireEvent(PlayerEvents.PLAYER_KILLED);
    }
    /**
     * The input handler for the dead state ignores all incoming events to the player.
     * @param event
     */
    handleInput(event) { }
    /**
     * Similar to the handleInput method, while in the dead state, the PlayerAI doesn't
     * get updated.
     * @param deltaT
     */
    update(deltaT) { }
    onExit() { return {}; }
}
exports.default = Dead;

},{"./PlayerState":124}],122:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/Vec2"));
const PlayerState_1 = require("./PlayerState");
const PlayerController_1 = require("../PlayerController");
const PlayerState_2 = __importDefault(require("./PlayerState"));
const ProjectEvents_1 = require("../../../ProjectEvents");
const PlayerController_2 = require("../PlayerController");
class Idle extends PlayerState_2.default {
    onEnter(options) {
        this.parent.owner.animation.playIfNotAlready(PlayerController_1.PlayerAnimations.IDLE, true);
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.parent.controller.shielding) {
            if (this.parent.owner._ai["currentStat"]["currentShield"] == this.parent.owner._ai["maxStatValue"])
                this.finished(PlayerState_1.PlayerStateType.SHIELDING);
            else {
                this.emitter.fireEvent(ProjectEvents_1.MessageBoxEvents.SHOW, { message: ProjectEvents_1.MessageBoxEvents.SKILL_ON_CD });
            }
        }
        if (this.parent.controller.ultimate) {
            this.emitter.fireEvent(PlayerController_2.PlayerInput.ULTIMATE);
        }
        if (this.parent.controller.attacking) {
            this.finished(PlayerState_1.PlayerStateType.ATTACKING);
        }
        if (!this.parent.controller.moveDir.equals(Vec2_1.default.ZERO)) {
            this.finished(PlayerState_1.PlayerStateType.MOVING);
        }
    }
    onExit() {
        return {};
    }
}
exports.default = Idle;

},{"../../../../Wolfie2D/DataTypes/Vec2":26,"../../../ProjectEvents":146,"../PlayerController":119,"./PlayerState":124}],123:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/Vec2"));
const PlayerController_1 = require("../PlayerController");
const PlayerState_1 = require("./PlayerState");
const PlayerState_2 = __importDefault(require("./PlayerState"));
class Moving extends PlayerState_2.default {
    onEnter(options) {
        this.parent.owner.animation.playIfNotAlready(PlayerController_1.PlayerAnimations.MOVING, true);
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
            }
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.parent.controller.shielding) {
            this.finished(PlayerState_1.PlayerStateType.SHIELDING);
        }
        if (this.parent.controller.attacking) {
            this.finished(PlayerState_1.PlayerStateType.ATTACKING);
        }
        if (this.parent.controller.moveDir.equals(Vec2_1.default.ZERO)) {
            this.finished(PlayerState_1.PlayerStateType.IDLE);
        }
    }
    onExit() { return {}; }
}
exports.default = Moving;

},{"../../../../Wolfie2D/DataTypes/Vec2":26,"../PlayerController":119,"./PlayerState":124}],124:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Attacking = exports.Dead = exports.Moving = exports.Shielding = exports.Idle = exports.PlayerStateType = exports.PlayerAnimationType = void 0;
const State_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/State/State"));
const ProjectEvents_1 = require("../../../ProjectEvents");
var PlayerAnimationType;
(function (PlayerAnimationType) {
    PlayerAnimationType["IDLE"] = "IDLE";
    PlayerAnimationType["MOVING"] = "MOVING";
    PlayerAnimationType["ATTACKING"] = "ATTACKING";
    PlayerAnimationType["SHIELDING"] = "SHIELDING";
})(PlayerAnimationType = exports.PlayerAnimationType || (exports.PlayerAnimationType = {}));
var PlayerStateType;
(function (PlayerStateType) {
    PlayerStateType["IDLE"] = "IDLE";
    PlayerStateType["ATTACKING"] = "ATTACKING";
    PlayerStateType["MOVING"] = "MOVING";
    PlayerStateType["SHIELDING"] = "SHIELDING";
})(PlayerStateType = exports.PlayerStateType || (exports.PlayerStateType = {}));
class PlayerState extends State_1.default {
    constructor(parent, owner) {
        super(parent);
        this.owner = owner;
    }
    onEnter(options) { }
    onExit() { return {}; }
    update(deltaT) {
        // if (this.parent.owner.animation.isPlaying(PlayerAnimations.IDLE)) {
        //     this.parent.owner.rotation = 0;
        // }
        // Adjust the angle the player is facing 
        // this.parent.owner.rotation = this.parent.controller.rotation;
        let princeDirection = this.parent.controller.moveDir;
        //change direction of the prince
        if (princeDirection.x == 0) {
            if (princeDirection.y > 0) {
                this.parent.owner.rotation = 3.15;
            }
            if (princeDirection.y < 0) {
                this.parent.owner.rotation = 0;
            }
        }
        if (princeDirection.y == 0) {
            if (princeDirection.x > 0) {
                this.parent.owner.rotation = 4.75;
            }
            if (princeDirection.x < 0) {
                this.parent.owner.rotation = 1.5;
            }
        }
        if (princeDirection.x < 0) {
            if (princeDirection.y < 0) {
                this.parent.owner.rotation = 0.75;
            }
            if (princeDirection.y > 0) {
                this.parent.owner.rotation = 2.25;
            }
        }
        if (princeDirection.x > 0) {
            if (princeDirection.y < 0) {
                this.parent.owner.rotation = 5.25;
            }
            if (princeDirection.y > 0) {
                this.parent.owner.rotation = 3.75;
            }
        }
        // Move the player
        this.parent.owner.move(this.parent.controller.moveDir);
        // if (this.parent.controller.attacking) {
        // }
        // if (this.parent.controller.shielding) {
        // }
        // Handle the player trying to pick up an item
        if (this.parent.controller.pickingUp) {
            // Request an item from the scene
            this.emitter.fireEvent(ProjectEvents_1.ItemEvent.ITEM_REQUEST, { node: this.owner, inventory: this.owner.inventory });
        }
        // Handle the player trying to drop an item
        if (this.parent.controller.dropping) {
        }
        if (this.parent.controller.useItem) {
        }
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                throw new Error(`Unhandled event of type ${event.type} caught in PlayerState!`);
            }
        }
    }
}
exports.default = PlayerState;
const Idle_1 = __importDefault(require("./Idle"));
exports.Idle = Idle_1.default;
const Shielding_1 = __importDefault(require("./Shielding"));
exports.Shielding = Shielding_1.default;
const Moving_1 = __importDefault(require("./Moving"));
exports.Moving = Moving_1.default;
const Attacking_1 = __importDefault(require("./Attacking"));
exports.Attacking = Attacking_1.default;
const Dead_1 = __importDefault(require("./Dead"));
exports.Dead = Dead_1.default;

},{"../../../../Wolfie2D/DataTypes/State/State":23,"../../../ProjectEvents":146,"./Attacking":120,"./Dead":121,"./Idle":122,"./Moving":123,"./Shielding":125}],125:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const PlayerController_1 = require("../PlayerController");
const PlayerState_1 = __importStar(require("./PlayerState"));
class Shielding extends PlayerState_1.default {
    onEnter(options) {
        this.parent.owner.animation.play(PlayerController_1.PlayerAnimations.SHIELDING, false);
        this.parent.owner._ai["currentStat"]["currentShield"] = 0;
    }
    update(deltaT) {
        super.update(deltaT);
        if (!this.parent.owner.animation.isPlaying(PlayerController_1.PlayerAnimations.SHIELDING)) {
            this.finished(PlayerState_1.PlayerStateType.IDLE);
        }
    }
    handleInput(event) {
        switch (event.type) {
            default: {
                super.handleInput(event);
                break;
            }
        }
    }
    onExit() {
        return {};
    }
}
exports.default = Shielding;

},{"../PlayerController":119,"./PlayerState":124}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ACTIONTYPE = void 0;
exports.ACTIONTYPE = {
    PICK: "PICK",
    USE: "USE",
};

},{}],127:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AnimatedSprite_1 = __importDefault(require("../../Wolfie2D/Nodes/Sprites/AnimatedSprite"));
const ProjectEvents_1 = require("../ProjectEvents");
const BasicTargeting_1 = __importDefault(require("../GameSystems/Targeting/BasicTargeting"));
const BasicBattler_1 = __importDefault(require("../GameSystems/BattleSystem/BasicBattler"));
const Timer_1 = __importDefault(require("../../Wolfie2D/Timing/Timer"));
class NPCActor extends AnimatedSprite_1.default {
    constructor(sheet) {
        super(sheet);
        this._navkey = "navkey";
        this._battler = new BasicBattler_1.default(this);
        this._targeting = new BasicTargeting_1.default(this);
        this.shieldingTimer = new Timer_1.default(1000);
        this.receiver.subscribe("use-hpack");
    }
    /** The TargetingEntity interface */
    clearTarget() { this._targeting.clearTarget(); }
    setTarget(targetable) { this._targeting.setTarget(targetable); }
    hasTarget() { return this._targeting.hasTarget(); }
    getTarget() { return this._targeting.getTarget(); }
    /** The TargetableEntity interface */
    getTargeting() { return this._battler.getTargeting(); }
    addTargeting(targeting) { this._battler.addTargeting(targeting); }
    removeTargeting(targeting) { this._battler.removeTargeting(targeting); }
    atTarget() {
        return this._targeting.getTarget().position.distanceSqTo(this.position) < 625;
    }
    get battlerActive() { return this.battler.battlerActive; }
    set battlerActive(value) {
        this.battler.battlerActive = value;
        this.visible = value;
        this.aiActive = value;
    }
    get battleGroup() { return this.battler.battleGroup; }
    set battleGroup(battleGroup) { this.battler.battleGroup = battleGroup; }
    get maxHealth() { return this.battler.maxHealth; }
    set maxHealth(maxHealth) {
        this.battler.maxHealth = maxHealth;
        this.emitter.fireEvent(ProjectEvents_1.HudEvent.HEALTH_CHANGE, { id: this.id, curhp: this.health, maxhp: this.maxHealth });
    }
    get health() { return this.battler.health; }
    set health(health) {
        this.battler.health = health;
        if (this.health <= 0 && this.battlerActive) {
            this.emitter.fireEvent(ProjectEvents_1.BattlerEvents.MONSTER_DEAD, { id: this.id });
        }
    }
    get speed() { return this.battler.speed; }
    set speed(speed) { this.battler.speed = speed; }
    setScene(scene) { this.scene = scene; }
    getScene() { return this.scene; }
    get navkey() { return this._navkey; }
    set navkey(navkey) { this._navkey = navkey; }
    getPath(to, from) {
        return this.scene.getNavigationManager().getPath(this.navkey, to, from);
    }
    get inventory() { return this.battler.inventory; }
    /** Protected getters for the different components */
    get battler() { return this._battler; }
    get targeting() { return this._targeting; }
}
exports.default = NPCActor;

},{"../../Wolfie2D/Nodes/Sprites/AnimatedSprite":50,"../../Wolfie2D/Timing/Timer":103,"../GameSystems/BattleSystem/BasicBattler":133,"../GameSystems/Targeting/BasicTargeting":141,"../ProjectEvents":146}],128:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AnimatedSprite_1 = __importDefault(require("../../Wolfie2D/Nodes/Sprites/AnimatedSprite"));
const ProjectEvents_1 = require("../ProjectEvents");
const BasicBattler_1 = __importDefault(require("../GameSystems/BattleSystem/BasicBattler"));
const BasicTargetable_1 = __importDefault(require("../GameSystems/Targeting/BasicTargetable"));
class PlayerActor extends AnimatedSprite_1.default {
    constructor(sheet) {
        super(sheet);
        this.battler = new BasicBattler_1.default(this);
        this.targetable = new BasicTargetable_1.default(this);
        this.receiver.subscribe(ProjectEvents_1.ItemEvent.LASERGUN_FIRED);
    }
    get battlerActive() {
        return this.battler.battlerActive;
    }
    set battlerActive(value) {
        this.battler.battlerActive = value;
        this.visible = value;
    }
    getTargeting() { return this.targetable.getTargeting(); }
    addTargeting(targeting) { this.targetable.addTargeting(targeting); }
    removeTargeting(targeting) { this.targetable.removeTargeting(targeting); }
    setScene(scene) { this.scene = scene; }
    getScene() { return this.scene; }
    get battleGroup() {
        return this.battler.battleGroup;
    }
    set battleGroup(value) {
        this.battler.battleGroup = value;
    }
    get maxHealth() {
        return this.battler.maxHealth;
    }
    set maxHealth(value) {
        this.battler.maxHealth = value;
    }
    get health() {
        return this.battler.health;
    }
    set health(value) {
        this.battler.health = value;
        if (this.health <= 0) {
            this.emitter.fireEvent(ProjectEvents_1.BattlerEvents.MONSTER_DEAD, { id: this.id });
        }
    }
    get speed() {
        return this.battler.speed;
    }
    set speed(value) {
        this.battler.speed = value;
    }
    get inventory() {
        return this.battler.inventory;
    }
}
exports.default = PlayerActor;

},{"../../Wolfie2D/Nodes/Sprites/AnimatedSprite":50,"../GameSystems/BattleSystem/BasicBattler":133,"../GameSystems/Targeting/BasicTargetable":140,"../ProjectEvents":146}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemButtonArray = exports.HW3Controls = void 0;
/**
 * A set of controls for the HW4 keybinding
 */
exports.HW3Controls = {
    ATTACKING: "ATTACKING",
    SHIELDING: "SHEILDING"
};
const length = 6;
function createItemButtonArray() {
    const array = [];
    for (let i = 1; i < length; i++) {
        array.push(i.toString());
    }
    return array;
}
;
exports.ItemButtonArray = createItemButtonArray();

},{}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackButtonEvent = exports.StartMenuButtonEvent = exports.PauseButtonEvent = exports.SelectMenuButtonEvent = exports.MainMenuButtonEvent = void 0;
var MainMenuButtonEvent;
(function (MainMenuButtonEvent) {
    MainMenuButtonEvent["Restart"] = "Restart";
    MainMenuButtonEvent["Select_levels"] = "Select levels";
    MainMenuButtonEvent["Controls"] = "Controls";
    MainMenuButtonEvent["Help"] = "Help";
    MainMenuButtonEvent["CHEAT"] = "CHEAT";
    MainMenuButtonEvent["Exit"] = "Exit";
})(MainMenuButtonEvent = exports.MainMenuButtonEvent || (exports.MainMenuButtonEvent = {}));
var SelectMenuButtonEvent;
(function (SelectMenuButtonEvent) {
    SelectMenuButtonEvent["LEVEL_1"] = "INTRO";
    SelectMenuButtonEvent["LEVEL_2"] = "REGULAR";
    SelectMenuButtonEvent["LEVEL_3"] = "SPEED RUN";
    SelectMenuButtonEvent["LEVEL_4"] = "TREASURE HUNTER";
    SelectMenuButtonEvent["LEVEL_5"] = "CRINGE";
    SelectMenuButtonEvent["LEVEL_6"] = "FINAL BOSS";
})(SelectMenuButtonEvent = exports.SelectMenuButtonEvent || (exports.SelectMenuButtonEvent = {}));
var PauseButtonEvent;
(function (PauseButtonEvent) {
    PauseButtonEvent["PAUSE"] = "PAUSE";
})(PauseButtonEvent = exports.PauseButtonEvent || (exports.PauseButtonEvent = {}));
var StartMenuButtonEvent;
(function (StartMenuButtonEvent) {
    StartMenuButtonEvent["START_GAME"] = "Start Game";
})(StartMenuButtonEvent = exports.StartMenuButtonEvent || (exports.StartMenuButtonEvent = {}));
var BackButtonEvent;
(function (BackButtonEvent) {
    BackButtonEvent["BACK"] = "BACK";
})(BackButtonEvent = exports.BackButtonEvent || (exports.BackButtonEvent = {}));

},{}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameItemsArray = exports.GameItems = void 0;
var GameItems;
(function (GameItems) {
    GameItems["LANTERNS"] = "lantern";
    GameItems["DOOR"] = "door";
    GameItems["HEALTH_PACKS"] = "healthPacks";
    GameItems["INVENTORYSLOT"] = "inventorySlot";
    GameItems["PHASINGPOTION"] = "phasingPotion";
})(GameItems = exports.GameItems || (exports.GameItems = {}));
function createGameItemsArray() {
    let GameItemsArray = [];
    for (const key of Object.keys(GameItems)) {
        GameItemsArray.push(GameItems[key]);
    }
    return GameItemsArray;
}
exports.GameItemsArray = createGameItemsArray();

},{}],132:[function(require,module,exports){
"use strict";
// baseLayer (base layer, where tilemap, item, player, level end locates)
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameLayers = void 0;
// fog of  war layer (make the screen black )
// container layer (container for next layer, to serve as a background for the actual menu  )
// PAUSE_MENU layer (display the pause menu selection )
// TEXT_MENU layer(display help and controls)
// UI layer(display the player and game status )
var GameLayers;
(function (GameLayers) {
    GameLayers["BEFORE_BASE"] = "BEFORE_BASE";
    GameLayers["BASE"] = "BASE";
    GameLayers["FOG_OF_WAR"] = "FOG_OF_WAR";
    GameLayers["PAUSE_MENU_CONTAINER"] = "PAUSE_MENU_CONTAINER";
    GameLayers["PAUSE_MENU"] = "PAUSE_MENU";
    GameLayers["CONTROL_TEXT_MENU_CONTAINER"] = "CONTROL_TEXT_MENU_CONTAINER";
    GameLayers["CONTROL_TEXT_MENU"] = "CONTROL_TEXT_MENU";
    GameLayers["HELP_TEXT_MENU_CONTAINER"] = "HELP_TEXT_MENU_CONTAINER";
    GameLayers["HELP_TEXT_MENU"] = "HELP_TEXT_MENU";
    GameLayers["UI"] = "UI";
})(GameLayers = exports.GameLayers || (exports.GameLayers = {}));

},{}],133:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Inventory_1 = __importDefault(require("../ItemSystem/Inventory"));
const BasicTargetable_1 = __importDefault(require("../Targeting/BasicTargetable"));
class BasicBattler {
    constructor(owner) {
        this._owner = owner;
        this._targetable = new BasicTargetable_1.default(owner);
        this.inventory = new Inventory_1.default();
        this.maxHealth = 0;
        this.health = 0;
        this.battleGroup = 0;
        this.speed = 0;
        this.battlerActive = true;
    }
    get id() { return this._owner.id; }
    get position() { return this._targetable.position; }
    set position(position) { this._targetable.position = position; }
    get relativePosition() {
        return this._targetable.relativePosition;
    }
    get battleGroup() { return this._battleGroup; }
    set battleGroup(battleGroup) { this._battleGroup = battleGroup; }
    get maxHealth() { return this._maxHealth; }
    set maxHealth(maxHealth) { this._maxHealth = maxHealth; }
    get health() { return this._health; }
    set health(health) { this._health = health; }
    get speed() { return this._speed; }
    set speed(speed) { this._speed = speed; }
    get inventory() { return this._inventory; }
    set inventory(inventory) { this._inventory = inventory; }
    get battlerActive() { return this._active; }
    set battlerActive(value) { this._active = value; }
    getTargeting() { return this._targetable.getTargeting(); }
    addTargeting(targeting) { this._targetable.addTargeting(targeting); }
    removeTargeting(targeting) { this._targetable.removeTargeting(targeting); }
}
exports.default = BasicBattler;

},{"../ItemSystem/Inventory":134,"../Targeting/BasicTargetable":140}],134:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = __importDefault(require("../../../Wolfie2D/Events/Emitter"));
/**
 * An inventory is a collection of items. All items in the inventory must be registered with
 * the Inventorys ItemManager class.
 */
class Inventory {
    constructor(capacity = 10) {
        this.__id = Inventory.NEXT_ID;
        Inventory.NEXT_ID += 1;
        this.inventory = new Map();
        this._emitter = new Emitter_1.default();
        this.size = 0;
        this.capacity = capacity;
        this.dirty = false;
        this.onChange = null;
    }
    get id() { return this.__id; }
    get dirty() { return this._dirty; }
    set dirty(dirty) { this._dirty = dirty; }
    get size() { return this._size; }
    set size(size) { this._size = size; }
    get capacity() { return this._capacity; }
    set capacity(capacity) { this._capacity = capacity; }
    get onChange() { return this._onChange; }
    set onChange(onChange) { this._onChange = onChange; }
    get inventory() { return this._inventory; }
    set inventory(inventory) { this._inventory = inventory; }
    get emitter() { return this._emitter; }
    set emitter(emitter) { this._emitter = emitter; }
    /**
     * Gets an item from this inventory by id.
     * @param id the id of the item to get
     * @returns the item if it exists; null otherwise
     */
    get(id) {
        if (!this.has(id)) {
            return null;
        }
        return this.inventory.get(id);
    }
    /**
     * Adds an item to this inventory
     * @param item adds an item to the inventory with the key of the items owner
     * @returns if the Item was successfully added to the inventory; null otherwise
     */
    add(item) {
        if (this.has(item.id) || this.size >= this.capacity || item.inventory !== null) {
            return null;
        }
        this.inventory.set(item.id, item);
        this.size += 1;
        this.dirty = true;
        item.inventory = this;
        item.visible = false;
        return item;
    }
    /**
     * Checks if an item with the given id number exists in this inventory.
     * @param id the id of the item in the inventory
     * @returns true if the item with the id exists; false otherwise
     */
    has(id) {
        return this.inventory.has(id);
    }
    /**
     * Removes the item with the given id number from this inventory
     * @param id the id of the item
     * @returns the item that was removed or null
     */
    remove(id) {
        if (!this.has(id)) {
            return null;
        }
        let item = this.get(id);
        this.inventory.delete(id);
        this.size -= 1;
        this.dirty = true;
        item.inventory = null;
        return item;
    }
    items() {
        return this.inventory.values();
    }
    find(func) {
        let item = Array.from(this.inventory.values()).find(func);
        return item === undefined ? null : item;
    }
    clean() {
        this.dirty = false;
        if (this.onChange !== null) {
            this.emitter.fireEvent(this.onChange, { id: this.id, inventory: this });
        }
    }
}
exports.default = Inventory;
/** The id number of the next inventory */
Inventory.NEXT_ID = 0;

},{"../../../Wolfie2D/Events/Emitter":29}],135:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = __importDefault(require("../../../Wolfie2D/Events/Emitter"));
const BasicTargetable_1 = __importDefault(require("../Targeting/BasicTargetable"));
class Item {
    constructor(sprite) {
        this.sprite = sprite;
        this.emitter = new Emitter_1.default();
        this._inventory = null;
        this._targetable = new BasicTargetable_1.default(this.sprite);
    }
    getTargeting() {
        return this._targetable.getTargeting();
    }
    addTargeting(targeting) {
        this._targetable.addTargeting(targeting);
    }
    removeTargeting(targeting) {
        this._targetable.removeTargeting(targeting);
    }
    get relativePosition() { return this.sprite.relativePosition; }
    get id() { return this.sprite.id; }
    get name() { return this.itemName; }
    ;
    set name(name) { this.itemName = name; }
    get position() { return this.sprite.position; }
    get visible() { return this.sprite.visible; }
    set visible(value) { this.sprite.visible = value; }
    get inventory() { return this._inventory; }
    set inventory(value) { this._inventory = value; }
}
exports.default = Item;

},{"../../../Wolfie2D/Events/Emitter":29,"../Targeting/BasicTargetable":140}],136:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../../../Wolfie2D/DataTypes/Vec2"));
const GameNode_1 = require("../../../../Wolfie2D/Nodes/GameNode");
const Color_1 = __importDefault(require("../../../../Wolfie2D/Utils/Color"));
const EaseFunctions_1 = require("../../../../Wolfie2D/Utils/EaseFunctions");
const Item_1 = __importDefault(require("../Item"));
class LaserGun extends Item_1.default {
    constructor(sprite, laser) {
        super(sprite);
        this._laser = laser;
        this._laser.start.copy(Vec2_1.default.ZERO_STATIC);
        this._laser.end.copy(Vec2_1.default.ZERO_STATIC);
        this._laser.color = Color_1.default.GREEN;
        this._laser.tweens.add("fade", {
            startDelay: 0,
            duration: 300,
            effects: [
                {
                    property: GameNode_1.TweenableProperties.alpha,
                    start: 1,
                    end: 0,
                    ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                }
            ],
            onEnd: "Laser faded"
        });
        this._direction = Vec2_1.default.ZERO;
    }
    static create(sprite, laser) {
        return new LaserGun(sprite, laser);
    }
    get direction() { return this._direction; }
    get laserStart() { return this._laser.start; }
    get laserEnd() { return this._laser.end; }
    playShootAnimation() { this._laser.tweens.play("fade"); }
}
exports.default = LaserGun;

},{"../../../../Wolfie2D/DataTypes/Vec2":26,"../../../../Wolfie2D/Nodes/GameNode":42,"../../../../Wolfie2D/Utils/Color":105,"../../../../Wolfie2D/Utils/EaseFunctions":106,"../Item":135}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BasicFinder {
    constructor(reducer = null, ...filters) {
        this.reducer = reducer;
        this.filters = filters;
    }
    find(targets) {
        let filtered = targets.filter(target => this.filters.every(filter => filter(target)));
        return filtered.length === 0 ? null : this.reducer === null ? filtered[0] : filtered.reduce(this.reducer);
    }
}
exports.default = BasicFinder;

},{}],138:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VisibleItemFilter = exports.ItemFilter = exports.RangeFilter = exports.EnemyFilter = exports.AllyFilter = exports.BattlerGroupFilter = exports.BattlerHealthFilter = exports.BattlerActiveFilter = void 0;
const MathUtils_1 = __importDefault(require("../../../Wolfie2D/Utils/MathUtils"));
function BattlerActiveFilter() {
    return (b) => b.battlerActive;
}
exports.BattlerActiveFilter = BattlerActiveFilter;
function BattlerHealthFilter(min, max) {
    return (b) => { return MathUtils_1.default.between(min, max, b.health, true); };
}
exports.BattlerHealthFilter = BattlerHealthFilter;
function BattlerGroupFilter(groups, whitelist = true) {
    return whitelist ? (b) => { return groups.includes(b.battleGroup); } : (b) => { return !groups.includes(b.battleGroup); };
}
exports.BattlerGroupFilter = BattlerGroupFilter;
function AllyFilter(battler) {
    return (other) => { return battler.battleGroup === other.battleGroup; };
}
exports.AllyFilter = AllyFilter;
function EnemyFilter(battler) {
    return (other) => { return battler.battleGroup !== other.battleGroup; };
}
exports.EnemyFilter = EnemyFilter;
function RangeFilter(positioned, minDistSq, maxDistSq) {
    return (t) => {
        let distSq = t.position.distanceSqTo(positioned.position);
        return distSq > minDistSq && distSq < maxDistSq;
    };
}
exports.RangeFilter = RangeFilter;
function ItemFilter(constr) {
    return (i) => { return i.constructor === constr; };
}
exports.ItemFilter = ItemFilter;
function VisibleItemFilter() {
    return (i) => i.visible;
}
exports.VisibleItemFilter = VisibleItemFilter;

},{"../../../Wolfie2D/Utils/MathUtils":108}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LowestHealthBattler = exports.ClosestPositioned = void 0;
function ClosestPositioned(positioned) {
    return (p1, p2) => {
        return p1.position.distanceSqTo(positioned.position) < p2.position.distanceSqTo(positioned.position) ? p1 : p2;
    };
}
exports.ClosestPositioned = ClosestPositioned;
function LowestHealthBattler(b1, b2) {
    return b1.health < b2.health ? b1 : b2;
}
exports.LowestHealthBattler = LowestHealthBattler;

},{}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BasicTargetable {
    constructor(owner) {
        this.owner = owner;
        this.targeting = new Map();
    }
    getTargeting() {
        return Array.from(this.targeting.values());
    }
    addTargeting(targeting) {
        this.targeting.set(targeting.id, targeting);
    }
    removeTargeting(targeting) {
        this.targeting.delete(targeting.id);
    }
    get position() { return this.owner.position; }
    get relativePosition() { return this.owner.relativePosition; }
}
exports.default = BasicTargetable;

},{}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BasicTargeting {
    constructor(owner) {
        this.owner = owner;
        this.target = null;
    }
    clearTarget() {
        if (this.target !== null) {
            this.target.removeTargeting(this);
        }
        this._target = null;
    }
    setTarget(targetable) {
        if (this.target !== null) {
            this.target.removeTargeting(this);
        }
        this.target = targetable;
        this.target.addTargeting(this);
    }
    getTarget() {
        if (this.target === null) {
            throw new Error("Target not set!");
        }
        return this.target;
    }
    hasTarget() {
        return this.target !== null;
    }
    get id() { return this.owner.id; }
    get target() { return this._target; }
    set target(target) { this._target = target; }
}
exports.default = BasicTargeting;

},{}],142:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../../Wolfie2D/DataTypes/Vec2"));
/**
 * A wrapper class around a Vec2 implementing the Positioned interface. The point
 * of this class is to let you use an arbitrary position as a TargetableEntity.
 */
class Position {
    constructor(x, y) {
        this._position = new Vec2_1.default(x, y);
    }
    get position() {
        return this._position;
    }
}
exports.default = Position;

},{"../../../Wolfie2D/DataTypes/Vec2":26}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuState = void 0;
var MenuState;
(function (MenuState) {
    MenuState["HIDDEN"] = "HIDDEN";
    MenuState["SHOWN"] = "SHOWN";
    MenuState["CONTROL_TEXT_MENU_SHOWN"] = "CONTROL_TEXT_MENU_SHOWN";
    MenuState["HELP_TEXT_MENU_SHOWN"] = "HELP_TEXT_MENU_SHOWN";
})(MenuState = exports.MenuState || (exports.MenuState = {}));

},{}],144:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = __importDefault(require("../../Wolfie2D/DataTypes/Collections/Stack"));
const NavigationPath_1 = __importDefault(require("../../Wolfie2D/Pathfinding/NavigationPath"));
const NavigationStrategy_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Strategies/NavigationStrategy"));
// TODO Construct a NavigationPath object using A*
class Node {
    constructor(index, parent, g, h) {
        this.index = index;
        this.parent = parent;
        this.g = g;
        this.h = h;
    }
}
/**
 * The AstarStrategy class is an extension of the abstract NavPathStrategy class. For our navigation system, you can
 * now specify and define your own pathfinding strategy. Originally, the two options were to use Djikstras or a
 * direct (point A -> point B) strategy. The only way to change how the pathfinding was done was by hard-coding things
 * into the classes associated with the navigation system.
 *
 * - Peter
 */
class AstarStrategy extends NavigationStrategy_1.default {
    /**
     * @see NavPathStrat.buildPath()
     */
    buildPath(to, from) {
        let start = this.mesh.graph.snap(from);
        let end = this.mesh.graph.snap(to);
        let pathStack = new Stack_1.default(this.mesh.graph.numVertices);
        if (start == end) {
            return new NavigationPath_1.default(pathStack);
        }
        let pathNode = this.endNode(start, end);
        // pathStack.push(to.clone());
        pathStack.push(this.mesh.graph.positions[end]);
        while (pathNode != null) {
            pathStack.push(this.mesh.graph.positions[pathNode.index]);
            pathNode = pathNode.parent;
        }
        // pathStack.push(this.mesh.graph.positions[start]);
        if (pathStack.size() == 1) {
            let emptyStack = new Stack_1.default(0);
            return new NavigationPath_1.default(emptyStack);
        }
        return new NavigationPath_1.default(pathStack);
    }
    endNode(start, end) {
        let startVec = this.mesh.graph.positions[start];
        let endVec = this.mesh.graph.positions[end];
        let openList = new Array();
        let closedList = new Array(this.mesh.graph.numVertices);
        openList.push(new Node(start, null, 0, endVec.distanceTo(startVec)));
        closedList[start] = true;
        while (openList.length > 0) {
            //find node with lowest f=g+h value
            let curr = openList.reduce((a, b) => a.g + a.h < b.g + b.h ? a : b);
            openList.splice(openList.indexOf(curr), 1);
            if (curr.index == end)
                return curr;
            let edge = this.mesh.graph.getEdges(curr.index);
            while (edge != null) {
                if (!closedList[edge.y]) {
                    let adjNode = new Node(edge.y);
                    let position = this.mesh.graph.positions[edge.y];
                    adjNode.g = position.distanceTo(this.mesh.graph.positions[curr.index]) + curr.g;
                    adjNode.h = position.distanceTo(endVec);
                    adjNode.parent = curr;
                    openList.push(adjNode);
                    closedList[edge.y] = true;
                }
                edge = edge.next;
            }
        }
        return null;
    }
}
exports.default = AstarStrategy;

},{"../../Wolfie2D/DataTypes/Collections/Stack":10,"../../Wolfie2D/Pathfinding/NavigationPath":63,"../../Wolfie2D/Pathfinding/Strategies/NavigationStrategy":65}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerStatsColorArray = exports.PlayerStatsNameArray = exports.PlayerStatsArray = void 0;
exports.PlayerStatsArray = ['currentHealth', 'currentEnergy', 'currentShield'];
exports.PlayerStatsNameArray = ['HP', 'ENERGY', 'SHIELD'];
exports.PlayerStatsColorArray = ['GREEN', 'CYAN', 'ORANGE'];

},{}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HudEvent = exports.ItemEvent = exports.MessageBoxEvents = exports.PlayerEvents = exports.BattlerEvents = void 0;
var BattlerEvents;
(function (BattlerEvents) {
    BattlerEvents["MONSTER_DEAD"] = "MONSTER_DEAD";
    BattlerEvents["MONSTER_HIT"] = "MONSTER_HIT";
    BattlerEvents["MONSTER_ATTACK"] = "MONSTER_ATTACK";
    BattlerEvents["PRINCE_HIT"] = "PRINCE_HIT";
    BattlerEvents["PRINCE_DEAD"] = "PRINCE_DEAD";
    BattlerEvents["PRINCE_ATTACK"] = "PRINCE_ATTACK";
})(BattlerEvents = exports.BattlerEvents || (exports.BattlerEvents = {}));
var PlayerEvents;
(function (PlayerEvents) {
    PlayerEvents["LEVEL_END"] = "LEVEL_END";
    PlayerEvents["PLAYER_ENTERED_LEVEL_END"] = "PLAYER_ENTERED_LEVEL_END";
})(PlayerEvents = exports.PlayerEvents || (exports.PlayerEvents = {}));
var MessageBoxEvents;
(function (MessageBoxEvents) {
    MessageBoxEvents["SHOW"] = "SHOW";
    MessageBoxEvents["HIDDEN"] = "HIDDEN";
    MessageBoxEvents["INVALID_ACTION"] = "You can not perform that action.";
    MessageBoxEvents["ITEM_NOT_FOUND"] = "That item cannot be found in your inventory.";
    MessageBoxEvents["SKILL_ON_CD"] = "That skill is on cooldown.";
    MessageBoxEvents["USE_DOOR"] = "The destaination has been shown";
    MessageBoxEvents["USE_LANTERN"] = "The visible area are increased";
    MessageBoxEvents["USE_HEALTH_PACK"] = "Health pack is used";
    MessageBoxEvents["USE_PHASING_POTION"] = "The character is able to phase through the wall";
})(MessageBoxEvents = exports.MessageBoxEvents || (exports.MessageBoxEvents = {}));
var ItemEvent;
(function (ItemEvent) {
    ItemEvent["ITEM_REQUEST"] = "ITEM_REQUEST";
    ItemEvent["LASERGUN_FIRED"] = "LASERGUN_FIRED";
    ItemEvent["WEAPON_USED"] = "WEAPON_USED";
    ItemEvent["CONSUMABLE_USED"] = "CONSUMABLE_USED";
    ItemEvent["INVENTORY_CHANGED"] = "INVENTORY_CHANGED";
})(ItemEvent = exports.ItemEvent || (exports.ItemEvent = {}));
var HudEvent;
(function (HudEvent) {
    HudEvent["HEALTH_CHANGE"] = "HEALTH_CHANGE";
    HudEvent["USE_HPACK"] = "USE_HPACK";
})(HudEvent = exports.HudEvent || (exports.HudEvent = {}));

},{}],147:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const Scene_1 = __importDefault(require("../../Wolfie2D/Scene/Scene"));
const LaserGuns_1 = __importDefault(require("../GameSystems/ItemSystem/Items/LaserGuns"));
const Label_1 = __importDefault(require("../../Wolfie2D/Nodes/UIElements/Label"));
const Color_1 = __importDefault(require("../../Wolfie2D/Utils/Color"));
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const CustomizedButton_1 = require("../CustomizedButton");
const Text_1 = require("../Text");
const PlayerStatsArray_1 = require("../PlayerStatsArray");
const GraphicTypes_1 = require("../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const ProjectEvents_1 = require("../ProjectEvents");
// scene import
// import IntroLevelScene from "./IntroLevelScene";
// import StartScene from "./StartScene";
const SelectLevelMenuScene_1 = __importDefault(require("./SelectLevelMenuScene"));
const GameNode_1 = require("../../Wolfie2D/Nodes/GameNode");
const EaseFunctions_1 = require("../../Wolfie2D/Utils/EaseFunctions");
const Timer_1 = __importDefault(require("../../Wolfie2D/Timing/Timer"));
const Input_1 = __importDefault(require("../../Wolfie2D/Input/Input"));
const PlayerActor_1 = __importDefault(require("../Actors/PlayerActor"));
const CustomizedButton_2 = require("../CustomizedButton");
const AABB_1 = __importDefault(require("../../Wolfie2D/DataTypes/Shapes/AABB"));
const PlayerAI_1 = __importDefault(require("../AI/Player/PlayerAI"));
const GameItemsArray_1 = require("../GameItemsArray");
const PlayerController_1 = require("../AI/Player/PlayerController");
const ActionType_1 = require("../ActionType");
const GameLayers_1 = require("../GameLayers");
const Controls_1 = require("../Controls");
const PositionGraph_1 = __importDefault(require("../../Wolfie2D/DataTypes/Graphs/PositionGraph"));
const Navmesh_1 = __importDefault(require("../../Wolfie2D/Pathfinding/Navmesh"));
const MathUtils_1 = __importDefault(require("../../Wolfie2D/Utils/MathUtils"));
const AstarStrategy_1 = __importDefault(require("../Pathfinding/AstarStrategy"));
const NPCActor_1 = __importDefault(require("../Actors/NPCActor"));
const MenuState_1 = require("../MenuState");
const SlimeBehavior_1 = __importDefault(require("../AI/NPC/NPCBehavior/SlimeBehavior"));
const BasicTargetable_1 = __importDefault(require("../GameSystems/Targeting/BasicTargetable"));
const Position_1 = __importDefault(require("../GameSystems/Targeting/Position"));
//
const GameEventType_1 = require("../../Wolfie2D/Events/GameEventType");
class ProjectScene extends Scene_1.default {
    constructor(viewport, sceneManager, renderingManager, options) {
        super(viewport, sceneManager, renderingManager, Object.assign(Object.assign({}, options), { physics: {
            // groupNames: [PhysicsGroups.PLAYER],
            } }));
        //button event
        this.PauseButtonEvent = CustomizedButton_2.PauseButtonEvent;
        this.emptyString = "";
        this.action = "action";
        this.GameLayers = GameLayers_1.GameLayers;
        this.backButtonPosition = new Vec2_1.default(50, 50);
        this.playerInitPosition = new Vec2_1.default(260, 235);
        // protected playerInitPosition = new Vec2(100, 90);
        this.levelEndPosition = new Vec2_1.default(260, 490);
        this.levelEndHalfSize = new Vec2_1.default(25, 25);
        this.levelEndColor = new Color_1.default(255, 0, 0, 0.5);
        this.playerMaxStatValue = 10;
        this.ultimateWaveKey = "ultimateWave";
        this.ultimateWaveFiredposition = new Vec2_1.default(0, 0);
        this.ultimateWavePlayerDistance = 40;
        //ui
        this.inGameControlTextBackground = "inGameControlTextBackground";
        this.inGameHelpTextBackground = "inGameHelpTextBackground";
        // Health labels
        this.PlayerStatUI = {};
        this.oneStatUI = {
            label: Label_1.default,
            bar: Label_1.default,
            barBg: Label_1.default,
        };
        //items to game 
        this.gameItemsArray = GameItemsArray_1.GameItemsArray;
        this.gameItemsMap = new Map();
        this.laserGunsKey = "laserGuns";
        this.lanternDuration = false;
        this.inventorySlotsMap = new Map();
        // relative path to the assets
        this.pathToItems = `shadowMaze_assets/data/items/`;
        this.pathToSprite = `shadowMaze_assets/sprites/`;
        this.visibleGroup = [];
        this.labelSize = 32;
        this.isPauseMenuHidden = true;
        this.MenuCurentState = MenuState_1.MenuState.HIDDEN;
        this.option = {
            isAstarChecked: false,
            isfogOfWarChecked: false,
        };
        // this.ButtonSelection = MainMenuButtonEvent;
        // for (const layerName of this.layerNames) {
        //     this[layerName] = layerName;
        // }
        this.battlers = new Array();
    }
    initScene(option) {
        if (option !== undefined)
            this.option = option;
    }
    initLevelScene() {
        this.center = this.getViewport().getCenter();
        this.initSubscribe();
        this.levelTransitionTimer = new Timer_1.default(500);
        this.levelEndTimer = new Timer_1.default(1000);
        this.isLevelEndEnetered = false;
        this.initLayers();
        this.levelEndTransitionLabel = this.addTweenLabel(this.levelEndTransitionLabel, ProjectEvents_1.PlayerEvents.LEVEL_END, "slideIn" /* tweensEffect.SLIDEIN */);
        this.messageBoxLabel = this.addTweenLabel(this.messageBoxLabel, ProjectEvents_1.MessageBoxEvents.HIDDEN, "slideIn" /* tweensEffect.SLIDEIN */);
    }
    loadGameItems(key) {
        this.load.object(key, `${this.pathToItems}${key}.json`);
        this.load.image(key, `${this.pathToSprite}${key}.png`);
    }
    loadUltimateWave() {
        let key = this.ultimateWaveKey;
        this.load.image(key, `${this.pathToSprite}${key}.png`);
    }
    initUltimateWave() {
        this.ultimateWave = this.add.sprite(this.ultimateWaveKey, this.GameLayers.BASE);
        this.ultimateWave.visible = false;
        const halfSize = this.player.sizeWithZoom.scale(0.25);
        this.ultimateWave.position.set(this.player.position.x, this.player.position.y);
        this.ultimateWave.setCollisionShape(new AABB_1.default(this.player.position, halfSize));
        this.visibleGroup.push(this.ultimateWave);
    }
    loadAllGameItems() {
        for (let key of this.gameItemsArray) {
            this.loadGameItems(key);
        }
    }
    initInventorySlotsMap() {
        const inventorySlotsPosition = this.load.getObject(GameItemsArray_1.GameItems.INVENTORYSLOT);
        let i = 1;
        for (let position of inventorySlotsPosition.position) {
            const postionItemsMap = new Map();
            postionItemsMap.set(position, []);
            this.inventorySlotsMap.set(i, postionItemsMap);
            i++;
        }
    }
    initAllGameItems() {
        for (let key of this.gameItemsArray) {
            let gameItem = this.load.getObject(key);
            const items = new Array(gameItem.position.length);
            for (let i = 0; i < items.length; i++) {
                let sprite, line;
                if (key === "inventorySlot") {
                    sprite = this.add.sprite(key, this.GameLayers.BEFORE_BASE);
                    line = this.add.graphic(GraphicTypes_1.GraphicType.LINE, this.GameLayers.BEFORE_BASE, { start: Vec2_1.default.ZERO, end: Vec2_1.default.ZERO });
                    let numOfSlots = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, this.GameLayers.BEFORE_BASE, { position: new Vec2_1.default(gameItem.position[i][0] - 17, gameItem.position[i][1]), text: `${i + 1}` });
                    numOfSlots.fontSize = 24;
                    numOfSlots.font = "Courier";
                    numOfSlots.textColor = Color_1.default.BLACK;
                    // numOfSlots.position.set(gameItem.position[i][0]-100, gameItem.position[i][1])
                }
                else {
                    sprite = this.add.sprite(key, this.GameLayers.BASE);
                    line = this.add.graphic(GraphicTypes_1.GraphicType.LINE, this.GameLayers.BASE, { start: Vec2_1.default.ZERO, end: Vec2_1.default.ZERO });
                }
                items[i] = LaserGuns_1.default.create(sprite, line);
                items[i].position.set(gameItem.position[i][0], gameItem.position[i][1]);
                items[i].name = key;
            }
            this.gameItemsMap.set(key, items);
        }
    }
    startScene() {
        let tilemapLayers = this.add.tilemap("level");
        this.walls = tilemapLayers[1].getItems()[0];
        this.wallSize = this.walls.size.x;
        // Set the viewport bounds to the tilemap
        let tilemapSize = this.walls.size;
        this.viewport.setBounds(0, 0, tilemapSize.x, tilemapSize.y);
        this.viewport.setZoomLevel(2);
        // this.initLayers();
        this.initLevelScene();
        this.initPlayer();
        let navmesh = this.initializeNavmesh(new PositionGraph_1.default(), this.walls);
        navmesh.registerStrategy("astar", new AstarStrategy_1.default(navmesh));
        navmesh.setStrategy("astar");
        this.navManager.addNavigableEntity("navmesh", navmesh);
        this.initInventorySlotsMap();
        // create screen first 
        if (!this.option.isfogOfWarChecked)
            // this.initFogOfWar();
            this.center = this.viewport.getHalfSize();
        this.initPauseMenuLayer();
        this.initializeLevelEnds();
        this.initAllGameItems();
        if (!this.option.isAstarChecked) {
            this.initPlayerStatUI();
            this.initNPCs();
        }
        this.emitter.fireEvent(GameEventType_1.GameEventType.PLAY_SOUND, { key: this.levelMusicKey, loop: true, holdReference: true });
    }
    initNPCs() {
        let monster = this.load.getObject("monster");
        for (let i = 0; i < monster.slime.length; i++) {
            let npc = this.add.animatedSprite(NPCActor_1.default, "black_pudding", this.GameLayers.BASE);
            npc.position.set(monster.slime[i][0], monster.slime[i][1]);
            npc.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
            npc.scale = new Vec2_1.default(0.15, 0.15);
            npc.navkey = "navmesh";
            npc.addAI(SlimeBehavior_1.default, { target: new BasicTargetable_1.default(new Position_1.default(npc.position.x, npc.position.y)), range: 100 });
            npc.animation.play("IDLE", true);
            this.battlers.push(npc);
        }
        for (let i = 0; i < monster.troll.length; i++) {
            let npc = this.add.animatedSprite(NPCActor_1.default, "troll", this.GameLayers.BASE);
            npc.position.set(monster.troll[i][0], monster.troll[i][1]);
            npc.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(7, 7)), null, false);
            npc.scale = new Vec2_1.default(1.5, 1.5);
            const halfSize = this.player.sizeWithZoom.scale(0.1);
            npc.setCollisionShape(new AABB_1.default(npc.position, halfSize));
            npc.navkey = "navmesh";
            npc.addAI(SlimeBehavior_1.default, { target: new BasicTargetable_1.default(new Position_1.default(npc.position.x, npc.position.y)), range: 100 });
            npc.animation.play("IDLE", true);
            this.battlers.push(npc);
        }
    }
    loadScene() {
        this.loadAllGameItems();
        // this.loadGameItems(this.laserGunsKey);
        this.load.spritesheet("prince", "shadowMaze_assets/spritesheets/prince.json");
        // Load the tilemap
        this.load.tilemap("level", "shadowMaze_assets/tilemaps/futureLevel.json");
    }
    buildLanternShape(position) {
        const lightDistance = 1 * this.labelSize;
        const centerToEdge = new Vec2_1.default(lightDistance, lightDistance);
        this.lanternShape = new AABB_1.default(position, centerToEdge);
        return this.lanternShape;
    }
    initSubscribe() {
        this.initGameEventSubscribe([
            ...Object.values(ProjectEvents_1.BattlerEvents),
            ...Object.values(ProjectEvents_1.PlayerEvents),
            ...Object.values(ProjectEvents_1.MessageBoxEvents),
        ]);
        this.receiver.subscribe(PlayerController_1.PlayerInput.ULTIMATE);
        this.initGameItemEventSubscribe();
    }
    initGameEventSubscribe(gameEvents) {
        for (const event of gameEvents) {
            this.receiver.subscribe(event);
        }
    }
    initGameItemEventSubscribe() {
        for (let gameItemKey of GameItemsArray_1.GameItemsArray) {
            this.receiver.subscribe(gameItemKey);
        }
    }
    initPlayerStatUI() {
        // UILayer stuff
        // this.addUILayer(GAMELayers.UIlayer);
        // HP Label
        const currentStat = this.player._ai["currentStat"];
        let yOffset = 10;
        let index = 0;
        let newText;
        for (const stat of Object.keys(currentStat)) {
            let statUI = {
                label: null,
                bar: null,
                barBg: null,
            };
            if (PlayerStatsArray_1.PlayerStatsNameArray[index] == 'HP') {
                newText = PlayerStatsArray_1.PlayerStatsNameArray[index];
            }
            else {
                newText = "    " + PlayerStatsArray_1.PlayerStatsNameArray[index];
            }
            //bar
            statUI.label = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, GameLayers_1.GameLayers.BASE, { position: new Vec2_1.default(10, yOffset), text: newText });
            statUI.label.size.set(300, 30);
            statUI.label.fontSize = 24;
            statUI.label.font = "Courier";
            //background
            statUI.bar = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, GameLayers_1.GameLayers.BASE, { position: new Vec2_1.default(75, yOffset), text: "" });
            statUI.bar.size = new Vec2_1.default(300, 25);
            statUI.bar.backgroundColor = Color_1.default[PlayerStatsArray_1.PlayerStatsColorArray[index]];
            //border
            statUI.barBg = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, GameLayers_1.GameLayers.BASE, { position: new Vec2_1.default(75, yOffset), text: "" });
            statUI.barBg.size = new Vec2_1.default(300, 25);
            statUI.barBg.borderColor = Color_1.default.BLACK;
            yOffset += 20;
            index++;
            this.PlayerStatUI[stat] = statUI;
            this.handlePlayerStatChange(stat);
        }
    }
    addLabel(option) {
        const newTextLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, option.layerName || this.GameLayers.BASE, option);
        if (option.size)
            newTextLabel.size.set(option.size.x, option.size.y);
        else
            newTextLabel.size.set(300, 100);
        newTextLabel.borderWidth = 2;
        newTextLabel.setTextColor(option.textColor || Color_1.default.WHITE);
        newTextLabel.setFont(option.font || "Arial");
        newTextLabel.setFontSize(option.fontSize || 28);
        newTextLabel.setBackgroundColor(option.backgroundColor || Color_1.default.BLACK);
        if (option.align)
            newTextLabel.setHAlign(option.align);
        return newTextLabel;
    }
    handleEnteredLevelEnd() {
        if (!this.isLevelEndEnetered) {
            this.isLevelEndEnetered = true;
            this.levelEndTransitionLabel.tweens.play("slideIn" /* tweensEffect.SLIDEIN */);
        }
    }
    initializeLevelEnds() {
        this.levelEndArea = this.add.graphic(GraphicTypes_1.GraphicType.RECT, this.GameLayers.BASE, { position: this.levelEndPosition, size: this.levelEndHalfSize });
        this.levelEndArea.addPhysics(undefined, undefined, false, true);
        // this.levelEndArea.setTrigger(PhysicsGroups.PLAYER, PlayerEvents.PLAYER_ENTERED_LEVEL_END, null);
        // this.levelEndArea.setTrigger(HW3PhysicsGroups.PLAYER, HW3Events.PLAYER_ENTERED_LEVEL_END, null);
        this.levelEndArea.color = this.levelEndColor;
    }
    addTweenLabel(label, onEndEvent, effect) {
        if (effect == "slideIn" /* tweensEffect.SLIDEIN */) {
            label = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, GameLayers_1.GameLayers.UI, { position: new Vec2_1.default(-500, 96), text: "Level Complete" });
            label.tweens.add("slideIn" /* tweensEffect.SLIDEIN */, {
                startDelay: 0,
                duration: 1000,
                effects: [
                    {
                        property: GameNode_1.TweenableProperties.posX,
                        start: 0,
                        end: 270,
                        ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                    }
                ],
                onEnd: onEndEvent,
            });
            label.tweens.add("slideOut" /* tweensEffect.SLIDEOUT */, {
                startDelay: 1000,
                duration: 1000,
                effects: [
                    {
                        property: GameNode_1.TweenableProperties.posX,
                        start: 270,
                        end: 1000,
                        ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                    }
                ],
                // onEnd: onEndEvent,
            });
            label.size.set(1200, 60);
            label.borderRadius = 0;
            label.backgroundColor = new Color_1.default(34, 32, 52);
            label.textColor = Color_1.default.WHITE;
            label.fontSize = 48;
            label.font = "PixelSimple";
        }
        else {
            label = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, GameLayers_1.GameLayers.UI, { position: new Vec2_1.default(300, 200), text: "" });
            label.alpha = 1;
            label.tweens.add("fadeIn" /* tweensEffect.FADEIN */, {
                startDelay: 0,
                duration: 1000,
                effects: [
                    {
                        property: GameNode_1.TweenableProperties.alpha,
                        start: 0,
                        end: 1,
                        ease: EaseFunctions_1.EaseFunctionType.IN_OUT_QUAD
                    }
                ],
                onEnd: onEndEvent,
            });
            label.tweens.add("fadeOut" /* tweensEffect.FADEOUT */, {
                startDelay: 0,
                duration: 1000,
                effects: [
                    {
                        property: GameNode_1.TweenableProperties.alpha,
                        start: 1,
                        end: 0,
                        ease: EaseFunctions_1.EaseFunctionType.IN_OUT_QUAD
                    }
                ],
            });
        }
        return label;
    }
    addButtons(option) {
        const newButton = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, option.layerName || this.GameLayers.BASE, option);
        newButton.size.set(50, 50);
        if (option.size)
            newButton.size.set(option.size.x, option.size.y);
        newButton.setBorderWidth(option.borderWidth || 0);
        newButton.setBorderColor(option.BorderColor || Color_1.default.TRANSPARENT);
        newButton.setBackgroundColor(option.backgroundColor || Color_1.default.BLACK);
        newButton.setTextColor(option.textColor || Color_1.default.WHITE);
        newButton.onClickEventId = option.buttonName;
        newButton.setFontSize(50);
        this.receiver.subscribe(option.buttonName);
        return newButton;
    }
    addBackButon(position) {
        const leftArrow = '\u2190';
        let buttonOption = {
            position: new Vec2_1.default(position.x, position.y),
            text: leftArrow,
            buttonName: CustomizedButton_1.BackButtonEvent.BACK,
        };
        this.addButtons(buttonOption);
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            const gameEvent = this.receiver.getNextEvent();
            this.handleEvent(gameEvent);
        }
        if (Input_1.default.isKeyJustPressed("escape")) {
            this.emitter.fireEvent(CustomizedButton_2.PauseButtonEvent.PAUSE);
        }
        this.updateVisibleGroup();
        if (this.option.isAstarChecked) {
            this.player.moveOnPath(1, this.path);
            if (this.path.isDone()) {
                this.handleEnteredLevelEnd();
            }
        }
        else {
            this.handlePlayerStatChange("currentShield");
            this.isPlayerAtItems();
            this.isPlayerAttacking();
            this.isPlayerUseItem();
        }
        this.isPlayerAtLevelEnd();
    }
    updateVisibleGroup() {
        this.updateTranparentLabels(this.player);
        if (this.ultimateWave.visible) {
            const distance = this.ultimateWave.position.distanceTo(this.player.position);
            const f = this.ultimateWave.collisionShape.overlaps(this.player.collisionShape);
            if (distance > this.ultimateWavePlayerDistance) {
                if (!this.ultimateWave.currentTransparentLabels) {
                    this.ultimateWave.currentTransparentLabels = this.initTransparentLabelByPosition(this.ultimateWave.position);
                }
                else
                    this.updateTranparentLabels(this.ultimateWave);
            }
            this.updateUltimateWave();
        }
    }
    isUltimateLeftPlayer() {
        let lables = this.getLabelsByPosition(this.ultimateWave.position);
        lables = lables.filter(label => label.backgroundColor == Color_1.default.FOG_OF_WAR_TRANSPARENT);
        return lables.length == 0;
    }
    updateUltimateWave() {
        let oldPosition = this.ultimateWave.position;
        let travellingDirectionVec = this.ultimateWaveDirection;
        // this.ultimateWave.currentTransparentLabels = this.initTransparentLabelByPosition(this.ultimateWave.position);
        const ratio = 8;
        this.ultimateWave.position.set(oldPosition.x + travellingDirectionVec.x / ratio, oldPosition.y + travellingDirectionVec.y / ratio);
        if (this.hasVecOutOfBound(this.ultimateWave.position.x) ||
            this.hasVecOutOfBound(this.ultimateWave.position.y)) {
            this.ultimateWave.visible = false;
            this.ultimateWave.currentTransparentLabels.forEach(label => {
                this.updateTranparentLablesColor(label);
            });
            this.ultimateWave.currentTransparentLabels = undefined;
        }
        this.checkUltimateMonstersCollision();
    }
    checkUltimateMonstersCollision() {
        this.battlers.forEach(battler => {
            if (battler.battlerActive && !(battler == this.player)) {
                if (battler.position.distanceTo(this.ultimateWave.position) < 10) {
                    this.emitter.fireEvent(ProjectEvents_1.BattlerEvents.MONSTER_DEAD, { id: battler.id });
                }
            }
        });
    }
    hasVecOutOfBound(x) {
        if (x < -15 || x > 540)
            return true;
        else
            return false;
    }
    isPlayerUseItem() {
        Controls_1.ItemButtonArray.forEach(key => {
            if (Input_1.default.isKeyJustPressed(key)) {
                const positionItemMap = this.inventorySlotsMap.get(parseInt(key));
                for (let [key, value] of positionItemMap.entries()) {
                    if (value.length != 0) {
                        const gameItem = value.pop();
                        this.emitter.fireEvent(gameItem.name, { action: ActionType_1.ACTIONTYPE.USE, gameItem: gameItem });
                        return;
                    }
                    else {
                        this.emitter.fireEvent(ProjectEvents_1.MessageBoxEvents.SHOW, { message: ProjectEvents_1.MessageBoxEvents.ITEM_NOT_FOUND });
                    }
                }
            }
        });
    }
    isPlayerAtLevelEnd() {
        if (this.levelEndPosition.distanceSqTo(this.player.position) < 10) {
            if (!this.isLevelEndEnetered)
                this.emitter.fireEvent(ProjectEvents_1.PlayerEvents.PLAYER_ENTERED_LEVEL_END);
        }
    }
    handleEvent(event) {
        if (event.data.get(this.action) == ActionType_1.ACTIONTYPE.PICK)
            this.handlePickGameItemsEvent(event);
        if (event.data.get(this.action) == ActionType_1.ACTIONTYPE.USE)
            this.handleUseGameItemsEvent(event);
        this.handleBattlerEvents(event);
        this.handleInGameMessageBox(event);
    }
    handleInGameMessageBox(event) {
        switch (event.type) {
            case ProjectEvents_1.MessageBoxEvents.SHOW:
                this.messageBoxLabel.text = event.data.get("message");
                this.messageBoxLabel.tweens.play("slideIn" /* tweensEffect.SLIDEIN */);
                break;
            case ProjectEvents_1.MessageBoxEvents.HIDDEN:
                console.log("Fades out");
                this.messageBoxLabel.tweens.play("slideOut" /* tweensEffect.SLIDEOUT */);
        }
    }
    handleBattlerEvents(event) {
        switch (event.type) {
            case ProjectEvents_1.BattlerEvents.MONSTER_DEAD: {
                this.handleBattlerKilled(event);
                if (this.player._ai["currentStat"]["currentEnergy"] < this.playerMaxStatValue) {
                    this.player._ai["currentStat"]["currentEnergy"]++;
                    this.handlePlayerStatChange("currentEnergy");
                }
                break;
            }
            case ProjectEvents_1.BattlerEvents.PRINCE_HIT: {
                if (!this.player._ai["isInvincible"]) {
                    this.player._ai["currentStat"]["currentHealth"]--;
                    this.handlePlayerStatChange("currentHealth");
                }
                break;
            }
            case ProjectEvents_1.BattlerEvents.PRINCE_DEAD: {
                setTimeout(() => {
                    this.viewport.setZoomLevel(1);
                    this.sceneManager.changeToScene(SelectLevelMenuScene_1.default, this.option);
                }, 2000);
            }
            case PlayerController_1.PlayerInput.ULTIMATE: {
                if (!this.ultimateWave.visible)
                    this.handleFireUltimate();
            }
        }
    }
    handleFireUltimate() {
        this.ultimateWave.visible = true;
        let faceDirectionVec = this.getFaceDirectionVec();
        this.ultimateWave.position.set(faceDirectionVec.x, faceDirectionVec.y);
        this.ultimateWaveDirection = faceDirectionVec.sub(this.player.position);
        // this.ultimateWave.currentTransparentLabels = this.initTransparentLabelByPosition(this.ultimateWave.position);
        this.ultimateWave.rotation = this.player.rotation;
        this.ultimateWaveFiredposition.x = this.player.position.x;
        this.ultimateWaveFiredposition.y = this.player.position.y;
    }
    handleBattlerKilled(event) {
        let id = event.data.get("id");
        let battler = this.battlers.find(b => b.id === id);
        if (battler) {
            battler.battlerActive = false;
        }
    }
    handleUseGameItemsEvent(event) {
        this.RemoveItemFromInventory(event);
        switch (event.type) {
            case GameItemsArray_1.GameItems.LANTERNS: {
                this.lanternDuration = !this.lanternDuration;
                this.ultimateWavePlayerDistance = 70;
                this.emitter.fireEvent(ProjectEvents_1.MessageBoxEvents.SHOW, { message: ProjectEvents_1.MessageBoxEvents.USE_LANTERN });
                break;
            }
            case GameItemsArray_1.GameItems.DOOR: {
                this.showPositionByColor(this.levelEndPosition, Color_1.default.TRANSPARENT);
                this.emitter.fireEvent(ProjectEvents_1.MessageBoxEvents.SHOW, { message: ProjectEvents_1.MessageBoxEvents.USE_DOOR });
                break;
            }
            case GameItemsArray_1.GameItems.HEALTH_PACKS: {
                if (this.player._ai["currentStat"]["currentHealth"] < this.playerMaxStatValue)
                    this.player._ai["currentStat"]["currentHealth"]++;
                this.handlePlayerStatChange("currentHealth");
                this.emitter.fireEvent(ProjectEvents_1.MessageBoxEvents.SHOW, { message: ProjectEvents_1.MessageBoxEvents.USE_HEALTH_PACK });
                break;
            }
            case GameItemsArray_1.GameItems.PHASINGPOTION: {
                const halfSize = this.player.sizeWithZoom.scale(0);
                this.player.setCollisionShape(new AABB_1.default(this.player.position, halfSize));
                this.emitter.fireEvent(ProjectEvents_1.MessageBoxEvents.SHOW, { message: ProjectEvents_1.MessageBoxEvents.USE_PHASING_POTION });
            }
        }
    }
    RemoveItemFromInventory(event) {
        const gameItem = event.data.get("gameItem");
        gameItem.visible = false;
    }
    handleMenuStateChange() {
        switch (this.MenuCurentState) {
            case MenuState_1.MenuState.HIDDEN: {
                this.MenuCurentState = MenuState_1.MenuState.SHOWN;
                break;
            }
            case MenuState_1.MenuState.SHOWN: {
                this.MenuCurentState = MenuState_1.MenuState.HIDDEN;
                break;
            }
            case MenuState_1.MenuState.CONTROL_TEXT_MENU_SHOWN: {
                this.MenuCurentState = MenuState_1.MenuState.SHOWN;
                break;
            }
            case MenuState_1.MenuState.HELP_TEXT_MENU_SHOWN: {
                this.MenuCurentState = MenuState_1.MenuState.SHOWN;
                break;
            }
        }
    }
    handleMenuShown() {
        switch (this.MenuCurentState) {
            case MenuState_1.MenuState.HIDDEN: {
                this.setContainerAndMenu(GameLayers_1.GameLayers.PAUSE_MENU_CONTAINER, GameLayers_1.GameLayers.PAUSE_MENU, true);
                break;
            }
            case MenuState_1.MenuState.SHOWN: {
                this.setContainerAndMenu(GameLayers_1.GameLayers.PAUSE_MENU_CONTAINER, GameLayers_1.GameLayers.PAUSE_MENU, false);
                this.setContainerAndMenu(GameLayers_1.GameLayers.CONTROL_TEXT_MENU_CONTAINER, GameLayers_1.GameLayers.CONTROL_TEXT_MENU, true);
                this.setContainerAndMenu(GameLayers_1.GameLayers.HELP_TEXT_MENU_CONTAINER, GameLayers_1.GameLayers.HELP_TEXT_MENU, true);
                break;
            }
            case MenuState_1.MenuState.CONTROL_TEXT_MENU_SHOWN: {
                this.setContainerAndMenu(GameLayers_1.GameLayers.CONTROL_TEXT_MENU_CONTAINER, GameLayers_1.GameLayers.CONTROL_TEXT_MENU, false);
                break;
            }
            case MenuState_1.MenuState.HELP_TEXT_MENU_SHOWN: {
                this.setContainerAndMenu(GameLayers_1.GameLayers.HELP_TEXT_MENU_CONTAINER, GameLayers_1.GameLayers.HELP_TEXT_MENU, false);
                break;
            }
        }
    }
    setContainerAndMenu(container, menu, flag) {
        this.getLayer(container).setHidden(flag);
        this.getLayer(menu).setHidden(flag);
    }
    handlePickGameItemsEvent(event) {
        this.putItemToInventory(event);
    }
    putItemToInventory(event) {
        const gameItem = event.data.get("gameItem");
        for (let postionItemsMap of Array.from(this.inventorySlotsMap.values())) {
            for (const [key, value] of postionItemsMap) {
                if (value.length === 0) {
                    gameItem.position.set(key[0], key[1]);
                    postionItemsMap.set(key, [gameItem]);
                    return;
                }
            }
        }
    }
    showPositionByColor(position, color) {
        const labels = this.getLabelsByPosition(position);
        labels.forEach(label => {
            if (label.backgroundColor) {
                if (label.backgroundColor.isEqual(Color_1.default.FOG_OF_WAR_BLACK)) {
                    label.backgroundColor = color;
                }
                else if (label.backgroundColor.isEqual(Color_1.default.TRANSPARENT)) {
                    label.backgroundColor = color;
                }
            }
        });
    }
    initTransparentLabelByPosition(position) {
        const labels = this.getLabelsByPosition(position);
        labels.forEach(label => { this.updateTranparentLablesColor(label); });
        return labels;
    }
    updateTranparentLabels(sprite) {
        let nextTransparentLabels = this.getLabelsByPosition(sprite.position);
        sprite.currentTransparentLabels.forEach(label => { this.updateTranparentLablesColor(label); });
        nextTransparentLabels.forEach(label => this.updateTranparentLablesColor(label));
        sprite.currentTransparentLabels = nextTransparentLabels;
    }
    getLabelsByPosition(postion) {
        let labels;
        if (!this.lanternDuration) {
            labels = this.getSceneGraph().getNodesAt(postion);
        }
        else {
            labels = this.getSceneGraph().getNodesInRegion(this.buildLanternShape(postion));
        }
        labels = labels.filter(label => label.getLayer().getName() == GameLayers_1.GameLayers.FOG_OF_WAR);
        return labels;
    }
    updateTranparentLablesColor(label) {
        if (label.backgroundColor) {
            if (label.backgroundColor.isEqual(Color_1.default.FOG_OF_WAR_BLACK)) {
                label.backgroundColor = Color_1.default.FOG_OF_WAR_TRANSPARENT;
            }
            else if (label.backgroundColor.isEqual(Color_1.default.FOG_OF_WAR_TRANSPARENT)) {
                label.backgroundColor = Color_1.default.FOG_OF_WAR_BLACK;
            }
        }
    }
    initLayers() {
        let depth = 1;
        for (const layer in GameLayers_1.GameLayers) {
            this.addLayer(layer, depth);
            depth++;
        }
        this.setContainerAndMenu(GameLayers_1.GameLayers.PAUSE_MENU_CONTAINER, GameLayers_1.GameLayers.PAUSE_MENU, true);
        this.setContainerAndMenu(GameLayers_1.GameLayers.CONTROL_TEXT_MENU_CONTAINER, GameLayers_1.GameLayers.CONTROL_TEXT_MENU, true);
        this.setContainerAndMenu(GameLayers_1.GameLayers.HELP_TEXT_MENU_CONTAINER, GameLayers_1.GameLayers.HELP_TEXT_MENU, true);
    }
    handlePlayerStatChange(type) {
        // this.PlayerStatUI[PlayerStatsNameArray[index]] = statUI;
        let oneStatUI = this.PlayerStatUI[type];
        const currentStatValue = this.player._ai["currentStat"][type];
        let unit = oneStatUI["barBg"].size.x / this.playerMaxStatValue;
        oneStatUI["bar"].size.set(oneStatUI["barBg"].size.x - unit * (this.playerMaxStatValue - currentStatValue), oneStatUI["barBg"].size.y);
        oneStatUI["bar"].position.set(oneStatUI["barBg"].position.x - (unit / 2 / this.getViewScale()) * (this.playerMaxStatValue - currentStatValue), oneStatUI["barBg"].position.y);
        if (type == "currentHealth")
            oneStatUI["bar"].backgroundColor = currentStatValue < this.playerMaxStatValue * 1 / 4 ? Color_1.default.RED : currentStatValue < this.playerMaxStatValue * 3 / 4 ? Color_1.default.YELLOW : Color_1.default.GREEN;
    }
    isPlayerAttacking() {
        let midpoint = this.getFaceDirectionVec();
        for (const battler of this.battlers) {
            if (battler == this.player) {
                continue;
            }
            if (battler.battlerActive && battler.position.distanceTo(midpoint) <= 15 && this.player.animation.isPlaying("ATTACKING")) {
                this.emitter.fireEvent(ProjectEvents_1.BattlerEvents.MONSTER_DEAD, { id: battler.id });
            }
            if (battler.battlerActive && battler.position.distanceTo(this.player.position) < 10) {
                if (!this.player._ai['isInvincible'])
                    this.emitter.fireEvent(ProjectEvents_1.BattlerEvents.PRINCE_HIT, { id: battler.id });
            }
        }
    }
    getFaceDirectionVec() {
        let midpoint = new Vec2_1.default(this.player.position.x, this.player.position.y);
        switch (this.player.rotation) {
            case 0:
                // midpoint = new Vec2(this.player.position.x, this.player.position.y - 15);
                midpoint.y = this.player.position.y - 15;
                break;
            case 3.15:
                midpoint.y = this.player.position.y + 15;
                break;
            case 1.5:
                midpoint.x = this.player.position.x - 15;
                break;
            case 4.75:
                midpoint.x = this.player.position.x + 15;
                break;
            case 5.25:
                midpoint.x = this.player.position.x + 10;
                midpoint.y = this.player.position.y - 10;
                break;
            case 0.75:
                midpoint.x = this.player.position.x - 10;
                midpoint.y = this.player.position.y - 10;
                break;
            case 3.75:
                midpoint.x = this.player.position.x + 10;
                midpoint.y = this.player.position.y + 10;
                break;
            case 2.25:
                midpoint.x = this.player.position.x - 10;
                midpoint.y = this.player.position.y + 10;
                break;
            default:
                midpoint = this.player.position;
                break;
        }
        return midpoint;
    }
    isPlayerAtItems() {
        for (const gameItems of this.gameItemsMap.values()) {
            gameItems.forEach(gameItem => {
                if (gameItem.visible && gameItem.position.distanceTo(this.player.position) < 10) {
                    // gameItem.visible = false;
                    this.emitter.fireEvent(gameItem.name, { action: ActionType_1.ACTIONTYPE.PICK, gameItem: gameItem });
                }
            });
        }
    }
    /**
     * Initializes the player in the scene
     */
    initPlayer() {
        let player = this.add.animatedSprite(PlayerActor_1.default, "prince", this.GameLayers.BASE);
        this.player = player;
        player.position.set(this.playerInitPosition.x, this.playerInitPosition.y);
        player.battleGroup = 2;
        player.scale = new Vec2_1.default(2, 2);
        // Give the player physics
        this.battlers.push(this.player);
        player.addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(8, 8)), null, false);
        const halfSize = this.player.sizeWithZoom.scale(0.125);
        player.setCollisionShape(new AABB_1.default(this.player.position, halfSize));
        player.currentTransparentLabels = this.initTransparentLabelByPosition(this.player.position);
        this.buildLanternShape(this.player.position);
        this.visibleGroup.push(player);
        // Give the player PlayerAI
        if (this.option.isAstarChecked) {
            console.log("Auto Pilot");
            this.initAstarMode();
        }
        else {
            player.addAI(PlayerAI_1.default);
            this.initUltimateWave();
        }
        // 
        player.animation.play("IDLE");
    }
    initAstarMode() {
        let navmesh = this.initializeNavmesh(new PositionGraph_1.default(), this.walls);
        navmesh.registerStrategy("astar", new AstarStrategy_1.default(navmesh));
        this.navManager.addNavigableEntity("navmesh", navmesh);
        navmesh.setStrategy("astar");
        this.player.collisionShape.halfSize.scaleTo(0.25);
        this.path = navmesh.getNavigationPath(this.player.position, this.levelEndPosition);
        console.log(this.path);
    }
    initControlTextLayer() {
        let controlTextOption = {
            position: new Vec2_1.default(450, 450),
            margin: 40,
            layerName: GameLayers_1.GameLayers.CONTROL_TEXT_MENU
        };
        this.addControlTextLayer(controlTextOption);
    }
    addControlTextLayer(option) {
        let position = option.position;
        let yInitPosition = position.y - 400;
        for (let text of Text_1.controlTextArray) {
            yInitPosition += option.margin;
            let textOption = {
                position: new Vec2_1.default(position.x - 150, yInitPosition),
                text: "• " + text,
                align: true,
                layerName: option.layerName,
                fontSize: option.fontSize,
                backgroundColor: Color_1.default.TRANSPARENT,
            };
            this.addLabel(textOption);
        }
    }
    initHelpTextLayer() {
        let helpTextOption = {
            position: new Vec2_1.default(450, 450),
            margin: 40,
            layerName: GameLayers_1.GameLayers.HELP_TEXT_MENU
        };
        this.addHelpTextLayer(helpTextOption);
    }
    addHelpTextLayer(option) {
        let position = option.position;
        let yInitPosition = position.y - 400;
        const newText = Text_1.helpTextArray;
        for (let text of newText) {
            yInitPosition += option.margin;
            let textOption = {
                position: new Vec2_1.default(position.x - 320, yInitPosition),
                text: text,
                align: "left",
                backgroundColor: Color_1.default.TRANSPARENT,
                fontSize: option.fontSize,
                layerName: option.layerName,
            };
            this.addLabel(textOption);
            // this.add.uiElement(UIElementType.LABEL,option.layerName,textOption);
        }
    }
    sceneChange(nextScene) {
        this.viewport.setZoomLevel(1);
        this.sceneManager.changeToScene(nextScene, this.option);
        this.emitter.fireEvent(GameEventType_1.GameEventType.STOP_SOUND, { key: this.levelMusicKey, loop: true, holdReference: true });
    }
    initPauseMenuLayer() {
        const pauseSign = "\u23F8";
        let pauseSignbuttonOption = {
            position: new Vec2_1.default(475, 20),
            text: pauseSign,
            layerName: GameLayers_1.GameLayers.UI,
            buttonName: CustomizedButton_2.PauseButtonEvent.PAUSE,
            backgroundColor: Color_1.default.TRANSPARENT,
        };
        this.addButtons(pauseSignbuttonOption);
        // let emptyMenuOption = {
        //     position: this.center,
        //     text: "",
        //     size: new Vec2(300, 550),
        //     layerName: GameLayers.PAUSE_MENU_CONTAINER,
        //     backgroundColor: Color.WHITE,
        // }
        // this.addLabel(emptyMenuOption);
        this.backgroundImage = this.add.sprite(this.inGameControlTextBackground, GameLayers_1.GameLayers.PAUSE_MENU_CONTAINER);
        this.backgroundImage.position.set(this.center.x, this.center.y + 20);
        this.backgroundImage = this.add.sprite(this.inGameControlTextBackground, GameLayers_1.GameLayers.CONTROL_TEXT_MENU_CONTAINER);
        this.backgroundImage.position.set(this.center.x, this.center.y + 20);
        let controlTextOption = {
            position: new Vec2_1.default(400, 515),
            margin: 30,
            layerName: GameLayers_1.GameLayers.CONTROL_TEXT_MENU
        };
        this.addControlTextLayer(controlTextOption);
        let inGameControlTextBackgroundImage = this.add.sprite(this.inGameHelpTextBackground, GameLayers_1.GameLayers.HELP_TEXT_MENU_CONTAINER);
        inGameControlTextBackgroundImage.position.set(this.center.x, this.center.y + 10);
        let helpTextOption = {
            position: new Vec2_1.default(435, 450),
            margin: 40,
            layerName: GameLayers_1.GameLayers.HELP_TEXT_MENU
        };
        this.addHelpTextLayer(helpTextOption);
        let pauseTextOption = {
            position: new Vec2_1.default(this.center.x, this.center.y - 100),
            text: "Paused",
            size: new Vec2_1.default(100, 30),
            layerName: GameLayers_1.GameLayers.PAUSE_MENU,
            backgroundColor: Color_1.default.WHITE,
            textColor: Color_1.default.BLACK,
        };
        this.addLabel(pauseTextOption);
        let positionY = this.center.y - 60;
        for (let buttonName in CustomizedButton_2.MainMenuButtonEvent) {
            if (buttonName == "Select_levels")
                buttonName = "Select levels";
            let buttonOption1 = {
                position: new Vec2_1.default(this.center.x, positionY),
                text: buttonName,
                layerName: GameLayers_1.GameLayers.PAUSE_MENU,
                buttonName: buttonName,
                backgroundColor: Color_1.default.PURPLE,
                size: new Vec2_1.default(300, 50),
                textColor: Color_1.default.WHITE,
            };
            this.addButtons(buttonOption1);
            positionY = positionY + 40;
        }
    }
    initializeNavmesh(graph, walls) {
        let dim = walls.getDimensions();
        for (let i = 0; i < dim.y; i++) {
            for (let j = 0; j < dim.x; j++) {
                let tile = walls.getTileCollider(j, i);
                graph.addPositionedNode(tile.center);
            }
        }
        let rc;
        for (let i = 0; i < graph.numVertices; i++) {
            rc = walls.getTileColRow(i);
            if (!walls.isTileCollidable(rc.x, rc.y) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), rc.y) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), rc.y) &&
                !walls.isTileCollidable(rc.x, MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(rc.x, MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y + 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x + 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1)) &&
                !walls.isTileCollidable(MathUtils_1.default.clamp(rc.x - 1, 0, dim.x - 1), MathUtils_1.default.clamp(rc.y - 1, 0, dim.y - 1))) {
                // Create edge to the left
                rc = walls.getTileColRow(i + 1);
                if ((i + 1) % dim.x !== 0 && !walls.isTileCollidable(rc.x, rc.y)) {
                    graph.addEdge(i, i + 1);
                    // this.add.graphic(GraphicType.LINE, "graph", {start: this.graph.getNodePosition(i), end: this.graph.getNodePosition(i + 1)})
                }
                // Create edge below
                rc = walls.getTileColRow(i + dim.x);
                if (i + dim.x < graph.numVertices && !walls.isTileCollidable(rc.x, rc.y)) {
                    graph.addEdge(i, i + dim.x);
                    // this.add.graphic(GraphicType.LINE, "graph", {start: this.graph.getNodePosition(i), end: this.graph.getNodePosition(i + dim.x)})
                }
            }
        }
        // Set this graph as a navigable entity
        return new Navmesh_1.default(graph);
    }
    initFogOfWar() {
        const len = this.wallSize / this.labelSize;
        for (let i = 0; i <= 2 * len; i++) {
            for (let j = 6; j <= 2 * len; j++) {
                let x = 0.5 * i * this.labelSize;
                let y = 0.5 * j * this.labelSize;
                let options = {
                    position: new Vec2_1.default(x, y),
                    text: "",
                };
                this.addBlackLabel(options);
            }
        }
    }
    addBlackLabel(options) {
        const label = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, GameLayers_1.GameLayers.FOG_OF_WAR, options);
        label.size.set(this.labelSize * 2, this.labelSize * 2);
        label.borderWidth = 0;
        label.borderRadius = 0;
        label.borderColor = Color_1.default.TRANSPARENT;
        label.backgroundColor = Color_1.default.FOG_OF_WAR_BLACK;
    }
}
exports.default = ProjectScene;

},{"../../Wolfie2D/DataTypes/Graphs/PositionGraph":14,"../../Wolfie2D/DataTypes/Shapes/AABB":20,"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Events/GameEventType":32,"../../Wolfie2D/Input/Input":34,"../../Wolfie2D/Nodes/GameNode":42,"../../Wolfie2D/Nodes/Graphics/GraphicTypes":45,"../../Wolfie2D/Nodes/UIElements/Label":58,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":61,"../../Wolfie2D/Pathfinding/Navmesh":64,"../../Wolfie2D/Scene/Scene":96,"../../Wolfie2D/Timing/Timer":103,"../../Wolfie2D/Utils/Color":105,"../../Wolfie2D/Utils/EaseFunctions":106,"../../Wolfie2D/Utils/MathUtils":108,"../AI/NPC/NPCBehavior/SlimeBehavior":115,"../AI/Player/PlayerAI":118,"../AI/Player/PlayerController":119,"../ActionType":126,"../Actors/NPCActor":127,"../Actors/PlayerActor":128,"../Controls":129,"../CustomizedButton":130,"../GameItemsArray":131,"../GameLayers":132,"../GameSystems/ItemSystem/Items/LaserGuns":136,"../GameSystems/Targeting/BasicTargetable":140,"../GameSystems/Targeting/Position":142,"../MenuState":143,"../Pathfinding/AstarStrategy":144,"../PlayerStatsArray":145,"../ProjectEvents":146,"../Text":155,"./SelectLevelMenuScene":153}],148:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* #################### IMPORTS #################### */
// Import from Wolfie2D or your own files here
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const Color_1 = __importDefault(require("../../Wolfie2D/Utils/Color"));
const CustomizedButton_1 = require("../CustomizedButton");
const SelectLevelMenuScene_1 = __importDefault(require("./SelectLevelMenuScene"));
const AbstractScene_1 = __importDefault(require("./AbstractScene"));
/* #################### CLASS DEFINITION #################### */
// Welcome to Wolfie2D!
// This is a simple sample scene so something displays when you run the game.
class CheatCodeMenuScene extends AbstractScene_1.default {
    constructor() {
        super(...arguments);
        /* ########## MEMBER DEFINITIONS ##########*/
        this.Astar = "Auto-Pilot";
        this.FogOfWar = "Remove Fog of War";
    }
    loadScene() {
        // this.load.tilemap("map", "../dist/shadowMaze_assets/tilemaps/test2.json");
        this.load.image(this.backgroundImageKey, "shadowMaze_assets/images/mazeBackground.jpg");
        // console.log(this.load.getImage("image"));
    }
    // startScene() is where you should build any game objects you wish to have in your scene,
    // or where you should initialize any other things you will need in your scene
    // Once again, this occurs strictly after loadScene(), so anything you loaded there will be available
    startScene() {
        this.addUILayer(this.GameLayers.BASE);
        this.isAstarChecked = false;
        this.isfogOfWarChecked = false;
        this.backgroundImage = this.add.sprite(this.backgroundImageKey, this.GameLayers.BASE);
        let center = this.viewport.getCenter();
        this.addBackButon(this.backButtonPosition);
        this.backgroundImage.position.set(center.x, center.y);
        let textOption = {
            position: new Vec2_1.default(center.x, center.y - 450),
            text: "Cheat Mode",
            backgroundColor: Color_1.default.TRANSPARENT,
            fontSize: 50,
        };
        this.addLabel(textOption);
        this.astarCheckLabel = this.addModeButton(center, this.Astar);
        center = new Vec2_1.default(center.x, center.y + 200);
        this.fogOfWarCheckLabel = this.addModeButton(center, this.FogOfWar);
    }
    addModeButton(position, buttonName) {
        let aStarTextOption = {
            position: new Vec2_1.default(position.x, position.y - 250),
            text: buttonName,
            size: new Vec2_1.default(300, 50),
            // buttonName:"Astar",
            fontSize: 50,
            textColor: Color_1.default.PURPLE,
            backgroundColor: Color_1.default.TRANSPARENT,
        };
        this.addLabel(aStarTextOption);
        let aStarChoiceOption = {
            position: new Vec2_1.default(position.x, position.y - 150),
            text: "",
            size: new Vec2_1.default(50, 50),
            buttonName: buttonName,
            backgroundColor: Color_1.default.WHITE,
            borderWidth: 10,
            fontSize: 30,
        };
        this.addButtons(aStarChoiceOption);
        let aStarCheckOption = {
            position: new Vec2_1.default(position.x, position.y - 150),
            text: "\u2713",
            size: new Vec2_1.default(50, 50),
            backgroundColor: Color_1.default.WHITE,
            borderWidth: 10,
            fontSize: 50,
            textColor: Color_1.default.TRANSPARENT,
        };
        return this.addLabel(aStarCheckOption);
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
    }
    showCheckLabel(label, flag) {
        if (!flag) {
            label.setTextColor(Color_1.default.BLACK);
        }
        else {
            label.setTextColor(Color_1.default.TRANSPARENT);
        }
        return !flag;
    }
    handleEvent(event) {
        // console.log(event.type === this.Astar)
        console.log(event.type);
        // console.log(event.type === this.FogOfWar)
        switch (event.type) {
            case CustomizedButton_1.BackButtonEvent.BACK: {
                const option = {
                    isAstarChecked: this.isAstarChecked,
                    isfogOfWarChecked: this.isfogOfWarChecked,
                };
                this.sceneManager.changeToScene(SelectLevelMenuScene_1.default, option);
                break;
            }
            case this.Astar: {
                // this.isAstarChecked= !this.isAstarChecked
                // this.showCheckLabel(this.astarCheckLabel, this.isAstarChecked);
                this.isAstarChecked = this.showCheckLabel(this.astarCheckLabel, this.isAstarChecked);
                break;
            }
            case this.FogOfWar: {
                this.isfogOfWarChecked = this.showCheckLabel(this.fogOfWarCheckLabel, this.isfogOfWarChecked);
                break;
            }
        }
    }
    getBattlers() { return this.battlers; }
}
exports.default = CheatCodeMenuScene;

},{"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Utils/Color":105,"../CustomizedButton":130,"./AbstractScene":147,"./SelectLevelMenuScene":153}],149:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* #################### IMPORTS #################### */
// Import from Wolfie2D or your own files here
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const Color_1 = __importDefault(require("../../Wolfie2D/Utils/Color"));
const CustomizedButton_1 = require("../CustomizedButton");
const MainMenuScene_1 = __importDefault(require("./MainMenuScene"));
const Text_1 = require("../Text");
const AbstractScene_1 = __importDefault(require("./AbstractScene"));
/* #################### CLASS DEFINITION #################### */
// Welcome to Wolfie2D!
// This is a simple sample scene so something displays when you run the game.
class ControlScene extends AbstractScene_1.default {
    /* ########## MEMBER DEFINITIONS ##########*/
    loadScene() {
        // this.load.tilemap("map", "../dist/shadowMaze_assets/tilemaps/test2.json");
        this.load.image(this.backgroundImageKey, "shadowMaze_assets/images/mazeBackground.jpg");
        // console.log(this.load.getImage("image"));
    }
    // startScene() is where you should build any game objects you wish to have in your scene,
    // or where you should initialize any other things you will need in your scene
    // Once again, this occurs strictly after loadScene(), so anything you loaded there will be available
    startScene() {
        this.addUILayer(this.GameLayers.BASE);
        this.backgroundImage = this.add.sprite(this.backgroundImageKey, this.GameLayers.BASE);
        let center = this.viewport.getCenter();
        this.backgroundImage.position.set(center.x, center.y);
        let textOption = {
            position: new Vec2_1.default(center.x, center.y - 450),
            text: "Controls",
            backgroundColor: Color_1.default.TRANSPARENT,
            fontSize: 50,
        };
        this.addLabel(textOption);
        let controlTextOption = {
            position: center,
            text: Text_1.controlTextArray,
            margin: 70,
            backgroundColor: Color_1.default.TRANSPARENT,
        };
        this.addControlTextLayer(controlTextOption);
        this.addBackButon(this.backButtonPosition);
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
    }
    handleEvent(event) {
        super.handleEvent(event);
        console.log(event.type);
        switch (event.type) {
            case CustomizedButton_1.BackButtonEvent.BACK: {
                this.sceneManager.changeToScene(MainMenuScene_1.default);
                break;
            }
        }
    }
    getBattlers() { return this.battlers; }
}
exports.default = ControlScene;

},{"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Utils/Color":105,"../CustomizedButton":130,"../Text":155,"./AbstractScene":147,"./MainMenuScene":152}],150:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* #################### IMPORTS #################### */
// Import from Wolfie2D or your own files here
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const Color_1 = __importDefault(require("../../Wolfie2D/Utils/Color"));
const CustomizedButton_1 = require("../CustomizedButton");
const MainMenuScene_1 = __importDefault(require("./MainMenuScene"));
const AbstractScene_1 = __importDefault(require("./AbstractScene"));
/* #################### CLASS DEFINITION #################### */
// Welcome to Wolfie2D!
// This is a simple sample scene so something displays when you run the game.
class HelpScene extends AbstractScene_1.default {
    /* ########## MEMBER DEFINITIONS ##########*/
    // private mainMenuLayerName: string = "startScene";
    loadScene() {
        // this.load.tilemap("map", "../dist/shadowMaze_assets/tilemaps/test2.json");
        this.load.image(this.backgroundImageKey, "shadowMaze_assets/images/mazeBackground.jpg");
        // console.log(this.load.getImage("image"));
    }
    // startScene() is where you should build any game objects you wish to have in your scene,
    // or where you should initialize any other things you will need in your scene
    // Once again, this occurs strictly after loadScene(), so anything you loaded there will be available
    startScene() {
        this.addUILayer(this.GameLayers.BASE);
        this.backgroundImage = this.add.sprite(this.backgroundImageKey, this.GameLayers.BASE);
        let center = this.viewport.getCenter();
        this.backgroundImage.position.set(center.x, center.y);
        let textOption = {
            position: new Vec2_1.default(center.x, center.y - 450),
            text: "Help",
            backgroundColor: Color_1.default.TRANSPARENT,
            fontSize: 50,
        };
        let helpTextOption = {
            position: center,
            margin: 50,
            backgroundColor: Color_1.default.TRANSPARENT,
            fontSize: 31,
        };
        this.addLabel(textOption);
        this.addHelpTextLayer(helpTextOption);
        this.addBackButon(this.backButtonPosition);
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            const gameEvent = this.receiver.getNextEvent();
            this.handleEvent(gameEvent);
        }
    }
    handleEvent(event) {
        super.handleEvent(event);
        console.log(event.type);
        switch (event.type) {
            case CustomizedButton_1.BackButtonEvent.BACK: {
                this.sceneManager.changeToScene(MainMenuScene_1.default);
                break;
            }
        }
    }
    getBattlers() { return this.battlers; }
}
exports.default = HelpScene;

},{"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Utils/Color":105,"../CustomizedButton":130,"./AbstractScene":147,"./MainMenuScene":152}],151:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const SelectLevelMenuScene_1 = __importDefault(require("./SelectLevelMenuScene"));
const StartScene_1 = __importDefault(require("./StartScene"));
const AbstractScene_1 = __importDefault(require("./AbstractScene"));
const CustomizedButton_1 = require("../CustomizedButton");
const ProjectEvents_1 = require("../ProjectEvents");
const CheatCodeMenuScene_1 = __importDefault(require("./CheatCodeMenuScene"));
const MenuState_1 = require("../MenuState");
const ACTIONTYPE = {
    PICK: "PICK",
    USE: "USE",
};
class IntroLevelScene extends AbstractScene_1.default {
    /**
     * @see Scene.update()
     */
    loadScene() {
        this.levelMusicKey = IntroLevelScene.LEVEL_MUSIC_KEY;
        // this.load.audio(this.levelMusicKey, IntroLevelScene.LEVEL_MUSIC_PATH);
        this.loadAllGameItems();
        this.loadUltimateWave();
        this.load.spritesheet("prince", "shadowMaze_assets/spritesheets/prince.json");
        this.load.spritesheet("black_pudding", "shadowMaze_assets/spritesheets/black_pudding.json");
        this.load.spritesheet("troll", "shadowMaze_assets/spritesheets/troll.json");
        this.load.object("monster", "shadowMaze_assets/data/enemies/monster.json");
        this.load.image(this.inGameControlTextBackground, "shadowMaze_assets/images/inGameControlTextBackground.png");
        this.load.image(this.inGameHelpTextBackground, "shadowMaze_assets/images/inGameHelpTextBackground.png");
        // Load the tilemap
        // this.load.tilemap("level", "shadowMaze_assets/tilemaps/futureLevel.json");
        this.load.tilemap("level", "shadowMaze_assets/tilemaps/LI_TEST_MAP.json");
    }
    /**
     * @see Scene.startScene
     */
    handleEvent(event) {
        super.handleEvent(event);
        this.handleInGameButtonEvent(event);
        // action type:  
    }
    handleInGameButtonEvent(event) {
        let nextScene;
        // console.log(event)
        switch (event.type) {
            case CustomizedButton_1.MainMenuButtonEvent.Restart: {
                nextScene = IntroLevelScene;
                break;
            }
            case CustomizedButton_1.PauseButtonEvent.PAUSE: {
                this.handleMenuStateChange();
                this.handleMenuShown();
                break;
            }
            case CustomizedButton_1.MainMenuButtonEvent.Select_levels: {
                nextScene = SelectLevelMenuScene_1.default;
                break;
            }
            case CustomizedButton_1.MainMenuButtonEvent.Controls: {
                this.MenuCurentState = MenuState_1.MenuState.CONTROL_TEXT_MENU_SHOWN;
                this.handleMenuShown();
                return;
            }
            case CustomizedButton_1.MainMenuButtonEvent.Help: {
                this.MenuCurentState = MenuState_1.MenuState.HELP_TEXT_MENU_SHOWN;
                this.handleMenuShown();
                break;
            }
            case CustomizedButton_1.MainMenuButtonEvent.CHEAT: {
                nextScene = CheatCodeMenuScene_1.default;
                break;
            }
            case CustomizedButton_1.MainMenuButtonEvent.Exit: {
                nextScene = StartScene_1.default;
                break;
            }
            case ProjectEvents_1.PlayerEvents.PLAYER_ENTERED_LEVEL_END: {
                this.handleEnteredLevelEnd();
                break;
            }
            case ProjectEvents_1.PlayerEvents.LEVEL_END: {
                setTimeout(() => {
                    nextScene = SelectLevelMenuScene_1.default;
                    this.sceneChange(nextScene);
                }, 2000);
                return;
            }
        }
        if (nextScene) {
            this.sceneChange(nextScene);
        }
    }
    getBattlers() { return this.battlers; }
}
exports.default = IntroLevelScene;
IntroLevelScene.LEVEL_MUSIC_KEY = "LEVEL_MUSIC";
IntroLevelScene.LEVEL_MUSIC_PATH = "shadowMaze_assets/music/level_bgm.mp3";

},{"../CustomizedButton":130,"../MenuState":143,"../ProjectEvents":146,"./AbstractScene":147,"./CheatCodeMenuScene":148,"./SelectLevelMenuScene":153,"./StartScene":154}],152:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = __importDefault(require("../../Wolfie2D/Scene/Scene"));
const Color_1 = __importDefault(require("../../Wolfie2D/Utils/Color"));
// import GuardDemoScene from "./GuardDemoScene";
const CustomizedButton_1 = require("../CustomizedButton");
const SelectLevelMenuScene_1 = __importDefault(require("./SelectLevelMenuScene"));
const HelpScene_1 = __importDefault(require("./HelpScene"));
const StartScene_1 = __importDefault(require("./StartScene"));
const ControlScene_1 = __importDefault(require("./ControlScene"));
const CheatCodeMenuScene_1 = __importDefault(require("./CheatCodeMenuScene"));
const GameLayers_1 = require("../GameLayers");
class MainMenu extends Scene_1.default {
    initScene(option) {
        this.option = option;
        console.log(this.option);
    }
    loadScene() {
        this.load.image(this.backgroundImageKey, "shadowMaze_assets/images/fullBackground.jpg");
    }
    startScene() {
        const center = this.viewport.getCenter();
        this.mainMenu = this.addUILayer(GameLayers_1.GameLayers.BASE);
        this.backgroundImage = this.add.sprite(this.backgroundImageKey, GameLayers_1.GameLayers.BASE);
        this.backgroundImage.position.set(center.x, center.y);
        // The main menu
        let positionY = center.y - 400;
        for (let buttonName in CustomizedButton_1.MainMenuButtonEvent) {
            if (buttonName == "Restart")
                continue;
            positionY = positionY + 100;
            if (buttonName == "Select_levels")
                buttonName = "Select levels";
            const options = {
                position: new Vec2_1.default(center.x, positionY),
                text: buttonName,
            };
            this.addButtons(options);
        }
    }
    addButtons(options) {
        const newButton = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, GameLayers_1.GameLayers.BASE, options);
        newButton.size.set(300, 50);
        newButton.borderWidth = 2;
        newButton.borderColor = Color_1.default.TRANSPARENT;
        newButton.backgroundColor = Color_1.default.BLACK;
        newButton.setTextColor(Color_1.default.PURPLE);
        newButton.onClickEventId = options.text;
        this.receiver.subscribe(options.text);
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
    }
    handleEvent(event) {
        console.log(event.type);
        switch (event.type) {
            case CustomizedButton_1.MainMenuButtonEvent.Select_levels: {
                this.sceneManager.changeToScene(SelectLevelMenuScene_1.default, this.option);
                break;
            }
            case CustomizedButton_1.MainMenuButtonEvent.Controls: {
                this.sceneManager.changeToScene(ControlScene_1.default);
                break;
            }
            case CustomizedButton_1.MainMenuButtonEvent.Help: {
                this.sceneManager.changeToScene(HelpScene_1.default);
                break;
            }
            case CustomizedButton_1.MainMenuButtonEvent.Exit: {
                this.sceneManager.changeToScene(StartScene_1.default);
                break;
            }
            case CustomizedButton_1.MainMenuButtonEvent.CHEAT: {
                this.sceneManager.changeToScene(CheatCodeMenuScene_1.default);
                break;
            }
        }
    }
}
exports.default = MainMenu;

},{"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":61,"../../Wolfie2D/Scene/Scene":96,"../../Wolfie2D/Utils/Color":105,"../CustomizedButton":130,"../GameLayers":132,"./CheatCodeMenuScene":148,"./ControlScene":149,"./HelpScene":150,"./SelectLevelMenuScene":153,"./StartScene":154}],153:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const CustomizedButton_1 = require("../CustomizedButton");
const IntroLevelScene_1 = __importDefault(require("./IntroLevelScene"));
const AbstractScene_1 = __importDefault(require("./AbstractScene"));
const MainMenuScene_1 = __importDefault(require("./MainMenuScene"));
class MainMenu extends AbstractScene_1.default {
    constructor() {
        super(...arguments);
        this.mainMenuLayerName = "mainMenu";
    }
    // private backgroundImage: Sprite;
    // private GameLayers = GameLayers;
    initScene(option) {
        this.option = option;
    }
    loadScene() {
        this.load.image(this.backgroundImageKey, "shadowMaze_assets/images/mazeBackground.jpg");
    }
    startScene() {
        this.addUILayer(this.GameLayers.BASE);
        const center = this.viewport.getCenter();
        this.backgroundImage = this.add.sprite(this.backgroundImageKey, this.GameLayers.BASE);
        this.backgroundImage.position.set(center.x, center.y);
        // The main menu
        let positionY = center.y - 100;
        let i = 0;
        for (let buttonName in CustomizedButton_1.SelectMenuButtonEvent) {
            buttonName = CustomizedButton_1.SelectMenuButtonEvent[buttonName];
            if (i === 0) {
                let buttonOption = {
                    buttonName: buttonName,
                    position: new Vec2_1.default(center.x, positionY),
                    size: new Vec2_1.default(300, 50),
                    text: buttonName,
                };
                this.addButtons(buttonOption);
                break;
            }
            i++;
        }
        this.addBackButon(this.backButtonPosition);
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            this.handleEvent(this.receiver.getNextEvent());
        }
    }
    handleEvent(event) {
        console.log(event.type);
        switch (event.type) {
            case CustomizedButton_1.BackButtonEvent.BACK: {
                this.sceneManager.changeToScene(MainMenuScene_1.default, this.option);
                break;
            }
            case CustomizedButton_1.SelectMenuButtonEvent.LEVEL_1: {
                this.sceneManager.changeToScene(IntroLevelScene_1.default, this.option);
                break;
            }
            case CustomizedButton_1.SelectMenuButtonEvent.LEVEL_2: {
                // this.sceneManager.changeToScene(AstarDemoScene);
                break;
            }
            case CustomizedButton_1.SelectMenuButtonEvent.LEVEL_6: {
            }
            // case SelectMenuButtonEvent.CHEAT:{
            //     this.sceneManager.changeToScene( CheatCodeMenuScene);
            // }
        }
    }
    getBattlers() { return this.battlers; }
}
exports.default = MainMenu;

},{"../../Wolfie2D/DataTypes/Vec2":26,"../CustomizedButton":130,"./AbstractScene":147,"./IntroLevelScene":151,"./MainMenuScene":152}],154:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* #################### IMPORTS #################### */
// Import from Wolfie2D or your own files here
const Vec2_1 = __importDefault(require("../../Wolfie2D/DataTypes/Vec2"));
const Color_1 = __importDefault(require("../../Wolfie2D/Utils/Color"));
const CustomizedButton_1 = require("../CustomizedButton");
const MainMenuScene_1 = __importDefault(require("./MainMenuScene"));
const AbstractScene_1 = __importDefault(require("./AbstractScene"));
/* #################### CLASS DEFINITION #################### */
// Welcome to Wolfie2D!
// This is a simple sample scene so something displays when you run the game.
class StartScene extends AbstractScene_1.default {
    /* ########## MEMBER DEFINITIONS ##########*/
    loadScene() {
        // this.load.tilemap("map", "../dist/shadowMaze_assets/tilemaps/test2.json");
        this.load.image(this.backgroundImageKey, "shadowMaze_assets/images/splash.jpg");
        // console.log(this.load.getImage("image"));
    }
    // startScene() is where you should build any game objects you wish to have in your scene,
    // or where you should initialize any other things you will need in your scene
    // Once again, this occurs strictly after loadScene(), so anything you loaded there will be available
    startScene() {
        this.addUILayer(this.GameLayers.BASE);
        this.backgroundImage = this.add.sprite(this.backgroundImageKey, this.GameLayers.BASE);
        let center = this.viewport.getCenter();
        this.backgroundImage.position.set(center.x, center.y);
        let textOption = {
            position: new Vec2_1.default(center.x, center.y - 300),
            text: "Shadow Maze",
            size: new Vec2_1.default(400, 100),
            fontSize: 60,
            backgroundColor: Color_1.default.TRANSPARENT,
            font: "Apple Chancery",
        };
        this.addLabel(textOption);
        let buttonOption = {
            position: new Vec2_1.default(center.x, center.y + 100),
            text: CustomizedButton_1.StartMenuButtonEvent.START_GAME,
            size: new Vec2_1.default(300, 50),
            textColor: Color_1.default.PURPLE,
            buttonName: "Start Game",
        };
        this.addButtons(buttonOption);
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            const gameEvent = this.receiver.getNextEvent();
            this.handleEvent(gameEvent);
        }
    }
    handleEvent(event) {
        switch (event.type) {
            case CustomizedButton_1.StartMenuButtonEvent.START_GAME: {
                this.sceneManager.changeToScene(MainMenuScene_1.default);
                break;
            }
        }
    }
    getBattlers() { return this.battlers; }
}
exports.default = StartScene;

},{"../../Wolfie2D/DataTypes/Vec2":26,"../../Wolfie2D/Utils/Color":105,"../CustomizedButton":130,"./AbstractScene":147,"./MainMenuScene":152}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.helpTextArray = exports.controlTextArray = void 0;
const helpText = "The prince’s goal is to make it out of the maze alive! He has a sword and shield to help him do so, as well as an ultimate ability in the form of a flying sword slash. Using the attack button will swing his sword at the prince’s enemies in front of him, dealing damage. To use his shield, hold down the shield button to absorb incoming damage. Be careful though, the shield will go on cool-down if it takes too much damage. You can also parry attacks by pressing the shield button right when an attack will hit you. This will rebound ranged attacks, and stun melee enemies.";
const controlText = "W - Move Up\nA - Move Left\nS - Move Down\nD - Move Right\nJ - Attack\nK - Shield\nU - Sword Slash\nEsc - Pause and Menu\nNumber - Use Items";
function buildControlText() {
    const lines = controlText.split('\n');
    // const keyValuesArray = lines.map(line => line.split(' - ')[0]);
    return lines;
}
function buildHelpText() {
    const paragraph = helpText;
    const MAX_LINE_LENGTH = 70;
    const lines = paragraph.split(" ");
    let currentLine = "";
    const result = lines.reduce((acc, word) => {
        if (currentLine.length + word.length + 1 > MAX_LINE_LENGTH) {
            acc.push(currentLine.trim());
            currentLine = "";
        }
        currentLine += `${word} `;
        return acc;
    }, []);
    result.push(currentLine.trim());
    return result;
}
exports.controlTextArray = buildControlText();
exports.helpTextArray = buildHelpText();

},{}],156:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Game_1 = __importDefault(require("./Wolfie2D/Loop/Game"));
const PlayerController_1 = require("./demoGame/AI/Player/PlayerController");
// import MainHW4Scene from "./demoGame/Scenes/MainHW4Scene";
const IntroLevelScene_1 = __importDefault(require("./demoGame/Scenes/IntroLevelScene"));
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    let options = {
        canvasSize: { x: 1024, y: 1024 },
        clearColor: { r: 0.1, g: 0.1, b: 0.1 },
        inputs: [
            { name: PlayerController_1.PlayerInput.MOVE_UP, keys: ["w"] },
            { name: PlayerController_1.PlayerInput.MOVE_DOWN, keys: ["s"] },
            { name: PlayerController_1.PlayerInput.MOVE_LEFT, keys: ["a"] },
            { name: PlayerController_1.PlayerInput.MOVE_RIGHT, keys: ["d"] },
            { name: PlayerController_1.PlayerInput.PICKUP_ITEM, keys: ["e"] },
            { name: PlayerController_1.PlayerInput.DROP_ITEM, keys: ["q"] },
            { name: PlayerController_1.PlayerInput.ATTACKING, keys: ["j"] },
            { name: PlayerController_1.PlayerInput.SHIELDING, keys: ["k"] },
            { name: PlayerController_1.PlayerInput.ULTIMATE, keys: ["u"] },
            { name: "slot2", keys: ["2"] },
        ],
        // useWebGL: true,   
        useWebGL: false,
        showDebug: false, // Whether to show debug messages. You can change this to true if you want
    };
    // Set up custom registries
    // RegistryManager.shaders.registerAndPreloadItem(
    //     BubbleShaderType.KEY,   // The key of the shader program
    //     BubbleShaderType,           // The constructor of the shader program
    //     BubbleShaderType.VSHADER,   // The path to the vertex shader
    //     BubbleShaderType.FSHADER);  // the path to the fragment shader*/
    // RegistryManager.shaders.registerAndPreloadItem(
    //     LaserShaderType.KEY,
    //     LaserShaderType,
    //     LaserShaderType.VSHADER,
    //     LaserShaderType.FSHADER
    // );
    // Create a game with the options specified
    const game = new Game_1.default(options);
    // Start our game
    game.start(IntroLevelScene_1.default, {});
    // game.start(HelpScene, {});
    // game.start(ControlScene,{});
    // game.start(StartScene, {});
    // game.start(CheatCodeMenuScene,{});
    // game.start(SelectLevelMenuScene,{});
    // game.start(MainMenu, {});
})();
function runTests() { }
;

},{"./Wolfie2D/Loop/Game":38,"./demoGame/AI/Player/PlayerController":119,"./demoGame/Scenes/IntroLevelScene":151}]},{},[156])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvV29sZmllMkQvQUkvQUlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL0FJL0dvYXAvR29hcEFjdGlvbi50cyIsInNyYy9Xb2xmaWUyRC9BSS9Hb2FwL0dvYXBBY3Rpb25QbGFubmVyLnRzIiwic3JjL1dvbGZpZTJEL0FJL0dvYXAvR29hcFN0YXRlLnRzIiwic3JjL1dvbGZpZTJEL0FJL0dvYXAvU3RhdGVNYWNoaW5lR29hcEFJLnRzIiwic3JjL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9CaW5hcnlIZWFwU2V0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXAudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0NvbGxlY3Rpb25zL1F1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9TdGFjay50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvRnVuY3Rpb25zL051bGxGdW5jLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvRWRnZU5vZGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGgudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9NYXQ0eDQudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1BoeXNpY3MvQXJlYUNvbGxpc2lvbi50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUGh5c2ljcy9IaXQudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1JlbmRlcmluZy9XZWJHTFByb2dyYW1UeXBlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQi50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0NpcmNsZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL0RlYnVnLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL1N0YXRzLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FdmVudFF1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnQudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFR5cGUudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL1JlY2VpdmVyLnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0LnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0SGFuZGxlci50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0Vudmlyb25tZW50SW5pdGlhbGl6ZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9GaXhlZFVwZGF0ZUdhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZS50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvQ2FudmFzTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0NpcmNsZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvTGluZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9QYXJ0aWNsZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9Qb2ludC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9SZWN0LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9TcHJpdGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVGlsZW1hcC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9Jc29tZXRyaWNUaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL1N0YWdnZXJlZElzb21ldHJpY1RpbGVtYXAudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvTGFiZWwudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9TbGlkZXIudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXQudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aC50cyIsInNyYy9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZtZXNoLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL1N0cmF0ZWdpZXMvTmF2aWdhdGlvblN0cmF0ZWd5LnRzIiwic3JjL1dvbGZpZTJEL1BoeXNpY3MvQmFzaWNQaHlzaWNzTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QaHlzaWNzL1BoeXNpY3NNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1BsYXliYWNrL1BsYXliYWNrTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1JlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnkudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvQW5pbWF0aW9uVHlwZXMudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvUGFydGljbGVTeXN0ZW1NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuQ29udHJvbGxlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2Vlbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvR3JhcGhpY1JlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvVGlsZW1hcFJlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvVUlFbGVtZW50UmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL0xhYmVsU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUG9pbnRTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9RdWFkU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUmVjdFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1Nwcml0ZVNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvQ2FudmFzTm9kZUZhY3RvcnkudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL0ZhY3RvcnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9UaWxlbWFwRmFjdG9yeS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllcnMvVUlMYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvU2NlbmVPcHRpb25zLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1ZpZXdwb3J0LnRzIiwic3JjL1dvbGZpZTJEL1NvdW5kL0F1ZGlvTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9UaW1pbmcvVGltZXIudHMiLCJzcmMvV29sZmllMkQvVGltaW5nL1RpbWVyTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9Db2xvci50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9FYXNlRnVuY3Rpb25zLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0dyYXBoVXRpbHMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvTWF0aFV0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL1JlbmRlcmluZ1V0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL1N0cmluZ1V0aWxzLnRzIiwic3JjL2RlbW9HYW1lL0FJL05QQy9OUENBY3Rpb25zL0F0dGFja0VuZW15LnRzIiwic3JjL2RlbW9HYW1lL0FJL05QQy9OUENBY3Rpb25zL0dvdG9BY3Rpb24udHMiLCJzcmMvZGVtb0dhbWUvQUkvTlBDL05QQ0FjdGlvbnMvTlBDQWN0aW9uLnRzIiwic3JjL2RlbW9HYW1lL0FJL05QQy9OUENCZWhhdmlvci50cyIsInNyYy9kZW1vR2FtZS9BSS9OUEMvTlBDQmVoYXZpb3IvU2xpbWVCZWhhdmlvci50cyIsInNyYy9kZW1vR2FtZS9BSS9OUEMvTlBDU3RhdHVzZXMvRmFsc2VTdGF0dXMudHMiLCJzcmMvZGVtb0dhbWUvQUkvTlBDL05QQ1N0YXR1c2VzL1RhcmdldEV4aXN0cy50cyIsInNyYy9kZW1vR2FtZS9BSS9QbGF5ZXIvUGxheWVyQUkudHMiLCJzcmMvZGVtb0dhbWUvQUkvUGxheWVyL1BsYXllckNvbnRyb2xsZXIudHMiLCJzcmMvZGVtb0dhbWUvQUkvUGxheWVyL1BsYXllclN0YXRlcy9BdHRhY2tpbmcudHMiLCJzcmMvZGVtb0dhbWUvQUkvUGxheWVyL1BsYXllclN0YXRlcy9EZWFkLnRzIiwic3JjL2RlbW9HYW1lL0FJL1BsYXllci9QbGF5ZXJTdGF0ZXMvSWRsZS50cyIsInNyYy9kZW1vR2FtZS9BSS9QbGF5ZXIvUGxheWVyU3RhdGVzL01vdmluZy50cyIsInNyYy9kZW1vR2FtZS9BSS9QbGF5ZXIvUGxheWVyU3RhdGVzL1BsYXllclN0YXRlLnRzIiwic3JjL2RlbW9HYW1lL0FJL1BsYXllci9QbGF5ZXJTdGF0ZXMvU2hpZWxkaW5nLnRzIiwic3JjL2RlbW9HYW1lL0FjdGlvblR5cGUudHMiLCJzcmMvZGVtb0dhbWUvQWN0b3JzL05QQ0FjdG9yLnRzIiwic3JjL2RlbW9HYW1lL0FjdG9ycy9QbGF5ZXJBY3Rvci50cyIsInNyYy9kZW1vR2FtZS9Db250cm9scy50cyIsInNyYy9kZW1vR2FtZS9DdXN0b21pemVkQnV0dG9uLnRzIiwic3JjL2RlbW9HYW1lL0dhbWVJdGVtc0FycmF5LnRzIiwic3JjL2RlbW9HYW1lL0dhbWVMYXllcnMudHMiLCJzcmMvZGVtb0dhbWUvR2FtZVN5c3RlbXMvQmF0dGxlU3lzdGVtL0Jhc2ljQmF0dGxlci50cyIsInNyYy9kZW1vR2FtZS9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0ludmVudG9yeS50cyIsInNyYy9kZW1vR2FtZS9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0l0ZW0udHMiLCJzcmMvZGVtb0dhbWUvR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtcy9MYXNlckd1bnMudHMiLCJzcmMvZGVtb0dhbWUvR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0Jhc2ljRmluZGVyLnRzIiwic3JjL2RlbW9HYW1lL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9IVzRGaWx0ZXJzLnRzIiwic3JjL2RlbW9HYW1lL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9IVzRSZWR1Y2Vycy50cyIsInNyYy9kZW1vR2FtZS9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvQmFzaWNUYXJnZXRhYmxlLnRzIiwic3JjL2RlbW9HYW1lL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9CYXNpY1RhcmdldGluZy50cyIsInNyYy9kZW1vR2FtZS9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvUG9zaXRpb24udHMiLCJzcmMvZGVtb0dhbWUvTWVudVN0YXRlLnRzIiwic3JjL2RlbW9HYW1lL1BhdGhmaW5kaW5nL0FzdGFyU3RyYXRlZ3kudHMiLCJzcmMvZGVtb0dhbWUvUGxheWVyU3RhdHNBcnJheS50cyIsInNyYy9kZW1vR2FtZS9Qcm9qZWN0RXZlbnRzLnRzIiwic3JjL2RlbW9HYW1lL1NjZW5lcy9BYnN0cmFjdFNjZW5lLnRzIiwic3JjL2RlbW9HYW1lL1NjZW5lcy9DaGVhdENvZGVNZW51U2NlbmUudHMiLCJzcmMvZGVtb0dhbWUvU2NlbmVzL0NvbnRyb2xTY2VuZS50cyIsInNyYy9kZW1vR2FtZS9TY2VuZXMvSGVscFNjZW5lLnRzIiwic3JjL2RlbW9HYW1lL1NjZW5lcy9JbnRyb0xldmVsU2NlbmUudHMiLCJzcmMvZGVtb0dhbWUvU2NlbmVzL01haW5NZW51U2NlbmUudHMiLCJzcmMvZGVtb0dhbWUvU2NlbmVzL1NlbGVjdExldmVsTWVudVNjZW5lLnRzIiwic3JjL2RlbW9HYW1lL1NjZW5lcy9TdGFydFNjZW5lLnRzIiwic3JjL2RlbW9HYW1lL1RleHQudHMiLCJzcmMvbWFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FDSUEsdUVBQStDO0FBRS9DOzs7R0FHRztBQUNILE1BQXFCLFNBQVM7SUFNN0I7UUFDQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhLENBQUMsS0FBWTtRQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsV0FBVyxDQUFDLEtBQVk7UUFDdkIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdkMsSUFBRyxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDN0I7SUFDRixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxJQUFZLEVBQUUsTUFBMEM7UUFDbEUsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsVUFBVSxDQUFDLElBQVk7UUFDdEIsSUFBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBQztZQUM5QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM7U0FDM0M7YUFBTTtZQUNOLE1BQU0sOEJBQThCLElBQUksc0NBQXNDLENBQUM7U0FDL0U7SUFDRixDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQWM7UUFDcEIsb0NBQW9DO1FBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBRyxLQUFLLENBQUMsUUFBUTtZQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUUsQ0FBQztDQUNEO0FBckRELDRCQXFEQzs7Ozs7Ozs7O0FDOURELHdFQUFnRDtBQUdoRCxNQUE4QixVQUFXLFNBQVEsZUFBSztJQVNsRCxZQUFtQixNQUFzQyxFQUFFLEtBQVk7UUFDbkUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUNsQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQsNENBQTRDO0lBQzVDLElBQUksSUFBSSxLQUFhLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDekMsSUFBSSxJQUFJLENBQUMsSUFBWSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUU3QyxzRUFBc0U7SUFDdEUsSUFBSSxhQUFhLEtBQWUsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRW5GLHFEQUFxRDtJQUNyRCxJQUFJLE9BQU8sS0FBZSxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUvRCxrQkFBa0IsQ0FBQyxNQUFnQjtRQUN0QyxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUN6RyxDQUFDO0lBRU0sZUFBZSxDQUFDLE1BQWM7UUFDakMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUNNLFNBQVMsQ0FBQyxNQUFjO1FBQzNCLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFZSxRQUFRO1FBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDOUIsQ0FBQztDQUVKO0FBMUNELDZCQTBDQztBQUVELElBQVksZ0JBSVg7QUFKRCxXQUFZLGdCQUFnQjtJQUN4Qiw2REFBVyxDQUFBO0lBQ1gsNkRBQVcsQ0FBQTtJQUNYLDZEQUFXLENBQUE7QUFDZixDQUFDLEVBSlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFJM0I7Ozs7Ozs7O0FDcERELHlFQUFpRDtBQUVqRCw4RUFBc0Q7QUFDdEQsd0VBQWdEO0FBR2hELE1BQXFCLGlCQUFpQjtJQUUzQixNQUFNLENBQUMsSUFBSSxDQUF1QixNQUFnQixFQUFFLElBQVksRUFBRSxPQUFpQjtRQUN0RixJQUFJLEtBQUssR0FBVSxJQUFJLGVBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuQyxJQUFJLE9BQU8sR0FBNEIsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUVqRCxlQUFlO1FBQ2YsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZCLGVBQWU7UUFDZixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDaEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRTVDLHdCQUF3QjtRQUN4QixJQUFJLENBQUMsU0FBUyxDQUFJLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFNUQsb0NBQW9DO1FBQ3BDLElBQUksSUFBSSxHQUFrQixvQkFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFeEQsK0JBQStCO1FBQy9CLElBQUksSUFBSSxHQUFHLElBQUksZUFBSyxFQUFLLENBQUM7UUFFaEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsT0FBTSxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDWCxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzdCO1lBQ1YsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNaO1FBRUssT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVPLE1BQU0sQ0FBQyxTQUFTLENBQTBCLE1BQWdCLEVBQUUsT0FBaUIsRUFBRSxJQUFZLEVBQUUsSUFBWSxFQUFFLE9BQWdDLEVBQUUsS0FBWTtRQUM3SiwyQkFBMkI7UUFDM0IsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNyQixzQkFBc0I7WUFDdEIsSUFBSSxNQUFNLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLEVBQUM7Z0JBQ2xDLDhCQUE4QjtnQkFDOUIsOEJBQThCO2dCQUM5QixJQUFJLFNBQVMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUM7Z0JBQzVCLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBRWxDLG1DQUFtQztnQkFDbkMsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFDO29CQUN6QixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQzlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO29CQUM3QixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUMxQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQzdCLE9BQU87aUJBQ1Y7Z0JBRUQsNkJBQTZCO2dCQUM3QixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM3QixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUUxQyxnQkFBZ0I7Z0JBQ2hCLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssTUFBTSxDQUFDLENBQUE7Z0JBQ3RELElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN4RTtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKO0FBaEVELG9DQWdFQzs7Ozs7QUNwRUQ7O0dBRUc7QUFDSCxNQUE4QixTQUFTO0NBSXRDO0FBSkQsNEJBSUM7Ozs7Ozs7O0FDVEQsOEVBQXNEO0FBRXRELDRFQUFtRDtBQUluRCwwRUFBa0Q7QUFHbEQsdUVBQStDO0FBRS9DOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQThCLGtCQUF5QyxTQUFRLHdCQUFjO0lBWXpGO1FBQ0ksS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksYUFBRyxFQUFhLENBQUM7UUFDckMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGFBQUcsRUFBSyxDQUFDO1FBQzdCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxlQUFLLEVBQUssQ0FBQztRQUM1QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNyQixDQUFDO0lBR00sTUFBTSxDQUFDLE1BQWM7UUFDeEIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRWUsVUFBVTtRQUN0QixvRUFBb0U7UUFDcEUsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELHFGQUFxRjtJQUNyRSxXQUFXO1FBQ3ZCLHlCQUF5QjtRQUN6QixJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRXpDLDRCQUE0QjtRQUM1QixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRWpCLHlDQUF5QztRQUN6QyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDdEIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7U0FDakM7UUFFRCx5QkFBeUI7UUFDekIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXRDLDZCQUE2QjtRQUM3QixJQUFHLElBQUksQ0FBQyxzQkFBc0IsRUFBQztZQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBQyxDQUFDLENBQUM7U0FDakY7UUFFRCx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVTLFNBQVM7UUFDZiwrQkFBK0I7UUFDL0IsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3BDLDhCQUE4QjtRQUM5QixJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2xGLGtCQUFrQjtRQUNsQixPQUFPLDJCQUFpQixDQUFDLElBQUksQ0FBSSxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRU0sYUFBYTtRQUNoQixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDbEcsQ0FBQztJQUVNLE9BQU8sQ0FBQyxJQUFZO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUE7U0FDMUY7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNyQixDQUFDO0lBRU0sU0FBUyxDQUFDLFVBQWtCLEVBQUUsTUFBaUI7UUFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFTSxRQUFRLENBQUMsU0FBaUIsRUFBRSxLQUFpQjtRQUNoRCxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBR0o7QUF2RkQscUNBdUZDOzs7Ozs7OztBQ2pIRCxtRkFBMkQ7QUFHM0Q7O0dBRUc7QUFDSCxNQUFxQixjQUFlLFNBQVEsc0JBQVk7SUFJdkQsZUFBZTtJQUNmLFlBQVksQ0FBQyxLQUFlLEVBQUUsTUFBMkIsSUFBVSxDQUFDO0lBRXBFLGVBQWU7SUFDZixPQUFPO1FBQ04sd0NBQXdDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztRQUNsQixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxlQUFlO0lBQ2YsUUFBUSxDQUFDLE9BQTRCLElBQVMsQ0FBQztDQUMvQztBQWhCRCxpQ0FnQkM7Ozs7O0FDckJELE1BQXFCLGFBQWE7SUFlOUIsWUFBWSxTQUFtQyxFQUFFLGNBQXNCLEdBQUc7UUFDdEUsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDZCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUVoQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxFQUFhLENBQUM7UUFDaEMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDZCxJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQztJQUMxQixDQUFDO0lBRUQsSUFBSSxDQUFDLENBQUk7UUFDTCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7U0FDbEI7SUFDTCxDQUFDO0lBRUQsR0FBRztRQUNDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO1FBRWYsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFekIsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBRUQsSUFBSTtRQUNBLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVELE9BQU87UUFDSCxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRCxPQUFPLENBQUMsSUFBYztRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxLQUFLO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELE9BQU8sQ0FBQyxLQUFRO1FBQ1osSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxHQUFHLENBQUMsS0FBUTtRQUNSLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVELFFBQVE7UUFDSixJQUFJLEdBQUcsR0FBRyxpQkFBaUIsQ0FBQztRQUM1QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNoQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7WUFDeEIsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUU7Z0JBQ25CLEdBQUcsSUFBSSxJQUFJLENBQUE7YUFDZDtTQUNKO1FBQ0QsR0FBRyxJQUFJLGFBQWEsQ0FBQztRQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQVcsRUFBRSxHQUFNLEVBQUUsRUFBRTtZQUNyQyxHQUFHLElBQUksS0FBSyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDbEMsQ0FBQyxDQUFDLENBQUM7UUFDSCxHQUFHLElBQUksR0FBRyxDQUFDO1FBQ1gsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBRVMsTUFBTSxDQUFDLElBQVk7UUFDekIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QixPQUFPLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3hFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3RCLElBQUksR0FBRyxJQUFJLENBQUM7WUFDWixJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM1QjtJQUNMLENBQUM7SUFDUyxRQUFRLENBQUMsSUFBWTtRQUMzQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlCLE9BQU8sS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDdEIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNqRixLQUFLLElBQUksQ0FBQyxDQUFDO2FBQ2Q7WUFDRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDdkIsSUFBSSxHQUFHLEtBQUssQ0FBQztnQkFDYixLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM3QjtpQkFBTTtnQkFDSCxNQUFNO2FBQ1Q7U0FDSjtJQUNMLENBQUM7SUFFUyxNQUFNLENBQUMsSUFBWTtRQUN6QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUNTLE1BQU0sQ0FBQyxJQUFZO1FBQ3pCLE9BQU8sSUFBSSxHQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUNTLE1BQU0sQ0FBQyxJQUFZO1FBQ3pCLE9BQU8sSUFBSSxHQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUNTLElBQUksQ0FBQyxLQUFhLEVBQUUsS0FBYTtRQUN2QyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFdEMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDNUIsQ0FBQztDQUVKO0FBaklELGdDQWlJQzs7Ozs7QUNqSUQ7O0dBRUc7QUFDSCxNQUFxQixHQUFHO0lBR3ZCLHdCQUF3QjtJQUN4QjtRQUNDLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQVE7UUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxHQUFHLENBQUMsR0FBVztRQUNkLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEdBQUcsQ0FBQyxHQUFXLEVBQUUsS0FBUTtRQUN4QixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEdBQUcsQ0FBQyxHQUFXO1FBQ2QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFNBQVMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSTtRQUNILE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVELGVBQWU7SUFDZixPQUFPLENBQUMsSUFBMkI7UUFDbEMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxHQUFXO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRUQsZUFBZTtJQUNmLEtBQUs7UUFDSixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVE7UUFDUCxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFFYixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO1FBRTdFLE9BQU8sR0FBRyxDQUFDO0lBQ1osQ0FBQztDQUNEO0FBakZELHNCQWlGQzs7Ozs7QUNwRkQ7O0dBRUc7QUFDSCxNQUFxQixLQUFLO0lBZ0J0Qjs7O09BR0c7SUFDSCxZQUFZLGNBQXNCLEdBQUc7UUFDakMsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7UUFDaEMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDZCxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNkLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPLENBQUMsSUFBTztRQUNYLElBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxDQUFDLElBQUksRUFBQztZQUNqRCxNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7U0FDdEQ7UUFFRCxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQ3BELENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ0gsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUM7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1NBQzFEO1FBR0QsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7UUFDZixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QixzQkFBc0I7UUFDdEIsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBRWhELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ0osSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUM7WUFDdkIsTUFBTSxrQ0FBa0MsQ0FBQTtTQUMzQztRQUVELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTdCLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7T0FHRztJQUNILE9BQU87UUFDSCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDckIsQ0FBQztJQUVELGVBQWU7SUFDZixLQUFLO1FBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQzFCLENBQUM7SUFFRCxlQUFlO0lBQ2YsT0FBTyxDQUFDLElBQXVDO1FBQzNDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDbEIsT0FBTSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksRUFBQztZQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuQixDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztTQUNuQztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ0osSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBRWhCLElBQUksQ0FBQyxPQUFPLENBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDMUIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFBO1lBQ3pCLElBQUcsS0FBSyxLQUFLLENBQUMsRUFBQztnQkFDWCxHQUFHLElBQUksTUFBTSxDQUFBO2FBQ2hCO1lBQ0QsTUFBTSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLFNBQVMsR0FBRyxNQUFNLENBQUM7SUFDOUIsQ0FBQztDQUNKO0FBNUhELHdCQTRIQzs7Ozs7QUMvSEQ7O0dBRUc7QUFDSCxNQUFxQixLQUFLO0lBVXRCOzs7T0FHRztJQUNILFlBQVksY0FBc0IsR0FBRztRQUNqQyxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUNoQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFJLENBQUMsSUFBTztRQUNSLElBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLFlBQVksRUFBQztZQUNuQyxNQUFNLGlDQUFpQyxDQUFDO1NBQzNDO1FBQ0QsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7T0FHRztJQUNILEdBQUc7UUFDQyxJQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDaEIsTUFBTSxxQ0FBcUMsQ0FBQztTQUMvQztRQUNELElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO1FBQ2YsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQUk7UUFDQSxJQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDaEIsTUFBTSxrQ0FBa0MsQ0FBQztTQUM1QztRQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOztNQUVFO0lBQ0YsT0FBTztRQUNILE9BQU8sSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQsZUFBZTtJQUNmLEtBQUs7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDeEQsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSTtRQUNBLE9BQU8sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELGVBQWU7SUFDZixPQUFPLENBQUMsSUFBdUM7UUFDM0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsT0FBTSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksRUFBQztZQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN2QixDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ1Y7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUVoQixJQUFJLENBQUMsT0FBTyxDQUFFLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQzFCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQTtZQUN6QixJQUFHLEtBQUssS0FBSyxDQUFDLEVBQUM7Z0JBQ1gsR0FBRyxJQUFJLE1BQU0sQ0FBQTthQUNoQjtZQUNELE1BQU0sR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDO1FBQzFCLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxTQUFTLEdBQUcsTUFBTSxDQUFDO0lBQzlCLENBQUM7Q0FDSjtBQXRHRCx3QkFzR0M7Ozs7QUMzR0QsY0FBYzs7QUFFZDs7R0FFRztBQUNILE1BQU0sUUFBUSxHQUFHLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQztBQUUxQixrQkFBZSxRQUFRLENBQUM7Ozs7O0FDUHhCOztHQUVHO0FBQ0gsTUFBcUIsUUFBUTtJQVF6Qjs7OztPQUlHO0lBQ04sWUFBWSxLQUFhLEVBQUUsTUFBZTtRQUN6QyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUNmLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuQyxDQUFDO0NBQ0Q7QUFsQkQsMkJBa0JDOzs7Ozs7Ozs7QUNyQkQsMERBQWtDO0FBRXJCLFFBQUEsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUUzQjs7R0FFRztBQUNILE1BQXFCLEtBQUs7SUFjekI7OztPQUdHO0lBQ0gsWUFBWSxXQUFvQixLQUFLO1FBQ3BDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBRXRCLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsYUFBSyxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxhQUFLLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7O01BRUU7SUFDRixPQUFPO1FBQ04sT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7O01BSUU7SUFDRixPQUFPLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxNQUFlO1FBQzVDLElBQUksSUFBSSxHQUFHLElBQUksa0JBQVEsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFJbkMsSUFBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFDO1lBQ2hCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxQjtRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBRXJCLElBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFDO1lBQ2pCLElBQUksR0FBRyxJQUFJLGtCQUFRLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRS9CLElBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBQztnQkFDaEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzFCO1lBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7U0FDckI7UUFFRCxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsVUFBVSxDQUFDLENBQVMsRUFBRSxDQUFTO1FBQzlCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFekIsT0FBTSxJQUFJLEtBQUssSUFBSSxFQUFDO1lBQ25CLElBQUcsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUM7Z0JBQ2YsT0FBTyxJQUFJLENBQUM7YUFDWjtZQUNELElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ2pCO0lBQ0YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxRQUFRLENBQUMsQ0FBUztRQUNqQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVMsQ0FBQyxDQUFTO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLFlBQVksQ0FBQyxLQUFhO1FBQ25DLE9BQU8sT0FBTyxHQUFHLEtBQUssQ0FBQztJQUN4QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNQLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUVoQixLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBQztZQUN4QyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pCLElBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQztZQUNqQixPQUFNLElBQUksS0FBSyxTQUFTLElBQUksSUFBSSxLQUFLLElBQUksRUFBQztnQkFDekMsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQzdCLElBQUcsSUFBSSxDQUFDLFFBQVEsRUFBQztvQkFDaEIsT0FBTyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztpQkFDcEM7Z0JBQ0QsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksRUFBQztvQkFDckIsT0FBTyxJQUFJLElBQUksQ0FBQztpQkFDaEI7Z0JBRUQsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDakI7WUFFRCxNQUFNLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsT0FBTyxHQUFHLElBQUksQ0FBQztTQUN2RDtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2YsQ0FBQztDQUNEO0FBeElELHdCQXdJQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9JRCxpREFBdUM7QUFJdkM7OztFQUdFO0FBQ0YsTUFBcUIsYUFBYyxTQUFRLGVBQUs7SUFJL0M7OztPQUdHO0lBQ0gsWUFBWSxXQUFvQixLQUFLO1FBQ3BDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQTZGakIsZ0JBQVcsR0FBRyxHQUFTLEVBQUU7WUFDeEIsb0NBQW9DO1lBQ3BDLHFGQUFxRjtZQUNyRixJQUFJO1FBQ0wsQ0FBQyxDQUFBO1FBaEdBLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsYUFBSyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxpQkFBaUIsQ0FBQyxRQUFjO1FBQy9CLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLFFBQVEsQ0FBQztRQUM1QyxPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsZUFBZSxDQUFDLEtBQWEsRUFBRSxRQUFjO1FBQzVDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDO1FBRWpDLHFEQUFxRDtRQUNyRCxLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsRUFBQztZQUVyQyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXpCLE9BQU0sSUFBSSxLQUFLLElBQUksRUFBQztnQkFDbkIsaUVBQWlFO2dCQUNqRSxJQUFHLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUM7b0JBQ2xDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbkU7Z0JBRUQsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDakI7U0FDRDtJQUNGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsZUFBZSxDQUFDLEtBQWE7UUFDNUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE9BQU8sQ0FBQyxDQUFTLEVBQUUsQ0FBUztRQUMzQixJQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUM7WUFDM0MsTUFBTSx1Q0FBdUMsQ0FBQztTQUM5QztRQUVELDJDQUEyQztRQUMzQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0QsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxZQUFZO0lBQ0YsWUFBWSxDQUFDLEtBQWE7UUFDbkMsT0FBTyxPQUFPLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25FLENBQUM7SUFFRTs7OztPQUlHO0lBQ0ksSUFBSSxDQUFDLFFBQWM7UUFDdEIsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDZCxJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwRCxPQUFNLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDWCxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqRCxJQUFHLENBQUMsR0FBRyxJQUFJLEVBQUM7Z0JBQ1gsSUFBSSxHQUFHLENBQUMsQ0FBQztnQkFDVCxLQUFLLEdBQUcsQ0FBQyxDQUFDO2FBQ1Y7WUFDRCxDQUFDLEVBQUUsQ0FBQztTQUNKO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDWCxDQUFDO0NBT0o7QUEzR0QsZ0NBMkdDOzs7Ozs7QUNqR0QsU0FBZ0IsUUFBUSxDQUFDLEdBQVE7SUFDN0IsT0FBTyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsS0FBSyxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUM7QUFDeEQsQ0FBQztBQUZELDRCQUVDOzs7Ozs7OztBQ3BCRCxrREFBMEI7QUFFMUIsb0JBQW9CO0FBQ3BCLE1BQXFCLE1BQU07SUFHMUI7UUFDQyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksWUFBWSxDQUFDO1lBQzNCLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ1YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7U0FDVixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsaUJBQWlCO0lBQ2pCLE1BQU0sS0FBSyxRQUFRO1FBQ2xCLE9BQU8sSUFBSSxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQsTUFBTSxLQUFLLElBQUk7UUFDZCxPQUFPLElBQUksTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVELFlBQVk7SUFDWixJQUFJLEdBQUcsQ0FBQyxDQUFTO1FBQ2hCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxHQUFHLENBQUMsR0FBVyxFQUFFLEdBQVcsRUFBRSxLQUFhO1FBQzFDLElBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsRUFBQztZQUMzQyxNQUFNLGtCQUFrQixHQUFHLEtBQUssR0FBRywrQkFBK0IsQ0FBQTtTQUNsRTtRQUNELElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7UUFFOUIsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQsR0FBRyxDQUFDLEdBQVcsRUFBRSxHQUFXO1FBQzNCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxNQUFNLENBQUMsR0FBRyxLQUFvQjtRQUM3QixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwQixPQUFPLElBQUksQ0FBQztJQUNiLENBQUM7SUFFRCxRQUFRO1FBQ1AsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUNqQixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQ1YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQ1YsQ0FBQTtJQUNGLENBQUM7SUFFRCxJQUFJO1FBQ0gsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUNqQixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQ1YsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFDVixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQ1YsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFFBQWdCO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FDakIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFDOUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQzdDLENBQUMsRUFBTyxDQUFDLEVBQVEsQ0FBQyxFQUFFLENBQUMsRUFDckIsQ0FBQyxFQUFPLENBQUMsRUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUNyQixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxTQUFTLENBQUMsV0FBZ0M7UUFDekMseUNBQXlDO1FBQ3pDLElBQUcsV0FBVyxZQUFZLGNBQUksRUFBQztZQUM5QixXQUFXLEdBQUcsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ3BDO1FBRUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUNqQixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQ3ZCLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFDdkIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUNWLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FDVixDQUFDO0lBQ0gsQ0FBQztJQUVELEtBQUssQ0FBQyxLQUFtQztRQUN4QyxvQ0FBb0M7UUFDcEMsSUFBRyxLQUFLLFlBQVksY0FBSSxFQUFDO1lBQ3hCLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDeEI7YUFBTSxJQUFHLENBQUMsQ0FBQyxLQUFLLFlBQVksWUFBWSxDQUFDLEVBQUM7WUFDMUMsS0FBSyxHQUFHLElBQUksWUFBWSxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDekM7UUFFRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQ2pCLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUksQ0FBQyxFQUFFLENBQUMsRUFDbkIsQ0FBQyxFQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUNyQixDQUFDLEVBQU0sQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQ2YsQ0FBQyxFQUFNLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQyxDQUNmLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQUksQ0FBQyxLQUFhLEVBQUUsR0FBWTtRQUMvQixJQUFJLElBQUksR0FBRyxJQUFJLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVoQyxLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDO1lBQ3pCLEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUM7Z0JBQ3pCLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztnQkFDZCxLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDO29CQUN6QixLQUFLLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQzFDO2dCQUNELElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFJLEtBQUssQ0FBQzthQUN2QjtTQUNEO1FBRUQsSUFBRyxHQUFHLEtBQUssU0FBUyxFQUFDO1lBQ3BCLE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1NBQzNCO2FBQU07WUFDTixPQUFPLElBQUksTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7U0FDcEM7SUFDRixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFtQjtRQUNqQyxxQkFBcUI7UUFDckIsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUUzQiw2Q0FBNkM7UUFDN0MsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUM7WUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDekI7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNiLENBQUM7SUFFRCxPQUFPO1FBQ04sT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxRQUFRO1FBQ1AsT0FBUSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLO1lBQ3RILElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUs7WUFDaEgsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSztZQUNsSCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFDdEgsQ0FBQztDQUNEO0FBbktELHlCQW1LQzs7Ozs7QUNqS0Q7O0dBRUc7QUFDSCxNQUFxQixhQUFhO0lBbUI5Qjs7OztPQUlHO0lBQ04sWUFBWSxJQUFZLEVBQUUsUUFBYyxFQUFFLEtBQWUsRUFBRSxJQUFZLEVBQUUsSUFBVTtRQUNsRixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNYLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ3hCLENBQUM7Q0FDRDtBQS9CRCxnQ0ErQkM7Ozs7Ozs7O0FDdkNELG1EQUEyQjtBQUUzQjs7O0dBR0c7QUFDSCxNQUFxQixHQUFHO0lBQXhCO1FBR0ksc0NBQXNDO1FBQ3RDLGNBQVMsR0FBUyxjQUFJLENBQUMsSUFBSSxDQUFDO1FBQzVCLG9DQUFvQztRQUNwQyxRQUFHLEdBQVMsY0FBSSxDQUFDLElBQUksQ0FBQztRQUN0QixzQ0FBc0M7UUFDdEMsVUFBSyxHQUFTLGNBQUksQ0FBQyxJQUFJLENBQUM7UUFDeEIsbUNBQW1DO1FBQ25DLFdBQU0sR0FBUyxjQUFJLENBQUMsSUFBSSxDQUFDO0lBQzdCLENBQUM7Q0FBQTtBQVhELHNCQVdDOzs7OztBQ2pCRCx3REFBd0Q7QUFDeEQsTUFBcUIsZ0JBQWdCO0lBVXBDOztPQUVHO0lBQ0gsTUFBTSxDQUFDLEVBQXlCO1FBQy9CLHVDQUF1QztRQUN2QyxJQUFHLElBQUksQ0FBQyxPQUFPLEVBQUM7WUFDZixFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMvQjtRQUVELElBQUcsSUFBSSxDQUFDLFlBQVksRUFBQztZQUNwQixFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUNuQztRQUVELElBQUcsSUFBSSxDQUFDLGNBQWMsRUFBQztZQUN0QixFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUNyQztJQUNGLENBQUM7Q0FDRDtBQTNCRCxtQ0EyQkM7Ozs7Ozs7O0FDNUJELG9EQUE0QjtBQUM1QixtREFBMkI7QUFDM0Isc0VBQThDO0FBQzlDLHNEQUE4QjtBQUM5Qix5REFBaUM7QUFFakM7OztHQUdHO0FBQ0gsTUFBcUIsSUFBSyxTQUFRLGVBQUs7SUFJbkM7Ozs7T0FJRztJQUNILFlBQVksTUFBYSxFQUFFLFFBQWU7UUFDdEMsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLGNBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRCxtRUFBbUU7SUFDbkUsSUFBSSxPQUFPO1FBQ1AsT0FBTyxJQUFJLGNBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUN4QyxDQUFDO0lBRUQsb0VBQW9FO0lBQ3BFLElBQUksUUFBUTtRQUNSLE9BQU8sSUFBSSxjQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDekMsQ0FBQztJQUVELHNFQUFzRTtJQUN0RSxJQUFJLFVBQVU7UUFDVixPQUFPLElBQUksY0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQzNDLENBQUM7SUFFRCx1RUFBdUU7SUFDdkUsSUFBSSxXQUFXO1FBQ1gsT0FBTyxJQUFJLGNBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUM1QyxDQUFDO0lBRUQsWUFBWTtJQUNaLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQsWUFBWTtJQUNaLGlCQUFpQjtRQUNiLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUE7UUFDbEMsT0FBTyxJQUFJLGdCQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQsY0FBYztJQUNkLFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQztJQUVELGNBQWM7SUFDZCxXQUFXLENBQUMsUUFBYztRQUN0QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUM3QixDQUFDO0lBRUQsMkNBQTJDO0lBQzNDOzs7O09BSUc7SUFDSCxhQUFhLENBQUMsS0FBVztRQUNyQixPQUFPLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRTtlQUMxRCxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQTtJQUNyRSxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGNBQWMsQ0FBQyxLQUFXO1FBQ3RCLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMxQixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFaEMsSUFBRyxFQUFFLElBQUksQ0FBQyxFQUFDO1lBQ1AsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWhDLElBQUcsRUFBRSxJQUFJLENBQUMsRUFBQztZQUNQLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsaUJBQWlCLENBQUMsS0FBVztRQUN6QixPQUFPLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRTtlQUN6RCxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQTtJQUNwRSxDQUFDO0lBR0Q7Ozs7OztPQU1HO0lBQ0gsZ0JBQWdCLENBQUMsS0FBVyxFQUFFLEtBQVcsRUFBRSxPQUFjO1FBQ3JELElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXZDLElBQUksTUFBTSxHQUFHLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksTUFBTSxHQUFHLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBRXZCLElBQUksS0FBSyxHQUFHLG1CQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ25DLElBQUksS0FBSyxHQUFHLG1CQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRW5DLElBQUksTUFBTSxHQUFHLE1BQU0sR0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEUsSUFBSSxNQUFNLEdBQUcsTUFBTSxHQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwRSxJQUFJLEtBQUssR0FBRyxNQUFNLEdBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25FLElBQUksS0FBSyxHQUFHLE1BQU0sR0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFbkUsSUFBRyxNQUFNLEdBQUcsS0FBSyxJQUFJLE1BQU0sR0FBRyxLQUFLLEVBQUM7WUFDaEMsc0VBQXNFO1lBQ3RFLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUVyQyx3QkFBd0I7UUFDeEIsSUFBRyxNQUFNLEtBQUssTUFBTSxFQUFDO1lBQ2pCLEtBQUssR0FBRyxNQUFNLENBQUM7U0FDbEI7YUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLEVBQUM7WUFDekIsS0FBSyxHQUFHLE1BQU0sQ0FBQztTQUNsQjtRQUVELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRWxDLElBQUcsS0FBSyxLQUFLLENBQUMsUUFBUSxFQUFDO1lBQ25CLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxJQUFHLEtBQUssSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsRUFBQztZQUN2QixPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsbUJBQW1CO1FBQ25CLElBQUksR0FBRyxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFDcEIsR0FBRyxDQUFDLElBQUksR0FBRyxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7UUFDekIsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO1FBRXpCLElBQUcsTUFBTSxHQUFHLE1BQU0sRUFBQztZQUNmLG1DQUFtQztZQUNuQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztZQUN0QixHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDcEI7YUFBTSxJQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLE1BQU0sRUFBQztZQUN6Qyx1QkFBdUI7WUFDdkIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7WUFDdEIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7WUFDdEIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztTQUMxQjthQUFNO1lBQ0gsOEJBQThCO1lBQzlCLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQixHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztTQUN6QjtRQUVELEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUMxQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztRQUN6QyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztRQUV6QyxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFRCxZQUFZO0lBQ1osUUFBUSxDQUFDLEtBQVk7UUFDakIsSUFBRyxLQUFLLFlBQVksSUFBSSxFQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNuQztRQUNELE1BQU0sMkNBQTJDLENBQUE7SUFDckQsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxZQUFZLENBQUMsS0FBVztRQUM5QixJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFM0MsSUFBRyxFQUFFLElBQUksQ0FBQyxFQUFDO1lBQ1AsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFM0MsSUFBRyxFQUFFLElBQUksQ0FBQyxFQUFDO1lBQ1AsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsV0FBVyxDQUFDLEtBQVc7UUFDbkIsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTNDLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMxQixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUUzQyxrRUFBa0U7UUFDbEUsSUFBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFF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dkMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzNFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUN2QyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDcEM7UUFFRCxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztJQUNoRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsT0FBTyxDQUFDLElBQVUsRUFBRSxFQUFRLEVBQUUsS0FBWTtRQUNoRCxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUUxRCxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDdkMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN2QyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQVMsRUFBRSxLQUFZO1FBQ3ZDLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVB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Q0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDdEUsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDdEUsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDdEUsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDdEUsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pHLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLG1CQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFB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QUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzVDLEVBQUUsSUFBSSxFQUFFLDhCQUFXLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzVDLEVBQUUsSUFBSSxFQUFFLDhCQUFXLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzNDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRTtTQUNqQztRQUNELHFCQUFxQjtRQUNyQixRQUFRLEVBQUUsS0FBSztRQUNmLFNBQVMsRUFBRSxLQUFLLEVBQXFCLDBFQUEwRTtLQUNsSCxDQUFBO0lBRUQsMkJBQTJCO0lBQzNCLGtEQUFrRDtJQUNsRCwrREFBK0Q7SUFDL0QsMkVBQTJFO0lBQzNFLG1FQUFtRTtJQUNuRSx1RUFBdUU7SUFFdkUsa0RBQWtEO0lBQ2xELDJCQUEyQjtJQUMzQix1QkFBdUI7SUFDdkIsK0JBQStCO0lBQy9CLDhCQUE4QjtJQUM5QixLQUFLO0lBQ0wsMkNBQTJDO0lBQzNDLE1BQU0sSUFBSSxHQUFHLElBQUksY0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQy9CLGlCQUFpQjtJQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLHlCQUFlLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDaEMsNkJBQTZCO0lBQzdCLCtCQUErQjtJQUMvQiw4QkFBOEI7SUFDOUIscUNBQXFDO0lBQ3JDLHVDQUF1QztJQUN2Qyw0QkFBNEI7QUFDaEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUVMLFNBQVMsUUFBUSxLQUFLLENBQUM7QUFBQSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcbmltcG9ydCBHb2FwQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9Hb2FwL0dvYXBBSVwiXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5cbi8qKlxuICogQSBtYW5hZ2VyIGNsYXNzIGZvciBhbGwgb2YgdGhlIEFJIGluIGEgc2NlbmUuXG4gKiBLZWVwcyBhIGxpc3Qgb2YgcmVnaXN0ZXJlZCBhY3RvcnMgYW5kIGhhbmRsZXMgQUkgZ2VuZXJhdGlvbiBmb3IgYWN0b3JzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBSU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblx0LyoqIFRoZSBhcnJheSBvZiByZWdpc3RlcmVkIGFjdG9ycyAqL1xuXHRhY3RvcnM6IEFycmF5PEFjdG9yPjtcblx0LyoqIE1hcHMgQUkgbmFtZXMgdG8gdGhlaXIgY29uc3RydWN0b3JzICovXG5cdHJlZ2lzdGVyZWRBSTogTWFwPEFJQ29uc3RydWN0b3I+O1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5hY3RvcnMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLnJlZ2lzdGVyZWRBSSA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gYWN0b3Igd2l0aCB0aGUgQUlNYW5hZ2VyXG5cdCAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gcmVnaXN0ZXJcblx0ICovXG5cdHJlZ2lzdGVyQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XG5cdFx0dGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XG5cdH1cblxuXHRyZW1vdmVBY3RvcihhY3RvcjogQWN0b3IpOiB2b2lkIHtcblx0XHRsZXQgaW5kZXggPSB0aGlzLmFjdG9ycy5pbmRleE9mKGFjdG9yKTtcblxuXHRcdGlmKGluZGV4ICE9PSAtMSl7XG5cdFx0XHR0aGlzLmFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gQUkgd2l0aCB0aGUgQUlNYW5hZ2VyIGZvciB1c2UgbGF0ZXIgb25cblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIHJlZ2lzdGVyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgQUlcblx0ICovXG5cdHJlZ2lzdGVyQUkobmFtZTogc3RyaW5nLCBjb25zdHI6IG5ldyA8VCBleHRlbmRzIEFJIHwgR29hcEFJPigpID0+IFQgKTogdm9pZCB7XG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkuYWRkKG5hbWUsIGNvbnN0cik7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGFuIEFJIGluc3RhbmNlIGZyb20gaXRzIG5hbWVcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIGFkZFxuXHQgKiBAcmV0dXJucyBBIG5ldyBBSSBpbnN0YW5jZVxuXHQgKi9cblx0Z2VuZXJhdGVBSShuYW1lOiBzdHJpbmcpOiBBSSB8IEdvYXBBSSB7XG5cdFx0aWYodGhpcy5yZWdpc3RlcmVkQUkuaGFzKG5hbWUpKXtcblx0XHRcdHJldHVybiBuZXcgKHRoaXMucmVnaXN0ZXJlZEFJLmdldChuYW1lKSkoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgYENhbm5vdCBjcmVhdGUgQUkgd2l0aCBuYW1lICR7bmFtZX0sIG5vIEFJIHdpdGggdGhhdCBuYW1lIGlzIHJlZ2lzdGVyZWRgO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIFJ1biB0aGUgYWkgZm9yIGV2ZXJ5IGFjdGl2ZSBhY3RvclxuXHRcdHRoaXMuYWN0b3JzLmZvckVhY2goYWN0b3IgPT4geyBpZihhY3Rvci5haUFjdGl2ZSkgYWN0b3IuYWkudXBkYXRlKGRlbHRhVCkgfSk7XG5cdH1cbn1cblxudHlwZSBBSUNvbnN0cnVjdG9yID0gbmV3IDxUIGV4dGVuZHMgQUk+KCkgPT4gVDsiLCJpbXBvcnQgQWN0b3IgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZVwiO1xuaW1wb3J0IFN0YXRlTWFjaGluZUdvYXBBSSBmcm9tIFwiLi9TdGF0ZU1hY2hpbmVHb2FwQUlcIjtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR29hcEFjdGlvbiBleHRlbmRzIFN0YXRlIHtcblxuICAgIHByb3RlY3RlZCBwYXJlbnQ6IFN0YXRlTWFjaGluZUdvYXBBSTxHb2FwQWN0aW9uPlxuICAgIHByb3RlY3RlZCBhY3RvcjogQWN0b3I7XG5cbiAgICBwcm90ZWN0ZWQgX3ByZWNvbmRpdGlvbnM6IFNldDxzdHJpbmc+O1xuICAgIHByb3RlY3RlZCBfZWZmZWN0czogU2V0PHN0cmluZz47XG4gICAgcHJvdGVjdGVkIF9jb3N0OiBudW1iZXI7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocGFyZW50OiBTdGF0ZU1hY2hpbmVHb2FwQUk8R29hcEFjdGlvbj4sIGFjdG9yOiBBY3Rvcikge1xuICAgICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgICB0aGlzLmFjdG9yID0gYWN0b3I7XG4gICAgICAgIHRoaXMuX3ByZWNvbmRpdGlvbnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgdGhpcy5fZWZmZWN0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICB0aGlzLl9jb3N0ID0gMDtcbiAgICB9XG5cbiAgICAvKiogQ29zdCBpdCB0YWtlcyB0byBjb21wbGV0ZSB0aGlzIGFjdGlvbiAqL1xuICAgIGdldCBjb3N0KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9jb3N0OyB9XG4gICAgc2V0IGNvc3QoY29zdDogbnVtYmVyKSB7IHRoaXMuX2Nvc3QgPSBjb3N0OyB9XG5cbiAgICAvKiogUHJlY29uZGl0aW9ucyB0aGF0IGhhdmUgdG8gYmUgc2F0aXNmaWVkIGZvciBhbiBhY3Rpb24gdG8gaGFwcGVuICovXG4gICAgZ2V0IHByZWNvbmRpdGlvbnMoKTogc3RyaW5nW10geyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9wcmVjb25kaXRpb25zLnZhbHVlcygpKTsgfTtcblxuICAgIC8qKiBSZXN1bHRpbmcgc3RhdHVzZXMgYWZ0ZXIgdGhpcyBhY3Rpb24gY29tcGxldGVzICovXG4gICAgZ2V0IGVmZmVjdHMoKTogc3RyaW5nW10geyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9lZmZlY3RzLnZhbHVlcygpKTsgfVxuXG4gICAgcHVibGljIGNoZWNrUHJlY29uZGl0aW9ucyhzdGF0dXM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3ByZWNvbmRpdGlvbnMudmFsdWVzKCkpLmV2ZXJ5KHByZWNvbmRpdGlvbiA9PiBzdGF0dXMuaW5jbHVkZXMocHJlY29uZGl0aW9uKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFkZFByZWNvbmRpdGlvbihzdGF0dXM6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLl9wcmVjb25kaXRpb25zLmFkZChzdGF0dXMpO1xuICAgIH1cbiAgICBwdWJsaWMgYWRkRWZmZWN0KHN0YXR1czogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VmZmVjdHMuYWRkKHN0YXR1cyk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGZpbmlzaGVkKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudC5jaGFuZ2VTdGF0ZSgpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZW51bSBHb2FwQWN0aW9uU3RhdHVzIHtcbiAgICBGQUlMVVJFID0gMCxcbiAgICBTVUNDRVNTID0gMSxcbiAgICBSVU5OSU5HID0gMlxufSIsImltcG9ydCBHcmFwaCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0dyYXBocy9HcmFwaFwiO1xuaW1wb3J0IEdvYXBBY3Rpb24gZnJvbSBcIi4vR29hcEFjdGlvblwiO1xuaW1wb3J0IFN0YWNrIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvU3RhY2tcIjtcbmltcG9ydCBHcmFwaFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9HcmFwaFV0aWxzXCI7XG5pbXBvcnQgQUkgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvYXBBY3Rpb25QbGFubmVyIHtcbiAgICBcbiAgICBwdWJsaWMgc3RhdGljIHBsYW48VCBleHRlbmRzIEdvYXBBY3Rpb24+KHN0YXR1czogc3RyaW5nW10sIGdvYWw6IHN0cmluZywgYWN0aW9uczogQXJyYXk8VD4pOiBTdGFjazxUPiB7XG4gICAgICAgIGxldCBncmFwaDogR3JhcGggPSBuZXcgR3JhcGgodHJ1ZSk7XG4gICAgICAgIGxldCBtYXBwaW5nOiBNYXA8bnVtYmVyLCBUIHwgc3RyaW5nPiA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvLzAgaXMgb3VyIHJvb3RcbiAgICAgICAgZ3JhcGguYWRkTm9kZSgpO1xuICAgICAgICBtYXBwaW5nLnNldCgwLFwiU3RhcnRcIik7XG4gICAgICAgIC8vMSBpcyB0aGUgZ29hbFxuICAgICAgICBncmFwaC5hZGROb2RlKCk7XG4gICAgICAgIG1hcHBpbmcuc2V0KDEsXCJHb2FsXCIpO1xuICAgICAgICBncmFwaC5hZGRFZGdlKDEsMSxOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG4gICAgICAgIC8vQnVpbGQgdHJlZSBmcm9tIDAgdG8gMVxuICAgICAgICB0aGlzLmJ1aWxkVHJlZTxUPihzdGF0dXMsIGFjdGlvbnMsIDAsIGdvYWwsIG1hcHBpbmcsIGdyYXBoKTtcblxuICAgICAgICAvL1J1biBkamlrc3RyYSB0byBmaW5kIHNob3J0ZXN0IHBhdGhcbiAgICAgICAgbGV0IHBhdGg6IEFycmF5PG51bWJlcj4gPSBHcmFwaFV0aWxzLmRqaWtzdHJhKGdyYXBoLCAwKTtcblxuICAgICAgICAvL1B1c2ggYWxsIGVsZW1lbnRzIG9mIHRoZSBwbGFuXG4gICAgICAgIGxldCBwbGFuID0gbmV3IFN0YWNrPFQ+KCk7XG5cdFx0XG5cdFx0bGV0IGkgPSAxO1xuXHRcdHdoaWxlKHBhdGhbaV0gIT09IC0xKXtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldICE9PSAwKXtcblx0XHRcdCAgICBwbGFuLnB1c2goPFQ+bWFwcGluZy5nZXQocGF0aFtpXSkpO1xuICAgICAgICAgICAgfVxuXHRcdFx0aSA9IHBhdGhbaV07XG5cdFx0fVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHBsYW47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgYnVpbGRUcmVlICA8VCBleHRlbmRzIEdvYXBBY3Rpb24+IChzdGF0dXM6IHN0cmluZ1tdLCBhY3Rpb25zOiBBcnJheTxUPiwgcm9vdDogbnVtYmVyLCBnb2FsOiBzdHJpbmcsIG1hcHBpbmc6IE1hcDxudW1iZXIsIFQgfCBzdHJpbmc+LCBncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICAgICAgLy9Gb3IgZWFjaCBwb3NzaWJsZSBhY3Rpb24gXG4gICAgICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICAgICAgLy9DYW4gaXQgYmUgcGVyZm9ybWVkP1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5jaGVja1ByZWNvbmRpdGlvbnMoc3RhdHVzKSl7XG4gICAgICAgICAgICAgICAgLy9UaGlzIGFjdGlvbiBjYW4gYmUgcGVyZm9ybWVkXG4gICAgICAgICAgICAgICAgLy9BZGQgZWZmZWN0cyB0byBjdXJyZW50U3RhdHVzXG4gICAgICAgICAgICAgICAgbGV0IG5ld1N0YXR1cyA9IFsuLi5zdGF0dXNdO1xuICAgICAgICAgICAgICAgIG5ld1N0YXR1cy5wdXNoKC4uLmFjdGlvbi5lZmZlY3RzKTtcblxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgaWYgdGhlIG5ldyBub2RlIGlzIHRoZSBnb2FsXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cy5pbmNsdWRlcyhnb2FsKSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdOb2RlID0gZ3JhcGguYWRkTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNldChuZXdOb2RlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlKHJvb3QsIG5ld05vZGUsIGFjdGlvbi5jb3N0KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYWRkRWRnZShuZXdOb2RlLCAxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vQWRkIG5vZGUgYW5kIGVkZ2UgZnJvbSByb290XG4gICAgICAgICAgICAgICAgbGV0IG5ld05vZGUgPSBncmFwaC5hZGROb2RlKCk7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5zZXQobmV3Tm9kZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlKHJvb3QsIG5ld05vZGUsIGFjdGlvbi5jb3N0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL1JlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgICAgICAgbGV0IG5ld0FjdGlvbnMgPSBhY3Rpb25zLmZpbHRlcihhY3QgPT4gYWN0ICE9PSBhY3Rpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFRyZWUobmV3U3RhdHVzLCBuZXdBY3Rpb25zLCBuZXdOb2RlLCBnb2FsLCBtYXBwaW5nLCBncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQgQWN0b3IgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XG5cbi8qKlxuICogQSBzdGF0ZSBmb3IgYSBHb2FwQUkuIFRoZSBcInN0YXRlXCIgaXMgbm90IHRoZSBzYW1lIGFzIGEgc3RhdGUgaW4gYSBzdGF0ZSBtYWNoaW5lLCBvciBzb21ldGhpbmcgb2YgdGhhdCBuYXR1cmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEdvYXBTdGF0ZSB7XG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgaXNTYXRpc2ZpZWQoKTogYm9vbGVhbjtcbiAgICBcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9TdGFja1wiO1xuaW1wb3J0IEdvYXBBY3Rpb24gZnJvbSBcIi4vR29hcEFjdGlvblwiO1xuaW1wb3J0IEdvYXBBY3Rpb25QbGFubmVyIGZyb20gXCIuL0dvYXBBY3Rpb25QbGFubmVyXCJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBBSSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcbmltcG9ydCBHb2FwU3RhdGUgZnJvbSBcIi4vR29hcFN0YXRlXCI7XG5pbXBvcnQgU3RhdGVNYWNoaW5lQUkgZnJvbSBcIi4uL1N0YXRlTWFjaGluZUFJXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgR29hcCBiZWhhdmlvci5cbiAqIFxuICogR09BUCByZXF1aXJlcyBhIGxvdCBvZiBvdmVyaGVhZCBmb3IgbWFuYWdpbmcgYWxsIG9mIHRoZSBzeW1ib2xzIChzdGF0dXNlcyBhbmQgZ29hbHMpLCB0aGVcbiAqIGFjdHVhbCBnb2FwLWFjdGlvbnMsIGFuZCBjcmVhdGluZyB0aGUgYWN0aW9uIHBsYW5zLiBcbiAqIFxuICogSSd2ZSBvcHRlZCB0byB0cnkgYW5kIGV4dGVuZCB0aGUgU3RhdGVNYWNoaW5lQUkgZm9yIHRoaXMgY2xhc3MsIG1vc3RseSB0byB0cnkgYW5kIGtlZXAgdGhpbmdzXG4gKiBzaW1pbGFyIHRvIHRoZSBTdGF0ZU1hY2hpbmVBSS4gTXkgU3RhdGVNYWNoaW5lR29hcEFJIGNsYXNzIGtpbmQgb2YgYnJlYWtzIExTUCAoTGlza292J3Mgc3Vic3RpdHV0aW9uIHByaW5jaXBsZSlcbiAqIHdoaWNoIGN1ZXMgbWUgaW50byB0aGUgZmFjdCB0aGF0IEkgc2hvdWxkIHByb2JhYmx5IG1ha2UgYSBzZXBlcmF0ZSBjbGFzcy5cbiAqIFxuICogU29tZXRoaW5nIEknZCBsaWtlIHRvIGFkZCBpcyBhbiBhZGRpdGlvbmFsIGNsYXNzIGZvciBtYW5hZ2luZyBhIHNldCBvZiBnb2Fscy4gVGhlIGdvYWxzIFxuICogYXJlIHByZXR0eSBzaW1pbGFyIHRvIHN0YXR1c2VzLCBleGNlcHQgdGhhdCBnb2FscyBoYXZlIHNvbWUga2luZCBvZmYgcHJpb3JpdHkgYXNzb2NpYXRlZFxuICogd2l0aCB0aGVtLiBOb3Qgc3VyZSBob3cgd2UnZCBkbyB0aGlzLlxuICogXG4gKiBAYXV0aG9yIFBldGVyIFdhbHNoXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFN0YXRlTWFjaGluZUdvYXBBSTxUIGV4dGVuZHMgR29hcEFjdGlvbj4gZXh0ZW5kcyBTdGF0ZU1hY2hpbmVBSSB7XG5cbiAgICAvKiogVGhlIHBhcmVudCBBY3RvciBvZiB0aGlzIEdvYXBBSSAqL1xuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XG5cbiAgICAvKiogVGhlIGdvYWwvc3RhdHVzIHdlJ3JlIHRyeWluZyB0byByZWFjaCAqL1xuICAgIHByb3RlY3RlZCBnb2FsOiBzdHJpbmc7XG4gICAgLyoqIEFsbCBzdGF0dXNlcyBmb3IgdGhpcyBHb2FwQUkgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdHVzZXM6IE1hcDxHb2FwU3RhdGU+XG4gICAgLyoqIEFsbCBvZiB0aGUgYWN0aW9uIHRoZSBHT0FQIEFJIGNhbiBwZXJmb3JtICovXG4gICAgcHJvdGVjdGVkIHN0YXRlTWFwOiBNYXA8VD47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzZXMgPSBuZXcgTWFwPEdvYXBTdGF0ZT4oKTtcbiAgICAgICAgdGhpcy5zdGF0ZU1hcCA9IG5ldyBNYXA8VD4oKTtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjazxUPigpO1xuICAgICAgICB0aGlzLmdvYWwgPSBudWxsO1xuICAgIH1cblxuXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaW5pdGlhbGl6ZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgQUkgYnkgYnVpbGRpbmcgYSBwbGFuIGZyb20gdGhlIHRoZSBjdXJyZW50IGFjdGlvbnNcbiAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuYnVpbGRQbGFuKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLm9uRW50ZXIoe30pO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZSh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBOT1RFOyB0aGlzIG1ldGhvZCBtaWdodCB0cmlnZ2VyIGluZmluaXRlIHJlY3Vyc2lvbiBpbiB5b3VyIEdPQVAgQUkgLSBQZXRleWx1bXBraW5zXG4gICAgcHVibGljIG92ZXJyaWRlIGNoYW5nZVN0YXRlKCk6IHZvaWQge1xuICAgICAgICAvLyBFeGl0IHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5jdXJyZW50U3RhdGUub25FeGl0KCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBwbGFuIGlzIGVtcHR5LCBidWlsZCBhIG5ldyBwbGFuXG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMuYnVpbGRQbGFuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgYWN0aW9uXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XG5cbiAgICAgICAgLy8gRW1pdCBhbiBldmVudCBpZiB0dXJuZWQgb25cbiAgICAgICAgaWYodGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSwge3N0YXRlOiB0aGlzLmN1cnJlbnRTdGF0ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW50ZXIgdGhlIG5ldyBhY3Rpb25cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcbiAgICB9XG4gICBcbiAgICBwcm90ZWN0ZWQgYnVpbGRQbGFuKCk6IFN0YWNrPFQ+IHtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgY3VycmVudCBzdGF0dXNlc1xuICAgICAgICBsZXQgc3RhdHVzZXMgPSB0aGlzLmN1cnJlbnRTdGF0dXMoKTtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgY3VycmVudCBhY3Rpb25zXG4gICAgICAgIGxldCBhY3Rpb25zID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlTWFwLmtleXMoKSkubWFwKGtleSA9PiB0aGlzLnN0YXRlTWFwLmdldChrZXkpKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBwbGFuXG4gICAgICAgIHJldHVybiBHb2FwQWN0aW9uUGxhbm5lci5wbGFuPFQ+KHN0YXR1c2VzLCB0aGlzLmdvYWwsIGFjdGlvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjdXJyZW50U3RhdHVzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdGF0dXNlcy5rZXlzKCkpLmZpbHRlcihzdGF0ID0+IHRoaXMuc3RhdHVzZXMuZ2V0KHN0YXQpLmlzU2F0aXNmaWVkKCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRHb2FsKGdvYWw6IHN0cmluZykgeyBcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c2VzLmhhcyhnb2FsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR29hbCBkb2Vzbid0IGV4aXN0LiBNYWtlIHN1cmUgeW91ciBnb2FsIGlzIGEgc3RhdHVzIGZvciB0aGlzIEdPQVAgQUlcIilcbiAgICAgICAgfSAgIFxuICAgICAgICB0aGlzLmdvYWwgPSBnb2FsO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRTdGF0dXMoc3RhdHVzTmFtZTogc3RyaW5nLCBzdGF0dXM6IEdvYXBTdGF0ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YXR1c2VzLnNldChzdGF0dXNOYW1lLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRTdGF0ZShzdGF0ZU5hbWU6IHN0cmluZywgc3RhdGU6IEdvYXBBY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuYWRkU3RhdGUoc3RhdGVOYW1lLCBzdGF0ZSk7XG4gICAgfVxuXG5cbn0iLCJpbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XG5pbXBvcnQgU3RhdGVNYWNoaW5lIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5cbi8qKlxuICogQSB2ZXJzaW9uIG9mIGEgQHJlZmVyZW5jZVtTdGF0ZU1hY2hpbmVdIHRoYXQgaXMgY29uZmlndXJlZCB0byB3b3JrIGFzIGFuIEFJIGNvbnRyb2xsZXIgZm9yIGEgQHJlZmVyZW5jZVtHYW1lTm9kZV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVNYWNoaW5lQUkgZXh0ZW5kcyBTdGF0ZU1hY2hpbmUgaW1wbGVtZW50cyBBSSB7XG5cdC8qKlx0VGhlIEdhbWVOb2RlIHRoYXQgdXNlcyB0aGlzIFN0YXRlTWFjaGluZSBmb3IgaXRzIEFJICovXG5cdHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGluaXRpYWxpemVBSShvd25lcjogR2FtZU5vZGUsIGNvbmZpZzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQgeyB9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGRlc3Ryb3koKXtcblx0XHQvLyBHZXQgcmlkIG9mIG91ciByZWZlcmVuY2UgdG8gdGhlIG93bmVyXG5cdFx0ZGVsZXRlIHRoaXMub3duZXI7XG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0YWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi4vSW50ZXJmYWNlcy9Db2xsZWN0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpbmFyeUhlYXBTZXQ8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgTUFYX0VMRU1FTlRTOiBudW1iZXI7XG4gICAgcHJpdmF0ZSByZWFkb25seSBST09UOiBudW1iZXI7XG5cbiAgICAvKiogQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBiaW5hcnkgaGVhcCBiYWNraW5nIHRoZSBwcmlvcml0eSBxdWV1ZSAqL1xuICAgIHByaXZhdGUgaGVhcDogQXJyYXk8VD47XG4gICAgLyoqIEEgbWFwcGluZyBvZiBub2RlcyB0aGF0IGV4aXN0IGluIHRoZSBxdWV1ZSB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGhlYXAgYXJyYXkgKi9cbiAgICBwcml2YXRlIG1hcDogTWFwPFQsIG51bWJlcj47XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiBlbGVtZW50cyBjdXJyZW50bHkgaW4gdGhlIGhlYXAgKi9cbiAgICBwcml2YXRlIHNpemU6IG51bWJlcjtcbiAgICAvKiogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIGhlYXAgZWxlbWVudHMgKi9cbiAgICBwcml2YXRlIGNvbXA6IChlMTogVCwgZTI6IFQpID0+IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmVUbzogKGUxOiBULCBlMjogVCkgPT4gbnVtYmVyLCBtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKSB7XG4gICAgICAgIHRoaXMuUk9PVCA9IDA7XG4gICAgICAgIHRoaXMuTUFYX0VMRU1FTlRTID0gbWF4RWxlbWVudHM7XG5cbiAgICAgICAgdGhpcy5oZWFwID0gbmV3IEFycmF5KHRoaXMuTUFYX0VMRU1FTlRTKTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwPFQsIG51bWJlcj4oKTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5jb21wID0gY29tcGFyZVRvO1xuICAgIH1cblxuICAgIHB1c2goZTogVCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMubWFwLmhhcyhlKSkge1xuICAgICAgICAgICAgdGhpcy5oZWFwW3RoaXMuc2l6ZV0gPSBlO1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGUsIHRoaXMuc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnBlcmN1cCh0aGlzLnNpemUpO1xuICAgICAgICAgICAgdGhpcy5zaXplICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwb3AoKTogVCB7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdGhpcy5tYXAuZGVsZXRlKHRoaXMuaGVhcFt0aGlzLlJPT1RdKTtcbiAgICAgICAgdGhpcy5zaXplIC09IDE7XG5cbiAgICAgICAgdGhpcy5oZWFwW3RoaXMuUk9PVF0gPSB0aGlzLmhlYXBbdGhpcy5zaXplXTtcbiAgICAgICAgdGhpcy5wZXJjZG93bih0aGlzLlJPT1QpO1xuXG4gICAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgcGVlaygpOiBUIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhcFt0aGlzLlJPT1RdO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IDA7XG4gICAgfVxuXG4gICAgZm9yRWFjaChmdW5jOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYXAuZm9yRWFjaChmdW5jKCkpO1xuICAgIH1cblxuICAgIGNsZWFyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYXAuZmlsbChudWxsKTtcbiAgICB9XG5cbiAgICByZXN0b3JlKHZhbHVlOiBUKTogdm9pZCB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5tYXAuZ2V0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5wZXJjdXAobm9kZSk7XG4gICAgICAgIHRoaXMucGVyY2Rvd24obm9kZSk7XG4gICAgfVxuXG4gICAgaGFzKHZhbHVlOiBUKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXMgPSBcIkJhY2tpbmcgSGVhcDogW1wiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICByZXMgKz0gYCR7dGhpcy5oZWFwW2ldfWBcbiAgICAgICAgICAgIGlmIChpIDwgdGhpcy5zaXplIC0gMSkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBcIiwgXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gXCJdXFxuTWFwOiBbXFxuXCI7XG4gICAgICAgIHRoaXMubWFwLmZvckVhY2goKHZhbDogbnVtYmVyLCBrZXk6IFQpID0+IHtcbiAgICAgICAgICAgIHJlcyArPSBgXFx0JHtrZXl9IC0+ICR7dmFsfVxcbmA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXMgKz0gXCJdXCI7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBlcmN1cChub2RlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHBybnQgPSB0aGlzLnBhcmVudChub2RlKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgPiB0aGlzLlJPT1QgJiYgdGhpcy5jb21wKHRoaXMuaGVhcFtub2RlXSwgdGhpcy5oZWFwW3BybnRdKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3dhcChub2RlLCBwcm50KTtcbiAgICAgICAgICAgIG5vZGUgPSBwcm50O1xuICAgICAgICAgICAgcHJudCA9IHRoaXMucGFyZW50KG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBwZXJjZG93bihub2RlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5sY2hpbGQobm9kZSk7XG4gICAgICAgIHdoaWxlIChjaGlsZCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkIDwgdGhpcy5zaXplIC0gMSAmJiB0aGlzLmNvbXAodGhpcy5oZWFwW2NoaWxkXSwgdGhpcy5oZWFwW2NoaWxkICsgMV0pIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjaGlsZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcCh0aGlzLmhlYXBbY2hpbGRdLCB0aGlzLmhlYXBbbm9kZV0pID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dhcChub2RlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5sY2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcmVudChub2RlOiBudW1iZXIpOiBudW1iZXIgeyBcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKG5vZGUgLSAxKS8yKTsgXG4gICAgfVxuICAgIHByb3RlY3RlZCBsY2hpbGQobm9kZTogbnVtYmVyKTogbnVtYmVyIHsgXG4gICAgICAgIHJldHVybiBub2RlKjIgKyAxOyBcbiAgICB9XG4gICAgcHJvdGVjdGVkIHJjaGlsZChub2RlOiBudW1iZXIpOiBudW1iZXIgeyBcbiAgICAgICAgcmV0dXJuIG5vZGUqMiArIDI7IFxuICAgIH1cbiAgICBwcm90ZWN0ZWQgc3dhcChub2RlMTogbnVtYmVyLCBub2RlMjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWFwLnNldCh0aGlzLmhlYXBbbm9kZTFdLCBub2RlMik7XG4gICAgICAgIHRoaXMubWFwLnNldCh0aGlzLmhlYXBbbm9kZTJdLCBub2RlMSk7XG5cbiAgICAgICAgbGV0IHRlbXAgPSB0aGlzLmhlYXBbbm9kZTFdO1xuICAgICAgICB0aGlzLmhlYXBbbm9kZTFdID0gdGhpcy5oZWFwW25vZGUyXTtcbiAgICAgICAgdGhpcy5oZWFwW25vZGUyXSA9IHRlbXA7XG4gICAgfVxuICAgIFxufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuLi9JbnRlcmZhY2VzL0NvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBc3NvY2lhdGVzIHN0cmluZ3Mgd2l0aCBlbGVtZW50cyBvZiB0eXBlIFRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XG5cdHByaXZhdGUgbWFwOiBSZWNvcmQ8c3RyaW5nLCBUPjtcblxuXHQvKiogQ3JlYXRlcyBhIG5ldyBtYXAgKi9cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLm1hcCA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSB2YWx1ZSBUIHN0b3JlZCBhdCBhIGtleS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGJlIHN0b3JlZFxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXG5cdCAqL1xuXHRhZGQoa2V5OiBzdHJpbmcsIHZhbHVlOiBUKTogdm9pZCB7XG5cdFx0dGhpcy5tYXBba2V5XSA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEga2V5LlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW1cblx0ICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGtleSBvciB1bmRlZmluZWRcblx0ICovXG5cdGdldChrZXk6IHN0cmluZyk6IFQge1xuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFuIGFsaWFzIG9mIGFkZC4gU2V0cyB0aGUgdmFsdWUgc3RvcmVkIGF0IGtleSB0byB0aGUgbmV3IHNwZWNpZmllZCB2YWx1ZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gYmUgc3RvcmVkXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgaXRlbSB0byBiZSBzdG9yZWRcblx0ICovXG5cdHNldChrZXk6IHN0cmluZywgdmFsdWU6IFQpOiB2b2lkIHtcblx0XHR0aGlzLmFkZChrZXksIHZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYSB2YWx1ZSBzdG9yZWQgYXQgdGhlIHNwZWNpZmllZCBrZXksIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGNoZWNrXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGUgZ2l2ZW4ga2V5LlxuXHQgKi9cblx0aGFzKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMubWFwW2tleV0gIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUga2V5cyBpbiB0aGlzIG1hcC5cblx0ICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyBhbGwga2V5cyBpbiB0aGUgbWFwLlxuXHQgKi9cblx0a2V5cygpOiBBcnJheTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApO1xuXHR9XG5cdFxuXHQvLyBAaW1wbGVtZW50ZWRcblx0Zm9yRWFjaChmdW5jOiAoa2V5OiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcblx0XHRPYmplY3Qua2V5cyh0aGlzLm1hcCkuZm9yRWFjaChrZXkgPT4gZnVuYyhrZXkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGFuIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGEga2V5XG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBhdCB3aGljaCB0byBkZWxldGUgYW4gaXRlbVxuXHQgKi9cblx0ZGVsZXRlKGtleTogc3RyaW5nKTogdm9pZCB7XG5cdFx0ZGVsZXRlIHRoaXMubWFwW2tleV07XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0Y2xlYXIoKTogdm9pZCB7XG5cdFx0dGhpcy5mb3JFYWNoKGtleSA9PiBkZWxldGUgdGhpcy5tYXBba2V5XSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhpcyBtYXAgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG5cdCAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXAuXG5cdCAqL1xuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdGxldCBzdHIgPSBcIlwiO1xuXG5cdFx0dGhpcy5mb3JFYWNoKChrZXkpID0+IHN0ciArPSBrZXkgKyBcIiAtPiBcIiArIHRoaXMuZ2V0KGtleSkudG9TdHJpbmcoKSArIFwiXFxuXCIpO1xuXG5cdFx0cmV0dXJuIHN0cjtcblx0fVxufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuLi9JbnRlcmZhY2VzL0NvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBIEZJRk8gcXVldWUgd2l0aCBlbGVtZW50cyBvZiB0eXBlIFRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVldWU8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBRdWV1ZSAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgTUFYX0VMRU1FTlRTOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWV1ZSAqL1xuICAgIHByaXZhdGUgcTogQXJyYXk8VD47XG4gICAgXG4gICAgLyoqIFRoZSBoZWFkIG9mIHRoZSBxdWV1ZSAqL1xuICAgIHByaXZhdGUgaGVhZDogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgdGFpbCBvZiB0aGUgcXVldWUgKi9cbiAgICBwcml2YXRlIHRhaWw6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgY3VycmVudCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHF1ZXVlICovXG4gICAgcHJpdmF0ZSBzaXplOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHF1ZXVlXG4gICAgICogQHBhcmFtIG1heEVsZW1lbnRzIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHN0YWNrXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF4RWxlbWVudHM6IG51bWJlciA9IDEwMCl7XG4gICAgICAgIHRoaXMuTUFYX0VMRU1FTlRTID0gbWF4RWxlbWVudHM7XG4gICAgICAgIHRoaXMucSA9IG5ldyBBcnJheSh0aGlzLk1BWF9FTEVNRU5UUyk7XG4gICAgICAgIHRoaXMuaGVhZCA9IDA7XG4gICAgICAgIHRoaXMudGFpbCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpdGVtIHRvIHRoZSBiYWNrIG9mIHRoZSBxdWV1ZVxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcbiAgICAgKi9cbiAgICBlbnF1ZXVlKGl0ZW06IFQpOiB2b2lke1xuICAgICAgICBpZigodGhpcy50YWlsICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUyA9PT0gdGhpcy5oZWFkKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpemUgKz0gMTtcbiAgICAgICAgdGhpcy5xW3RoaXMudGFpbF0gPSBpdGVtO1xuICAgICAgICB0aGlzLnRhaWwgPSAodGhpcy50YWlsICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICovXG4gICAgZGVxdWV1ZSgpOiBUIHtcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSB0aGlzLnRhaWwpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgZW1wdHkgLSBjYW5ub3QgcmVtb3ZlIGVsZW1lbnRcIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuc2l6ZSAtPSAxO1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMucVt0aGlzLmhlYWRdO1xuICAgICAgICAvLyBOb3cgZGVsZXRlIHRoZSBpdGVtXG4gICAgICAgIGRlbGV0ZSB0aGlzLnFbdGhpcy5oZWFkXTtcbiAgICAgICAgdGhpcy5oZWFkID0gKHRoaXMuaGVhZCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWUsIGJ1dCBkb2VzIG5vdCByZW1vdmUgaXRcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICovXG4gICAgcGVla05leHQoKTogVCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gdGhpcy50YWlsKXtcbiAgICAgICAgICAgIHRocm93IFwiUXVldWUgZW1wdHkgLSBjYW5ub3QgZ2V0IGVsZW1lbnRcIlxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVldWUgaGFzIGl0ZW1zIGluIGl0LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgcXVldWUgaGFzIGl0ZW1zXG4gICAgICovXG4gICAgaGFzSXRlbXMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgIT09IHRoaXMudGFpbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIGdldFNpemUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICB9XG5cbiAgICAvLyBAaW1wbGVtZW50ZWRcbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gZGVsZXRlIHRoaXMucVtpbmRleF0pO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWw7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgZm9yRWFjaChmdW5jOiAoaXRlbTogVCwgaW5kZXg/OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlKGkgIT09IHRoaXMudGFpbCl7XG4gICAgICAgICAgICBmdW5jKHRoaXMucVtpXSwgaSk7XG4gICAgICAgICAgICBpID0gKGkgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBxdWV1ZSBpbnRvIGEgc3RyaW5nIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHF1ZXVlXG4gICAgICovXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoKCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSAwKXtcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIgLT4gXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHZhbCA9IHN0ciArIHJldHZhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFwiVG9wIC0+IFwiICsgcmV0dmFsO1xuICAgIH1cbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi4vSW50ZXJmYWNlcy9Db2xsZWN0aW9uXCI7XG5cbi8qKlxuICogQSBMSUZPIHN0YWNrIHdpdGggaXRlbXMgb2YgdHlwZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YWNrPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgU3RhY2sgKi9cbiAgICBwcml2YXRlIE1BWF9FTEVNRU5UUzogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0YWNrICovXG4gICAgcHJpdmF0ZSBzdGFjazogQXJyYXk8VD47XG4gICAgXG4gICAgLyoqIFRoZSBoZWFkIG9mIHRoZSBzdGFjayAqL1xuXHRwcml2YXRlIGhlYWQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgc3RhY2tcbiAgICAgKiBAcGFyYW0gbWF4RWxlbWVudHMgVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKXtcbiAgICAgICAgdGhpcy5NQVhfRUxFTUVOVFMgPSBtYXhFbGVtZW50cztcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBBcnJheTxUPih0aGlzLk1BWF9FTEVNRU5UUyk7XG4gICAgICAgIHRoaXMuaGVhZCA9IC0xO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgbmV3IGl0ZW0gdG8gYWRkIHRvIHRoZSBzdGFja1xuICAgICAqL1xuICAgIHB1c2goaXRlbTogVCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmhlYWQgKyAxID09PSB0aGlzLk1BWF9FTEVNRU5UUyl7XG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWQgKz0gMTtcbiAgICAgICAgdGhpcy5zdGFja1t0aGlzLmhlYWRdID0gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICovXG4gICAgcG9wKCk6IFQge1xuICAgICAgICBpZih0aGlzLmhlYWQgPT09IC0xKXtcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZW1wdHkgLSBjYW5ub3QgcmVtb3ZlIGVsZW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWQgLT0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5oZWFkICsgMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWxlbWVudCBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAqL1xuICAgIHBlZWsoKTogVCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gLTEpe1xuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCBnZXQgZWxlbWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuaGVhZF07XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHN0YWNrIGlzIGVtcHR5XG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RhY2sgaXMgZW1wdHlcbiAgICAqL1xuICAgIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgPT09IC0xO1xuICAgIH1cblxuICAgIC8vIEBpbXBsZW1lbnRlZFxuICAgIGNsZWFyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiBkZWxldGUgdGhpcy5zdGFja1tpbmRleF0pO1xuICAgICAgICB0aGlzLmhlYWQgPSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgY3VycmVudGx5IGluIHRoZSBzdGFja1xuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHN0YWNrXG4gICAgICovXG4gICAgc2l6ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkICsgMTtcbiAgICB9XG5cbiAgICAvLyBAaW1wbGVtZW50ZWRcbiAgICBmb3JFYWNoKGZ1bmM6IChpdGVtOiBULCBpbmRleD86IG51bWJlcikgPT4gdm9pZCk6IHZvaWR7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUoaSA8PSB0aGlzLmhlYWQpe1xuICAgICAgICAgICAgZnVuYyh0aGlzLnN0YWNrW2ldLCBpKTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgc3RhY2sgaW50byBhIHN0cmluZyBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBzdGFja1xuICAgICAqL1xuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXR2YWwgPSBcIlwiO1xuXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RyID0gaXRlbS50b1N0cmluZygpXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR2YWwgPSBzdHIgKyByZXR2YWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBcIlRvcCAtPiBcIiArIHJldHZhbDtcbiAgICB9XG59IiwiLy8gQGlnbm9yZVBhZ2VcblxuLyoqXG4gKiBBIHBsYWNlaG9sZGVyIGZ1bmN0aW9uIGZvciBObyBPcGVyYXRpb24uIERvZXMgbm90aGluZ1xuICovXG5jb25zdCBOdWxsRnVuYyA9ICgpID0+IHt9O1xuXG5leHBvcnQgZGVmYXVsdCBOdWxsRnVuYzsiLCIvKipcbiAqIEEgbGlua2VkLWxpc3QgZm9yIHRoZSBlZGdlcyBpbiBhIEByZWZlcmVuY2VbR3JhcGhdLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGdlTm9kZSB7XG4gICAgLyoqIFRoZSBub2RlIGluIHRoZSBHcmFwaCB0aGlzIGVkZ2UgY29ubmVjdHMgdG8gKi9cbiAgICB5OiBudW1iZXI7XG4gICAgLyoqIFRoZSB3ZWlnaHQgb2YgdGhpcyBFZGdlTm9kZSAqL1xuXHR3ZWlnaHQ6IG51bWJlcjtcbiAgICAvKiogVGhlIG5leHQgRWRnZU5vZGUgaW4gdGhlIGxpbmtlZC1saXN0ICovXG4gICAgbmV4dDogRWRnZU5vZGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEVkZ2VOb2RlXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0aGlzIGVkZ2UgY29ubmVjdHMgdG9cbiAgICAgKiBAcGFyYW0gd2VpZ2h0IFRoZSB3ZWlnaHQgb2YgdGhpcyBlZGdlXG4gICAgICovXG5cdGNvbnN0cnVjdG9yKGluZGV4OiBudW1iZXIsIHdlaWdodD86IG51bWJlcil7XG5cdFx0dGhpcy55ID0gaW5kZXg7XG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcblx0XHR0aGlzLndlaWdodCA9IHdlaWdodCA/IHdlaWdodCA6IDE7XG5cdH1cbn0iLCJpbXBvcnQgRWRnZU5vZGUgZnJvbSBcIi4vRWRnZU5vZGVcIjtcblxuZXhwb3J0IGNvbnN0IE1BWF9WID0gMTAwMDA7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBncmFwaCBkYXRhIHN0cnVjdHVyZSB1c2luZyBlZGdlIGxpc3RzLiBJbnNwaXJlZCBieSBUaGUgQWxnb3JpdGhtIERlc2lnbiBNYW51YWwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIHtcblx0LyoqIEFuIGFycmF5IG9mIGVkZ2VzIGF0IHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cblx0ZWRnZXM6IEFycmF5PEVkZ2VOb2RlPjtcblx0LyoqIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgZGVncmVlIG9mIHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cblx0ZGVncmVlOiBBcnJheTxudW1iZXI+O1xuXHQvKiogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZ3JhcGggKi9cblx0bnVtVmVydGljZXM6IG51bWJlcjtcblx0LyoqIFRoZSBudW1iZXIgb2YgZWRnZXMgaW4gdGhlIGdyYXBoICovXG5cdG51bUVkZ2VzOiBudW1iZXI7XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgZGlyZWN0ZWQgKi9cblx0ZGlyZWN0ZWQ6IGJvb2xlYW47XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgd2VpZ2h0ZWQgKi9cblx0d2VpZ2h0ZWQ6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGhcblx0ICogQHBhcmFtIGRpcmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoaXMgZ3JhcGggaXMgZGlyZWN0ZWRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGVkOiBib29sZWFuID0gZmFsc2Upe1xuXHRcdHRoaXMuZGlyZWN0ZWQgPSBkaXJlY3RlZDtcblx0XHR0aGlzLndlaWdodGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLm51bVZlcnRpY2VzID0gMDtcblx0XHR0aGlzLm51bUVkZ2VzID0gMDtcblxuXHRcdHRoaXMuZWRnZXMgPSBuZXcgQXJyYXkoTUFYX1YpO1xuXHRcdHRoaXMuZGVncmVlID0gbmV3IEFycmF5KE1BWF9WKTtcblx0fVxuXG5cdC8qKiBBZGRzIGEgbm9kZSB0byB0aGlzIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiBpdFxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIG5ldyBub2RlXG5cdCovXG5cdGFkZE5vZGUoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5udW1WZXJ0aWNlcysrO1xuXHR9XG5cblx0LyoqIEFkZHMgYW4gZWRnZSBiZXR3ZWVuIG5vZGUgeCBhbmQgeSwgd2l0aCBhbiBvcHRpb25hbCB3ZWlnaHRcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBzdGFydCBvZiB0aGUgZWRnZVxuXHQgKiBAcGFyYW0geSBUaGUgaW5kZXggb2YgdGhlIGVuZCBvZiB0aGUgZWRnZVxuXHQgKiBAcGFyYW0gd2VpZ2h0IFRoZSBvcHRpb25hbCB3ZWlnaHQgb2YgdGhlIG5ldyBlZGdlXG5cdCovXG5cdGFkZEVkZ2UoeDogbnVtYmVyLCB5OiBudW1iZXIsIHdlaWdodD86IG51bWJlcik6IHZvaWQge1xuXHRcdGxldCBlZGdlID0gbmV3IEVkZ2VOb2RlKHksIHdlaWdodCk7XG5cblxuXG5cdFx0aWYodGhpcy5lZGdlc1t4XSl7XG5cdFx0XHRlZGdlLm5leHQgPSB0aGlzLmVkZ2VzW3hdO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLmVkZ2VzW3hdID0gZWRnZTtcblxuXHRcdGlmKCF0aGlzLmRpcmVjdGVkKXtcblx0XHRcdGVkZ2UgPSBuZXcgRWRnZU5vZGUoeCwgd2VpZ2h0KTtcblxuXHRcdFx0aWYodGhpcy5lZGdlc1t5XSl7XG5cdFx0XHRcdGVkZ2UubmV4dCA9IHRoaXMuZWRnZXNbeV07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuZWRnZXNbeV0gPSBlZGdlO1xuXHRcdH1cblxuXHRcdHRoaXMubnVtRWRnZXMgKz0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYW4gZWRnZSBleGlzdHMgYmV0d2VlbiB0d28gbm9kZXMuXG5cdCAqIFRoaXMgY2hlY2sgaXMgZGlyZWN0aW9uYWwgaWYgdGhpcyBpcyBhIGRpcmVjdGVkIGdyYXBoLlxuXHQgKiBAcGFyYW0geCBUaGUgZmlyc3Qgbm9kZVxuXHQgKiBAcGFyYW0geSBUaGUgc2Vjb25kIG5vZGVcblx0ICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlZGdlIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRlZGdlRXhpc3RzKHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbiB7XG5cdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW3hdO1xuXG5cdFx0d2hpbGUoZWRnZSAhPT0gbnVsbCl7XG5cdFx0XHRpZihlZGdlLnkgPT09IHkpe1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGVkZ2UgbGlzdCBhc3NvY2lhdGVkIHdpdGggbm9kZSB4XG5cdCAqIEBwYXJhbSB4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxuXHQgKiBAcmV0dXJucyBUaGUgaGVhZCBvZiBhIGxpbmtlZC1saXN0IG9mIGVkZ2VzXG5cdCAqL1xuXHRnZXRFZGdlcyh4OiBudW1iZXIpOiBFZGdlTm9kZSB7XG5cdFx0cmV0dXJuIHRoaXMuZWRnZXNbeF07XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZGVncmVlIGFzc29jaWF0ZWQgd2l0aCBub2RlIHhcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXG5cdCAqL1xuXHRnZXREZWdyZWUoeDogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5kZWdyZWVbeF07XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIHNwZWNpZmVkIG5vZGUgaW50byBhIHN0cmluZ1xuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmdcblx0ICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZTogXCJOb2RlIHhcIlxuXHQgKi9cblx0cHJvdGVjdGVkIG5vZGVUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCJOb2RlIFwiICsgaW5kZXg7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIEdyYXBoIGludG8gYSBzdHJpbmcgZm9ybWF0XG5cdCAqIEByZXR1cm5zIFRoZSBncmFwaCBhcyBhIHN0cmluZ1xuXHQgKi9cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRsZXQgcmV0dmFsID0gXCJcIjtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm51bVZlcnRpY2VzOyBpKyspe1xuXHRcdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXHRcdFx0bGV0IGVkZ2VTdHIgPSBcIlwiO1xuXHRcdFx0d2hpbGUoZWRnZSAhPT0gdW5kZWZpbmVkICYmIGVkZ2UgIT09IG51bGwpe1xuXHRcdFx0XHRlZGdlU3RyICs9IGVkZ2UueS50b1N0cmluZygpO1xuXHRcdFx0XHRpZih0aGlzLndlaWdodGVkKXtcblx0XHRcdFx0XHRlZGdlU3RyICs9IFwiIChcIiArIGVkZ2Uud2VpZ2h0ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoZWRnZS5uZXh0ICE9PSBudWxsKXtcblx0XHRcdFx0XHRlZGdlU3RyICs9IFwiLCBcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHZhbCArPSB0aGlzLm5vZGVUb1N0cmluZyhpKSArIFwiOiBcIiArIGVkZ2VTdHIgKyBcIlxcblwiO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR2YWw7XG5cdH1cbn0iLCJpbXBvcnQgR3JhcGgsIHsgTUFYX1YgfSBmcm9tIFwiLi9HcmFwaFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBEZWJ1Z1JlbmRlcmFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvRGVidWdSZW5kZXJhYmxlXCI7XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIG9mIEdyYXBoIHRoYXQgaGFzIG5vZGVzIHdpdGggcG9zaXRpb25zIGluIDJEIHNwYWNlLlxuICogVGhpcyBpcyBhIHdlaWdodGVkIGdyYXBoICh0aG91Z2ggbm90IGluaGVyZW50bHkgZGlyZWN0ZClcbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbkdyYXBoIGV4dGVuZHMgR3JhcGggaW1wbGVtZW50cyBEZWJ1Z1JlbmRlcmFibGUge1xuXHQvKiogQW4gYXJyYXkgb2YgdGhlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgaW4gdGhpcyBncmFwaCAqL1xuXHRwb3NpdGlvbnM6IEFycmF5PFZlYzI+O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVlcyBhIG5ldyBQb3NpdGlvbkdyYXBoXG5cdCAqIEBwYXJhbSBkaXJlY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIGdyYXBoIGlzIGRpcmVjdGVkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihkaXJlY3RlZDogYm9vbGVhbiA9IGZhbHNlKXtcblx0XHRzdXBlcihkaXJlY3RlZCk7XG5cdFx0dGhpcy5wb3NpdGlvbnMgPSBuZXcgQXJyYXkoTUFYX1YpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBwb3NpdGlvbmVkIG5vZGUgdG8gdGhpcyBncmFwaFxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIHRvIGFkZFxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGFkZGVkIG5vZGVcblx0ICovXG5cdGFkZFBvc2l0aW9uZWROb2RlKHBvc2l0aW9uOiBWZWMyKTogbnVtYmVyIHtcblx0XHR0aGlzLnBvc2l0aW9uc1t0aGlzLm51bVZlcnRpY2VzXSA9IHBvc2l0aW9uO1xuXHRcdHJldHVybiB0aGlzLmFkZE5vZGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiBhIG5vZGUuXG5cdCAqIEF1dG9tYXRpY2FsbHkgYWRqdXN0cyB0aGUgd2VpZ2h0cyBvZiB0aGUgZ3JhcGggdGllZCB0byB0aGlzIG5vZGUuXG5cdCAqIEFzIHN1Y2gsIGJlIHdhcm5lZCB0aGF0IHRoaXMgZnVuY3Rpb24gaGFzIGFuIE8obiArIG0pIHJ1bm5pbmcgdGltZSwgYW5kIHVzZSBpdCBzcGFyaW5nbHkuXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcblx0ICogQHBhcmFtIHBvc2l0aW9uIFRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIG5vZGVcblx0ICovXG5cdHNldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyLCBwb3NpdGlvbjogVmVjMik6IHZvaWQge1xuXHRcdHRoaXMucG9zaXRpb25zW2luZGV4XSA9IHBvc2l0aW9uO1xuXG5cdFx0Ly8gUmVjYWxjdWxhdGUgYWxsIHdlaWdodHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5kZXhcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1FZGdlczsgaSsrKXtcblxuXHRcdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXG5cdFx0XHR3aGlsZShlZGdlICE9PSBudWxsKXtcblx0XHRcdFx0Ly8gSWYgdGhpcyBub2RlIGlzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBlZGdlLCByZWNhbGN1bGF0ZSB3ZWlnaHRcblx0XHRcdFx0aWYoaSA9PT0gaW5kZXggfHwgZWRnZS55ID09PSBpbmRleCl7XG5cdFx0XHRcdFx0ZWRnZS53ZWlnaHQgPSB0aGlzLnBvc2l0aW9uc1tpXS5kaXN0YW5jZVRvKHRoaXMucG9zaXRpb25zW2VkZ2UueV0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgYSBub2RlXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcblx0ICogQHJldHVybnMgVGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlXG5cdCAqL1xuXHRnZXROb2RlUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLnBvc2l0aW9uc1tpbmRleF07XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBlZGdlIHRvIHRoaXMgZ3JhcGggYmV0d2VlbiBub2RlIHggYW5kIHkuXG5cdCAqIEF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlcyB0aGUgd2VpZ2h0IG9mIHRoZSBlZGdlIGFzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBub2Rlcy5cblx0ICogQHBhcmFtIHggVGhlIGJlZ2lubmluZyBvZiB0aGUgZWRnZVxuXHQgKiBAcGFyYW0geSBUaGUgZW5kIG9mIHRoZSBlZGdlXG5cdCAqL1xuXHRhZGRFZGdlKHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZCB7XG5cdFx0aWYoIXRoaXMucG9zaXRpb25zW3hdIHx8ICF0aGlzLnBvc2l0aW9uc1t5XSl7XG5cdFx0XHR0aHJvdyBcIkNhbid0IGFkZCBlZGdlIHRvIHVuLXBvc2l0aW9uZWQgbm9kZSFcIjtcblx0XHR9XG5cblx0XHQvLyBXZWlnaHQgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vZGVzXG5cdFx0bGV0IHdlaWdodCA9IHRoaXMucG9zaXRpb25zW3hdLmRpc3RhbmNlVG8odGhpcy5wb3NpdGlvbnNbeV0pO1xuXG5cdFx0c3VwZXIuYWRkRWRnZSh4LCB5LCB3ZWlnaHQpO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdHByb3RlY3RlZCBub2RlVG9TdHJpbmcoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG5cdFx0cmV0dXJuIFwiTm9kZSBcIiArIGluZGV4ICsgXCIgLSBcIiArIHRoaXMucG9zaXRpb25zW2luZGV4XS50b1N0cmluZygpO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbm9kZSBpbiB0aGUgZ3JhcGggd2l0aCB0aGUgcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMgdGhlIG5vZGUgaW4gdGhlIGdyYXBoIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgc25hcChwb3NpdGlvbjogVmVjMik6IG51bWJlciB7XG4gICAgICAgIGxldCBuID0gdGhpcy5udW1WZXJ0aWNlcztcblx0XHRsZXQgaSA9IDE7XG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRsZXQgZGlzdCA9IHBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLnBvc2l0aW9uc1swXSk7XG5cdFx0d2hpbGUoaSA8IG4pe1xuXHRcdFx0bGV0IGQgPSBwb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5wb3NpdGlvbnNbaV0pO1xuXHRcdFx0aWYoZCA8IGRpc3Qpe1xuXHRcdFx0XHRkaXN0ID0gZDtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcbiAgICB9XG5cblx0ZGVidWdSZW5kZXIgPSAoKTogdm9pZCA9PiB7XG5cdFx0Ly8gZm9yKGxldCBwb2ludCBvZiB0aGlzLnBvc2l0aW9ucyl7XG5cdFx0Ly8gXHRjdHguZmlsbFJlY3QoKHBvaW50LnggLSBvcmlnaW4ueCAtIDQpKnpvb20sIChwb2ludC55IC0gb3JpZ2luLnkgLSA0KSp6b29tLCA4LCA4KTtcblx0XHQvLyB9XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL1NoYXBlcy9BQUJCXCI7XG5cbi8qKiBBbiBvYmplY3QgdGhhdCBpcyBhIHJlZ2lvbiwgd2l0aCBhIHNpemUsIHNjYWxlLCBhbmQgYm91bmRhcnkuICovXG5leHBvcnQgZGVmYXVsdCBpbnRlcmZhY2UgUmVnaW9uIHtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhpcyBvYmplY3QuICovXG4gICAgc2l6ZTogVmVjMjtcblxuICAgIC8qKiBUaGUgc2NhbGUgb2YgdGhpcyBvYmplY3QuICovXG4gICAgc2NhbGU6IFZlYzI7XG5cbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG9iamVjdCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB6b29tIGFuZCBzY2FsZSAqL1xuICAgIHJlYWRvbmx5IHNpemVXaXRoWm9vbTogVmVjMjtcblxuICAgIC8qKiBUaGUgYm91bmRpbmcgYm94IG9mIHRoaXMgb2JqZWN0LiAqL1xuICAgIGJvdW5kYXJ5OiBBQUJCO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWdpb24oYXJnOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gYXJnICYmIGFyZy5zaXplICYmIGFyZy5zY2FsZSAmJiBhcmcuYm91bmRhcnk7XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4vVmVjMlwiO1xuXG4vKiogQSA0eDQgbWF0cml4MCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0NHg0IHtcblx0cHJpdmF0ZSBtYXQ6IEZsb2F0MzJBcnJheTtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMubWF0ID0gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwXG5cdFx0XSk7XG5cdH1cblxuXHQvLyBTdGF0aWMgbWVtYmVyc1xuXHRzdGF0aWMgZ2V0IElERU5USVRZKCk6IE1hdDR4NCB7XG5cdFx0cmV0dXJuIG5ldyBNYXQ0eDQoKS5pZGVudGl0eSgpO1xuXHR9XG5cblx0c3RhdGljIGdldCBaRVJPKCk6IE1hdDR4NCB7XG5cdFx0cmV0dXJuIG5ldyBNYXQ0eDQoKS56ZXJvKCk7XG5cdH1cblxuXHQvLyBBY2Nlc3NvcnNcblx0c2V0IF8wMCh4OiBudW1iZXIpIHtcblx0XHR0aGlzLm1hdFswXSA9IHg7XG5cdH1cblxuXHRzZXQoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogTWF0NHg0IHtcblx0XHRpZihjb2wgPCAwIHx8IGNvbCA+IDMgfHwgcm93IDwgMCB8fCByb3cgPiAzKXtcblx0XHRcdHRocm93IGBFcnJvciAtIGluZGV4ICgke2NvbH0sICR7cm93fSkgaXMgb3V0IG9mIGJvdW5kcyBmb3IgTWF0NHg0YFxuXHRcdH1cblx0XHR0aGlzLm1hdFtyb3cqNCArIGNvbF0gPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Z2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlcik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMubWF0W3Jvdyo0ICsgY29sXTtcblx0fVxuXG5cdHNldEFsbCguLi5pdGVtczogQXJyYXk8bnVtYmVyPik6IE1hdDR4NCB7XG5cdFx0dGhpcy5tYXQuc2V0KGl0ZW1zKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGlkZW50aXR5KCk6IE1hdDR4NCB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdClcblx0fVxuXG5cdHplcm8oKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlcyB0aGlzIE1hdDR4NCBhIHJvdGF0aW9uIG1hdHJpeCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiByYWRpYW5zIGNjd1xuXHQgKiBAcGFyYW0gelJhZGlhbnMgVGhlIG51bWJlciBvZiByYWRpYW5zIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJucyB0aGlzIE1hdDR4NFxuXHQgKi9cblx0cm90YXRlKHpSYWRpYW5zOiBudW1iZXIpOiBNYXQ0eDQge1xuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdE1hdGguY29zKHpSYWRpYW5zKSwgLU1hdGguc2luKHpSYWRpYW5zKSwgXHQwLCAwLFxuXHRcdFx0TWF0aC5zaW4oelJhZGlhbnMpLCBNYXRoLmNvcyh6UmFkaWFucyksIFx0MCwgMCxcblx0XHRcdDAsIFx0XHRcdFx0XHQwLCBcdFx0XHRcdFx0XHQxLCAwLFxuXHRcdFx0MCwgXHRcdFx0XHRcdDAsIFx0XHRcdFx0XHRcdDAsIDFcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFR1cm5zIHRoaXMgTWF0NHg0IGludG8gYSB0cmFuc2xhdGlvbiBtYXRyaXggb2YgdGhlIHNwZWNpZmllZCB0cmFuc2xhdGlvblxuXHQgKiBAcGFyYW0gdHJhbnNsYXRpb24gVGhlIHRyYW5zbGF0aW9uIGluIHggYW5kIHlcblx0ICogQHJldHVybnMgdGhpcyBNYXQ0eDRcblx0ICovXG5cdHRyYW5zbGF0ZSh0cmFuc2xhdGlvbjogVmVjMiB8IEZsb2F0MzJBcnJheSk6IE1hdDR4NCB7XG5cdFx0Ly8gSWYgdHJhbnNsYXRpb24gaXMgYSB2ZWMsIGdldCBpdHMgYXJyYXlcblx0XHRpZih0cmFuc2xhdGlvbiBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0dHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbi50b0FycmF5KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxuXHRcdFx0MSwgMCwgMCwgdHJhbnNsYXRpb25bMF0sXG5cdFx0XHQwLCAxLCAwLCB0cmFuc2xhdGlvblsxXSxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cdFx0KTtcblx0fVxuXG5cdHNjYWxlKHNjYWxlOiBWZWMyIHwgRmxvYXQzMkFycmF5IHwgbnVtYmVyKTogTWF0NHg0IHtcblx0XHQvLyBNYWtlIHN1cmUgc2NhbGUgaXMgYSBmbG9hdDMyQXJyYXlcblx0XHRpZihzY2FsZSBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0c2NhbGUgPSBzY2FsZS50b0FycmF5KCk7XG5cdFx0fSBlbHNlIGlmKCEoc2NhbGUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKXtcblx0XHRcdHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbc2NhbGUsIHNjYWxlXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxuXHRcdFx0c2NhbGVbMF0sIDAsIFx0XHQwLCAwLFxuXHRcdFx0MCwgXHRcdCAgc2NhbGVbMV0sIDAsIDAsXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQxLCAwLFxuXHRcdFx0MCwgXHRcdCAgMCxcdFx0MCwgMVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBNYXQ0eDQgdGhhdCByZXByZXNlbnRzIHRoZSByaWdodCBzaWRlIG11bHRpcGxpY2F0aW9uIFRISVMgeCBPVEhFUlxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIE1hdDR4NCB0byBtdWx0aXBseSBieVxuXHQgKiBAcmV0dXJucyBhIG5ldyBNYXQ0eDQgY29udGFpbmluZyB0aGUgcHJvZHVjdCBvZiB0aGVzZSB0d28gTWF0NHg0c1xuXHQgKi9cblx0bXVsdChvdGhlcjogTWF0NHg0LCBvdXQ/OiBNYXQ0eDQpOiBNYXQ0eDQge1xuXHRcdGxldCB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgNDsgaSsrKXtcblx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCA0OyBqKyspe1xuXHRcdFx0XHRsZXQgdmFsdWUgPSAwO1xuXHRcdFx0XHRmb3IobGV0IGsgPSAwOyBrIDwgNDsgaysrKXtcblx0XHRcdFx0XHR2YWx1ZSArPSB0aGlzLmdldChrLCBpKSAqIG90aGVyLmdldChqLCBrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZW1wW2oqNCArIGldICA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKG91dCAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdHJldHVybiBvdXQuc2V0QWxsKC4uLnRlbXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLnNldEFsbCguLi50ZW1wKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGllcyBhbGwgZ2l2ZW4gbWF0cmljaWVzIGluIG9yZGVyLiBlLmcuIE1VTFQoQSwgQiwgQykgLT4gQSpCKkNcblx0ICogQHBhcmFtIG1hdHMgQSBsaXN0IG9mIE1hdDR4NHMgdG8gbXVsdGlwbHkgaW4gb3JkZXJcblx0ICogQHJldHVybnMgQSBuZXcgTWF0NHg0IGhvbGRpbmcgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG5cdCAqL1xuXHRzdGF0aWMgTVVMVCguLi5tYXRzOiBBcnJheTxNYXQ0eDQ+KTogTWF0NHg0IHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgYXJyYXlcblx0XHRsZXQgdGVtcCA9IE1hdDR4NC5JREVOVElUWTtcblxuXHRcdC8vIE11bHRpcGx5IGJ5IGV2ZXJ5IGFycmF5IGluIG9yZGVyLCBpbiBwbGFjZVxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCBtYXRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdHRlbXAubXVsdChtYXRzW2ldLCB0ZW1wKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGVtcDtcblx0fVxuXG5cdHRvQXJyYXkoKTogRmxvYXQzMkFycmF5IHtcblx0XHRyZXR1cm4gdGhpcy5tYXQ7XG5cdH1cblxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdHJldHVybiAgYHwke3RoaXMubWF0WzBdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzFdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzJdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzNdLnRvRml4ZWQoMil9fFxcbmAgKyBcblx0XHRcdFx0YHwke3RoaXMubWF0WzRdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzVdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzZdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzddLnRvRml4ZWQoMil9fFxcbmAgK1xuXHRcdFx0XHRgfCR7dGhpcy5tYXRbOF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbOV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTBdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzExXS50b0ZpeGVkKDIpfXxcXG5gICtcblx0XHRcdFx0YHwke3RoaXMubWF0WzEyXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxM10udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTRdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzE1XS50b0ZpeGVkKDIpfXxgO1xuXHR9XG59IiwiaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgSGl0IGZyb20gXCIuL0hpdFwiO1xuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyB0aGUgYXJlYSBvZiBvdmVybGFwIG9mIHR3byBjb2xsaWRpbmcgb2JqZWN0cyB0byBhbGxvdyBmb3Igc29ydGluZyBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyZWFDb2xsaXNpb24ge1xuICAgIC8qKiBUaGUgYXJlYSBvZiB0aGUgb3ZlcmxhcCBmb3IgdGhlIGNvbGxpZGluZyBvYmplY3RzICovXG4gICAgYXJlYTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBBQUJCIG9mIHRoZSBvdGhlciBjb2xsaWRlciBpbiB0aGlzIGNvbGxpc2lvbiAqL1xuICAgIGNvbGxpZGVyOiBBQUJCO1xuXG4gICAgLyoqIFR5cGUgb2YgdGhlIGNvbGxpc2lvbiAqL1xuICAgIHR5cGU6IHN0cmluZztcblxuICAgIC8qKiBUaGVyIG90aGVyIG9iamVjdCBpbiB0aGUgY29sbGlzaW9uICovXG4gICAgb3RoZXI6IFBoeXNpY2FsO1xuXG4gICAgLyoqIFRoZSB0aWxlLCBpZiB0aGlzIHdhcyBhIHRpbGVtYXAgY29sbGlzaW9uICovXG4gICAgdGlsZTogVmVjMjtcblxuICAgIC8qKiBUaGUgcGh5c2ljcyBoaXQgZm9yIHRoaXMgb2JqZWN0ICovXG4gICAgaGl0OiBIaXQ7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFyZWFDb2xsaXNpb24gb2JqZWN0XG4gICAgICogQHBhcmFtIGFyZWEgVGhlIGFyZWEgb2YgdGhlIGNvbGxpc2lvblxuICAgICAqIEBwYXJhbSBjb2xsaWRlciBUaGUgb3RoZXIgY29sbGlkZXJcbiAgICAgKi9cblx0Y29uc3RydWN0b3IoYXJlYTogbnVtYmVyLCBjb2xsaWRlcjogQUFCQiwgb3RoZXI6IFBoeXNpY2FsLCB0eXBlOiBzdHJpbmcsIHRpbGU6IFZlYzIpe1xuXHRcdHRoaXMuYXJlYSA9IGFyZWE7XG4gICAgICAgIHRoaXMuY29sbGlkZXIgPSBjb2xsaWRlcjtcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnRpbGUgPSB0aWxlO1xuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcblxuLyoqXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRhIGNvbGxlY3RlZCBmcm9tIGEgcGh5c2ljcyBoaXQgYmV0d2VlbiB0d28gZ2VvbWV0cmljIG9iamVjdHMuXG4gKiBJbnNwaXJlZCBieSB0aGUgaGVscGZ1bCBjb2xsaXNpb24gZG9jdW1lbnRhdGlvbiBAbGluayhoZXJlKShodHRwczovL25vb25hdC5naXRodWIuaW8vaW50ZXJzZWN0LykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpdCB7XG4gICAgLyoqIFRoZSB0aW1lIG9mIHRoZSBjb2xsaXNpb24uIE9ubHkgbnVtYmVycyAwIHRocm91Z2ggMSBoYXBwZW4gaW4gdGhpcyBmcmFtZS4gKi9cbiAgICB0aW1lOiBudW1iZXI7XG4gICAgLyoqIFRoZSBuZWFyIHRpbWVzIG9mIHRoZSBjb2xsaXNpb24gKi9cbiAgICBuZWFyVGltZXM6IFZlYzIgPSBWZWMyLlpFUk87XG4gICAgLyoqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29sbGlzaW9uICovXG4gICAgcG9zOiBWZWMyID0gVmVjMi5aRVJPO1xuICAgIC8qKiBUaGUgb3ZlcmxhcCBkaXN0YW5jZSBvZiB0aGUgaGl0ICovXG4gICAgZGVsdGE6IFZlYzIgPSBWZWMyLlpFUk87XG4gICAgLyoqIFRoZSBub3JtYWwgdmVjdG9yIG9mIHRoZSBoaXQgKi9cbiAgICBub3JtYWw6IFZlYzIgPSBWZWMyLlpFUk87XG59IiwiLyoqIEEgY29udGFpbmVyIGZvciBpbmZvIGFib3V0IGEgd2ViR0wgc2hhZGVyIHByb2dyYW0gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUHJvZ3JhbVR5cGUge1xuXHQvKiogQSB3ZWJHTCBwcm9ncmFtICovXG5cdHByb2dyYW06IFdlYkdMUHJvZ3JhbTtcblx0XG5cdC8qKiBBIHZlcnRleCBzaGFkZXIgKi9cblx0dmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcjtcblxuXHQvKiogQSBmcmFnbWVudCBzaGFkZXIgKi9cblx0ZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyO1xuXG5cdC8qKlxuXHQgKiBEZWxldGVzIHRoaXMgc2hhZGVyIHByb2dyYW1cblx0ICovXG5cdGRlbGV0ZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XG5cdFx0Ly8gQ2xlYW4gdXAgYWxsIGFzcGVjdHMgb2YgdGhpcyBwcm9ncmFtXG5cdFx0aWYodGhpcy5wcm9ncmFtKXtcblx0XHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcblx0XHR9XG5cdFx0XHRcblx0XHRpZih0aGlzLnZlcnRleFNoYWRlcil7XG5cdFx0XHRnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0ZXhTaGFkZXIpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuZnJhZ21lbnRTaGFkZXIpe1xuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBTaGFwZSBmcm9tIFwiLi9TaGFwZVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcbmltcG9ydCBIaXQgZnJvbSBcIi4uL1BoeXNpY3MvSGl0XCI7XG5cbi8qKlxuICogQW4gQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveC4gSW4gb3RoZXIgd29yZHMsIGEgcmVjdGFuZ2xlIHRoYXQgaXMgYWx3YXlzIGFsaWduZWQgdG8gdGhlIHgteSBncmlkLlxuICogSW5zcGlyZWQgYnkgdGhlIGhlbHBmdWwgY29sbGlzaW9uIGRvY3VtZW50YXRpb24gQGxpbmsoaGVyZSkoaHR0cHM6Ly9ub29uYXQuZ2l0aHViLmlvL2ludGVyc2VjdC8pLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBQUJCIGV4dGVuZHMgU2hhcGUge1xuICAgIGNlbnRlcjogVmVjMjtcbiAgICBoYWxmU2l6ZTogVmVjMjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQUFCQlxuICAgICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgQUFCQlxuICAgICAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgaGFsZiBzaXplIG9mIHRoZSBBQUJCIC0gVGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byBhbiBlZGdlIGluIHggYW5kIHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjZW50ZXI/OiBWZWMyLCBoYWxmU2l6ZT86IFZlYzIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemUgPyBoYWxmU2l6ZSA6IG5ldyBWZWMyKDAsIDApO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cbiAgICBnZXQgdG9wTGVmdCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubGVmdCwgdGhpcy50b3ApXG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cbiAgICBnZXQgdG9wUmlnaHQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnJpZ2h0LCB0aGlzLnRvcClcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhIHBvaW50IHJlcHJlc2VudGluZyB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBBQUJCICovXG4gICAgZ2V0IGJvdHRvbUxlZnQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXG4gICAgZ2V0IGJvdHRvbVJpZ2h0KCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pXG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCk6IEFBQkIge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZSB7XG4gICAgICAgIGxldCByID0gTWF0aC5tYXgodGhpcy5odywgdGhpcy5oaClcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGUodGhpcy5jZW50ZXIuY2xvbmUoKSwgcik7XG4gICAgfVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemU7XG4gICAgfVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICBzZXRIYWxmU2l6ZShoYWxmU2l6ZTogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemU7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIG1vdmUgdGhlc2UgYWxsIHRvIHRoZSBTaGFwZSBjbGFzc1xuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwb2ludC54ID49IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XG4gICAgICAgICAgICAmJiBwb2ludC55ID49IHRoaXMueSAtIHRoaXMuaGggJiYgcG9pbnQueSA8PSB0aGlzLnkgKyB0aGlzLmhoXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgZHggPSBwb2ludC54IC0gdGhpcy54O1xuICAgICAgICBsZXQgcHggPSB0aGlzLmh3IC0gTWF0aC5hYnMoZHgpO1xuICAgICAgICBcbiAgICAgICAgaWYocHggPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZHkgPSBwb2ludC55IC0gdGhpcy55O1xuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoIC0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIGlmKHB5IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnQgd2l0aCBzb2Z0IGxlZnQgYW5kIHRvcCBib3VuZGFyaWVzLlxuICAgICAqIEluIG90aGVyIHdvcmRzLCBpZiB0aGUgdG9wIGxlZnQgaXMgKDAsIDApLCB0aGUgcG9pbnQgKDAsIDApIGlzIG5vdCBpbiB0aGUgQUFCQlxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50U29mdChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA+IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XG4gICAgICAgICAgICAmJiBwb2ludC55ID4gdGhpcy55IC0gdGhpcy5oaCAmJiBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgZnJvbSB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgQUFCQiB3aXRoIGEgbGluZSBzZWdtZW50IGZyb20gYSBwb2ludCBpbiBhIGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdGhhdCB0aGUgbGluZSBzZWdtZW50IHN0YXJ0cyBmcm9tXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIG9mIHRoZSBzZWdtZW50XG4gICAgICogQHBhcmFtIHBhZGRpbmcgUGFkcyB0aGUgQUFCQiB0byBtYWtlIGl0IHdpZGVyIGZvciB0aGUgaW50ZXJzZWN0aW9uIHRlc3RcbiAgICAgKiBAcmV0dXJucyBUaGUgSGl0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbiwgb3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uXG4gICAgICovXG4gICAgaW50ZXJzZWN0U2VnbWVudChwb2ludDogVmVjMiwgZGVsdGE6IFZlYzIsIHBhZGRpbmc/OiBWZWMyKTogSGl0IHtcbiAgICAgICAgbGV0IHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmcueCA6IDA7XG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nLnkgOiAwO1xuXG4gICAgICAgIGxldCBzY2FsZVggPSAxL2RlbHRhLng7XG4gICAgICAgIGxldCBzY2FsZVkgPSAxL2RlbHRhLnk7XG5cbiAgICAgICAgbGV0IHNpZ25YID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVYKTtcbiAgICAgICAgbGV0IHNpZ25ZID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVZKTtcblxuICAgICAgICBsZXQgdG5lYXJ4ID0gc2NhbGVYKih0aGlzLnggLSBzaWduWCoodGhpcy5odyArIHBhZGRpbmdYKSAtIHBvaW50LngpO1xuICAgICAgICBsZXQgdG5lYXJ5ID0gc2NhbGVZKih0aGlzLnkgLSBzaWduWSoodGhpcy5oaCArIHBhZGRpbmdZKSAtIHBvaW50LnkpO1xuICAgICAgICBsZXQgdGZhcnggPSBzY2FsZVgqKHRoaXMueCArIHNpZ25YKih0aGlzLmh3ICsgcGFkZGluZ1gpIC0gcG9pbnQueCk7XG4gICAgICAgIGxldCB0ZmFyeSA9IHNjYWxlWSoodGhpcy55ICsgc2lnblkqKHRoaXMuaGggKyBwYWRkaW5nWSkgLSBwb2ludC55KTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRuZWFyeCA+IHRmYXJ5IHx8IHRuZWFyeSA+IHRmYXJ4KXtcbiAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBjb2xsaWRpbmcgLSB3ZSBjbGVhciBvbmUgYXhpcyBiZWZvcmUgaW50ZXJzZWN0aW5nIGFub3RoZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRuZWFyID0gTWF0aC5tYXgodG5lYXJ4LCB0bmVhcnkpO1xuXG4gICAgICAgIC8vIERvdWJsZSBjaGVjayBmb3IgTmFOc1xuICAgICAgICBpZih0bmVhcnggIT09IHRuZWFyeCl7XG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeTtcbiAgICAgICAgfSBlbHNlIGlmICh0bmVhcnkgIT09IHRuZWFyeSl7XG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0ZmFyID0gTWF0aC5taW4odGZhcngsIHRmYXJ5KTtcblxuICAgICAgICBpZih0bmVhciA9PT0gLUluZmluaXR5KXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodG5lYXIgPj0gMSB8fCB0ZmFyIDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBhcmUgY29sbGlkaW5nXG4gICAgICAgIGxldCBoaXQgPSBuZXcgSGl0KCk7XG4gICAgICAgIGhpdC50aW1lID0gTWF0aFV0aWxzLmNsYW1wMDEodG5lYXIpO1xuICAgICAgICBoaXQubmVhclRpbWVzLnggPSB0bmVhcng7XG4gICAgICAgIGhpdC5uZWFyVGltZXMueSA9IHRuZWFyeTtcblxuICAgICAgICBpZih0bmVhcnggPiB0bmVhcnkpe1xuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpemVcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZihNYXRoLmFicyh0bmVhcnggLSB0bmVhcnkpIDwgMC4wMDAxKXtcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgY29ybmVyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAtc2lnblg7XG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XG4gICAgICAgICAgICBoaXQubm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSB0b3Agb3IgYm90dG9tXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAwO1xuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gLXNpZ25ZO1xuICAgICAgICB9XG5cbiAgICAgICAgaGl0LmRlbHRhLnggPSAoMS4wIC0gaGl0LnRpbWUpICogLWRlbHRhLng7XG4gICAgICAgIGhpdC5kZWx0YS55ID0gKDEuMCAtIGhpdC50aW1lKSAqIC1kZWx0YS55O1xuICAgICAgICBoaXQucG9zLnggPSBwb2ludC54ICsgZGVsdGEueCAqIGhpdC50aW1lO1xuICAgICAgICBoaXQucG9zLnkgPSBwb2ludC55ICsgZGVsdGEueSAqIGhpdC50aW1lO1xuXG4gICAgICAgIHJldHVybiBoaXQ7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgb3ZlcmxhcHMob3RoZXI6IFNoYXBlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmKG90aGVyIGluc3RhbmNlb2YgQUFCQil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwc0FBQkIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwiT3ZlcmxhcCBub3QgZGVmaW5lZCBiZXR3ZWVuIHRoZXNlIHNoYXBlcy5cIlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgb3ZlcmxhcHMgYW5vdGhlclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQiB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIEFBQkIgb3ZlcmxhcHMgdGhlIG90aGVyLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcmxhcHNBQUJCKG90aGVyOiBBQUJCKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcbiAgICAgICAgXG4gICAgICAgIGlmKHB4IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIGlmKHB5IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXNlIEFBQkJzIGFyZSBKVVNUIHRvdWNoaW5nIC0gbm90IG92ZXJsYXBwaW5nLlxuICAgICAqIFZlYzIueCBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgdG8gdGhlIGxlZnQsIDEgaWYgdG8gdGhlIHJpZ2h0LlxuICAgICAqIExpa2V3aXNlLCBWZWMyLnkgaXMgLTEgaWYgdGhlIG90aGVyIGlzIG9uIHRvcCwgMSBpZiBvbiBib3R0b20uXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVGhlIGNvbGxpc2lvbiBzaWRlcyBzdG9yZWQgaW4gYSBWZWMyIGlmIHRoZSBBQUJCcyBhcmUgdG91Y2hpbmcsIG51bGwgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgdG91Y2hlc0FBQkIob3RoZXI6IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xuXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcblxuICAgICAgICAvLyBJZiBvbmUgYXhpcyBpcyBqdXN0IHRvdWNoaW5nIGFuZCB0aGUgb3RoZXIgaXMgb3ZlcmxhcHBpbmcsIHRydWVcbiAgICAgICAgaWYoKHB4ID09PSAwICYmIHB5ID49IDApIHx8IChweSA9PT0gMCAmJiBweCA+PSAwKSl7XG4gICAgICAgICAgICBsZXQgcmV0ID0gbmV3IFZlYzIoKTtcblxuICAgICAgICAgICAgaWYocHggPT09IDApe1xuICAgICAgICAgICAgICAgIHJldC54ID0gb3RoZXIueCA8IHRoaXMueCA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocHkgPT09IDApe1xuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXNlIEFBQkJzIGFyZSBKVVNUIHRvdWNoaW5nIC0gbm90IG92ZXJsYXBwaW5nLlxuICAgICAqIEFsc28sIGlmIHRoZXkgYXJlIG9ubHkgdG91Y2hpbmcgY29ybmVycywgdGhleSBhcmUgY29uc2lkZXJlZCBub3QgdG91Y2hpbmcuXG4gICAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXG4gICAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lkZSBvZiB0aGUgdG91Y2gsIHN0b3JlZCBhcyBhIFZlYzIsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gdG91Y2hcbiAgICAgKi9cbiAgICB0b3VjaGVzQUFCQldpdGhvdXRDb3JuZXJzKG90aGVyOiBBQUJCKTogVmVjMiB7XG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcblxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XG5cbiAgICAgICAgLy8gSWYgb25lIGF4aXMgaXMgdG91Y2hpbmcsIGFuZCB0aGUgb3RoZXIgaXMgc3RyaWN0bHkgb3ZlcmxhcHBpbmdcbiAgICAgICAgaWYoKHB4ID09PSAwICYmIHB5ID4gMCkgfHwgKHB5ID09PSAwICYmIHB4ID4gMCkpe1xuICAgICAgICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XG5cbiAgICAgICAgICAgIGlmKHB4ID09PSAwKXtcbiAgICAgICAgICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhpcyBBQUJCIGFuZCBhbm90aGVyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCXG4gICAgICogQHJldHVybnMgVGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgYmV0d2VlbiB0aGUgQUFCQnNcbiAgICAgKi9cbiAgICBvdmVybGFwQXJlYShvdGhlcjogQUFCQik6IG51bWJlciB7XG4gICAgICAgIGxldCBsZWZ0eCA9IE1hdGgubWF4KHRoaXMueCAtIHRoaXMuaHcsIG90aGVyLnggLSBvdGhlci5odyk7XG4gICAgICAgIGxldCByaWdodHggPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLmh3LCBvdGhlci54ICsgb3RoZXIuaHcpO1xuICAgICAgICBsZXQgZHggPSByaWdodHggLSBsZWZ0eDtcblxuICAgICAgICBsZXQgbGVmdHkgPSBNYXRoLm1heCh0aGlzLnkgLSB0aGlzLmhoLCBvdGhlci55IC0gb3RoZXIuaGgpO1xuICAgICAgICBsZXQgcmlnaHR5ID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oaCwgb3RoZXIueSArIG90aGVyLmhoKTtcbiAgICAgICAgbGV0IGR5ID0gcmlnaHR5IC0gbGVmdHk7XG5cbiAgICAgICAgaWYoZHggPCAwIHx8IGR5IDwgMCkgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZHgqZHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW5kIHJlc2l6ZXMgdGhpcyByZWN0IGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24gdG8gdGhlIHBvc2l0aW9uIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgbW92ZW1lbnQgb2YgdGhlIHJlY3QgZnJvbSBpdHMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIEEgcG9zaXRpb24gc3BlY2lmaWVkIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBvZiBzd2VlcGluZ1xuICAgICAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgaGFsZlNpemUgb2YgdGhlIHN3ZWVwaW5nIHJlY3QgXG4gICAgICovXG4gICAgc3dlZXAodmVsb2NpdHk6IFZlYzIsIGZyb21Qb3NpdGlvbj86IFZlYzIsIGhhbGZTaXplPzogVmVjMik6IHZvaWQge1xuICAgICAgICBpZighZnJvbVBvc2l0aW9uKXtcbiAgICAgICAgICAgIGZyb21Qb3NpdGlvbiA9IHRoaXMuY2VudGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWhhbGZTaXplKXtcbiAgICAgICAgICAgIGhhbGZTaXplID0gdGhpcy5oYWxmU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjZW50ZXJYID0gZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54LzI7XG4gICAgICAgIGxldCBjZW50ZXJZID0gZnJvbVBvc2l0aW9uLnkgKyB2ZWxvY2l0eS55LzI7XG5cbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihmcm9tUG9zaXRpb24ueCAtIGhhbGZTaXplLngsIGZyb21Qb3NpdGlvbi54ICsgdmVsb2NpdHkueCAtIGhhbGZTaXplLngpO1xuICAgICAgICBsZXQgbWluWSA9IE1hdGgubWluKGZyb21Qb3NpdGlvbi55IC0gaGFsZlNpemUueSwgZnJvbVBvc2l0aW9uLnkgKyB2ZWxvY2l0eS55IC0gaGFsZlNpemUueSk7XG5cbiAgICAgICAgdGhpcy5jZW50ZXIuc2V0KGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICB0aGlzLmhhbGZTaXplLnNldChjZW50ZXJYIC0gbWluWCwgY2VudGVyWSAtIG1pblkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBjbG9uZSgpOiBBQUJCIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBQUJCKHRoaXMuY2VudGVyLmNsb25lKCksIHRoaXMuaGFsZlNpemUuY2xvbmUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBBQUJCIHRvIGEgc3RyaW5nIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIChjZW50ZXI6ICh4LCB5KSwgaGFsZlNpemU6ICh4LCB5KSlcbiAgICAgKi9cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gXCIoY2VudGVyOiBcIiArIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgKyBcIiwgaGFsZi1zaXplOiBcIiArIHRoaXMuaGFsZlNpemUudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi9BQUJCXCI7XG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcblxuLyoqXG4gKiBBIENpcmNsZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBTaGFwZSB7XG5cdHByaXZhdGUgX2NlbnRlcjogVmVjMjtcblx0cmFkaXVzOiBudW1iZXI7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBDaXJjbGVcblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0ICovXG5cdGNvbnN0cnVjdG9yKGNlbnRlcjogVmVjMiwgcmFkaXVzOiBudW1iZXIpIHtcblx0XHRzdXBlcigpO1xuICAgICAgICB0aGlzLl9jZW50ZXIgPSBjZW50ZXIgPyBjZW50ZXIgOiBuZXcgVmVjMigwLCAwKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgPyByYWRpdXMgOiAwO1xuXHR9XG5cblx0Z2V0IGNlbnRlcigpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5fY2VudGVyO1xuXHR9XG5cblx0c2V0IGNlbnRlcihjZW50ZXI6IFZlYzIpIHtcblx0XHR0aGlzLl9jZW50ZXIgPSBjZW50ZXI7XG5cdH1cblxuXHRnZXQgaGFsZlNpemUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyk7XG5cdH1cblxuXHRnZXQgcigpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnJhZGl1cztcblx0fVxuXG5cdHNldCByKHJhZGl1czogbnVtYmVyKSB7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0LyoqXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLmRpc3RhbmNlU3FUbyhwb2ludCkgPD0gdGhpcy5yYWRpdXMqdGhpcy5yYWRpdXM7XG4gICAgfVxuXG5cdC8vIEBvdmVycmlkZVxuXHRnZXRCb3VuZGluZ1JlY3QoKTogQUFCQiB7XG5cdFx0cmV0dXJuIG5ldyBBQUJCKHRoaXMuX2NlbnRlci5jbG9uZSgpLCBuZXcgVmVjMih0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMpKTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0b3ZlcmxhcHMob3RoZXI6IFNoYXBlKTogYm9vbGVhbiB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0Y2xvbmUoKTogQ2lyY2xlIHtcblx0XHRyZXR1cm4gbmV3IENpcmNsZSh0aGlzLl9jZW50ZXIuY2xvbmUoKSwgdGhpcy5yYWRpdXMpO1xuXHR9XG5cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCIoY2VudGVyOiBcIiArIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgKyBcIiwgcmFkaXVzOiBcIiArIHRoaXMucmFkaXVzICsgXCIpXCI7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBTaGFwZSBjbGFzcyB0aGF0IGFjdHMgYXMgYW4gaW50ZXJmYWNlIGZvciBiZXR0ZXIgaW50ZXJhY3Rpb25zIHdpdGggc3ViY2xhc3Nlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhcGUge1xuICAgIGFic3RyYWN0IGdldCBjZW50ZXIoKTogVmVjMjtcblxuICAgIGFic3RyYWN0IHNldCBjZW50ZXIoY2VudGVyOiBWZWMyKTtcblxuICAgIGFic3RyYWN0IGdldCBoYWxmU2l6ZSgpOiBWZWMyO1xuXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLng7XG4gICAgfVxuXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLnk7XG4gICAgfVxuXG4gICAgZ2V0IGh3KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLng7XG4gICAgfVxuXG4gICAgZ2V0IGhoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLnk7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy55IC0gdGhpcy5oaDtcbiAgICB9XG5cbiAgICBnZXQgYm90dG9tKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhoO1xuICAgIH1cblxuICAgIGdldCBsZWZ0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggLSB0aGlzLmh3O1xuICAgIH1cblxuICAgIGdldCByaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy5odztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgYm91bmRpbmcgcmVjdGFuZ2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXG4gICAgICogRm9yIGluc3RhbmNlLCB0aGUgYm91bmRpbmcgY2lyY2xlIG9mIGFuIEFBQkIgaXMgaXRzZWxmLiBVc2UgY2xvbmUoKSBpZiB5b3UgbmVlZCBhIG5ldyBzaGFwZS5cbiAgICAgKiBAcmV0dXJucyBBbiBBQUJCIHRoYXQgYm91bmRzIHRoaXMgc2hhcGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRCb3VuZGluZ1JlY3QoKTogQUFCQjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib3VuZGluZyBjaXJjbGUgZm9yIHRoaXMgc2hhcGUuIFdhcm5pbmcgLSBtYXkgYmUgdGhlIHNhbWUgYXMgdGhpcyBTaGFwZS5cbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRoZSBib3VuZGluZyBjaXJjbGUgb2YgYSBDaXJjbGUgaXMgaXRzZWxmLiBVc2UgY2xvbmUoKSBpZiB5b3UgbmVlZCBhIG5ldyBzaGFwZS5cbiAgICAgKiBAcmV0dXJucyBBIENpcmNsZSB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBTaGFwZVxuICAgICAqIEByZXR1cm5zIEEgbmV3IGNvcHkgb2YgdGhpcyBzaGFwZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGNsb25lKCk6IFNoYXBlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgc2hhcGUgb3ZlcmxhcHMgYW5vdGhlclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgc2hhcGUgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIGEgYm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGlzIFNoYXBlIG92ZXJsYXBzIHRoZSBvdGhlciBvbmVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuO1xuXG4gICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgU2hhcGUgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGFic3RyYWN0IGNvbnRhaW5zUG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuO1xuXG4gICAgc3RhdGljIGdldFRpbWVPZkNvbGxpc2lvbihBOiBTaGFwZSwgdmVsQTogVmVjMiwgQjogU2hhcGUsIHZlbEI6IFZlYzIpOiBbVmVjMiwgVmVjMiwgYm9vbGVhbiwgYm9vbGVhbl0ge1xuXHRcdGlmKEEgaW5zdGFuY2VvZiBBQUJCICYmIEIgaW5zdGFuY2VvZiBBQUJCKXtcblx0XHRcdHJldHVybiBTaGFwZS5nZXRUaW1lT2ZDb2xsaXNpb25fQUFCQl9BQUJCKEEsIHZlbEEsIEIsIHZlbEIpO1xuXHRcdH1cbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBOiBBQUJCLCB2ZWxBOiBWZWMyLCBCOiBTaGFwZSwgdmVsQjogVmVjMik6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XG4gICAgICAgIGxldCBwb3NTbWFsbGVyID0gQS5jZW50ZXI7XG4gICAgICAgIGxldCBwb3NMYXJnZXIgPSBCLmNlbnRlcjtcbiAgICAgICAgXG4gICAgICAgIGxldCBzaXplU21hbGxlciA9IEEuaGFsZlNpemU7XG4gICAgICAgIGxldCBzaXplTGFyZ2VyID0gQi5oYWxmU2l6ZTtcbiAgICBcbiAgICAgICAgbGV0IGZpcnN0Q29udGFjdCA9IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICBsZXQgbGFzdENvbnRhY3QgPSBuZXcgVmVjMigwLCAwKTtcbiAgICBcbiAgICAgICAgbGV0IGNvbGxpZGluZ1ggPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvbGxpZGluZ1kgPSBmYWxzZTtcbiAgICBcbiAgICAgICAgLy8gU29ydCBieSBwb3NpdGlvblxuICAgICAgICBpZihwb3NMYXJnZXIueCA8IHBvc1NtYWxsZXIueCl7XG4gICAgICAgICAgICAvLyBTd2FwLCBiZWNhdXNlIHNtYWxsZXIgaXMgZnVydGhlciByaWdodCB0aGFuIGxhcmdlclxuICAgICAgICAgICAgbGV0IHRlbXA6IFZlYzI7XG4gICAgICAgICAgICB0ZW1wID0gc2l6ZVNtYWxsZXI7XG4gICAgICAgICAgICBzaXplU21hbGxlciA9IHNpemVMYXJnZXI7XG4gICAgICAgICAgICBzaXplTGFyZ2VyID0gdGVtcDtcbiAgICBcbiAgICAgICAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xuICAgICAgICAgICAgcG9zU21hbGxlciA9IHBvc0xhcmdlcjtcbiAgICAgICAgICAgIHBvc0xhcmdlciA9IHRlbXA7XG4gICAgXG4gICAgICAgICAgICB0ZW1wID0gdmVsQTtcbiAgICAgICAgICAgIHZlbEEgPSB2ZWxCO1xuICAgICAgICAgICAgdmVsQiA9IHRlbXA7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQSBpcyBsZWZ0LCBCIGlzIHJpZ2h0XG4gICAgICAgIGZpcnN0Q29udGFjdC54ID0gSW5maW5pdHk7XG4gICAgICAgIGxhc3RDb250YWN0LnggPSBJbmZpbml0eTtcbiAgICBcbiAgICAgICAgaWYgKHBvc0xhcmdlci54IC0gc2l6ZUxhcmdlci54ID49IHBvc1NtYWxsZXIueCArIHNpemVTbWFsbGVyLngpe1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlbid0IGN1cnJlbnRseSBjb2xsaWRpbmdcbiAgICAgICAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnggLSB2ZWxCLng7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHJlbFZlbCA+IDApe1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcbiAgICAgICAgICAgICAgICBmaXJzdENvbnRhY3QueCA9ICgocG9zTGFyZ2VyLnggLSBzaXplTGFyZ2VyLngpIC0gKHBvc1NtYWxsZXIueCArIHNpemVTbWFsbGVyLngpKS8ocmVsVmVsKTtcbiAgICAgICAgICAgICAgICBsYXN0Q29udGFjdC54ID0gKChwb3NMYXJnZXIueCArIHNpemVMYXJnZXIueCkgLSAocG9zU21hbGxlci54IC0gc2l6ZVNtYWxsZXIueCkpLyhyZWxWZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGlkaW5nWCA9IHRydWU7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYocG9zTGFyZ2VyLnkgPCBwb3NTbWFsbGVyLnkpe1xuICAgICAgICAgICAgLy8gU3dhcCwgYmVjYXVzZSBzbWFsbGVyIGlzIGZ1cnRoZXIgdXAgdGhhbiBsYXJnZXJcbiAgICAgICAgICAgIGxldCB0ZW1wOiBWZWMyO1xuICAgICAgICAgICAgdGVtcCA9IHNpemVTbWFsbGVyO1xuICAgICAgICAgICAgc2l6ZVNtYWxsZXIgPSBzaXplTGFyZ2VyO1xuICAgICAgICAgICAgc2l6ZUxhcmdlciA9IHRlbXA7XG4gICAgXG4gICAgICAgICAgICB0ZW1wID0gcG9zU21hbGxlcjtcbiAgICAgICAgICAgIHBvc1NtYWxsZXIgPSBwb3NMYXJnZXI7XG4gICAgICAgICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xuICAgIFxuICAgICAgICAgICAgdGVtcCA9IHZlbEE7XG4gICAgICAgICAgICB2ZWxBID0gdmVsQjtcbiAgICAgICAgICAgIHZlbEIgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEEgaXMgdG9wLCBCIGlzIGJvdHRvbVxuICAgICAgICBmaXJzdENvbnRhY3QueSA9IEluZmluaXR5O1xuICAgICAgICBsYXN0Q29udGFjdC55ID0gSW5maW5pdHk7XG4gICAgXG4gICAgICAgIGlmIChwb3NMYXJnZXIueSAtIHNpemVMYXJnZXIueSA+PSBwb3NTbWFsbGVyLnkgKyBzaXplU21hbGxlci55KXtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXG4gICAgICAgICAgICBsZXQgcmVsVmVsID0gdmVsQS55IC0gdmVsQi55O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihyZWxWZWwgPiAwKXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBtb3ZpbmcgdG93YXJkcyBlYWNoIG90aGVyXG4gICAgICAgICAgICAgICAgZmlyc3RDb250YWN0LnkgPSAoKHBvc0xhcmdlci55IC0gc2l6ZUxhcmdlci55KSAtIChwb3NTbWFsbGVyLnkgKyBzaXplU21hbGxlci55KSkvKHJlbFZlbCk7XG4gICAgICAgICAgICAgICAgbGFzdENvbnRhY3QueSA9ICgocG9zTGFyZ2VyLnkgKyBzaXplTGFyZ2VyLnkpIC0gKHBvc1NtYWxsZXIueSAtIHNpemVTbWFsbGVyLnkpKS8ocmVsVmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxpZGluZ1kgPSB0cnVlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBbZmlyc3RDb250YWN0LCBsYXN0Q29udGFjdCwgY29sbGlkaW5nWCwgY29sbGlkaW5nWV07XG4gICAgfVxufSIsImltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi9TdGF0ZU1hY2hpbmVcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIHN0YXRlIGZvciBhIEByZWZlcmVuY2VbU3RhdGVNYWNoaW5lXS5cbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIGJlIGV4dGVuZGVkIHRvIGFsbG93IGZvciBjdXN0b20gc3RhdGUgYmVoYXZpb3JzLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTdGF0ZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuICAgIC8qKiBUaGUgU3RhdGVNYWNoaW5lIHRoYXQgdXNlcyB0aGlzIFN0YXRlICovXG4gICAgcHJvdGVjdGVkIHBhcmVudDogU3RhdGVNYWNoaW5lO1xuXG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3RhdGVcbiAgICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgU3RhdGVNYWNoaW5lIG9mIHRoaXMgc3RhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IFN0YXRlTWFjaGluZSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoaXMgc3RhdGUgaXMgZW50ZXJlZC4gVXNlIHRoaXMgdG8gaW5pdGlhbGl6ZSBhbnkgdmFyaWFibGVzIGJlZm9yZSB1cGRhdGVzIG9jY3VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEluZm9ybWF0aW9uIHRvIHBhc3MgdG8gdGhpcyBzdGF0ZVxuICAgICAqL1xuICAgIGFic3RyYWN0IG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBoYW5kbGVzIGFuIGlucHV0IGV2ZW50LCBzdWNoIGFzIHRha2luZyBkYW1hZ2UuXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBHYW1lRXZlbnQgdG8gcHJvY2Vzc1xuICAgICAqL1xuICAgIGFic3RyYWN0IGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkO1xuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgYWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBzdGF0ZSBtYWNoaW5lIHRoYXQgdGhpcyBzdGF0ZSBoYXMgZW5kZWQsIGFuZCBtYWtlcyBpdCB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgc3RhdGUgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHN0YXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0b1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaW5pc2hlZChzdGF0ZU5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudC5jaGFuZ2VTdGF0ZShzdGF0ZU5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaXMgZW5kaW5nLlxuICAgICAqIEByZXR1cm5zIGluZm8gdG8gcGFzcyB0byB0aGUgbmV4dCBzdGF0ZVxuICAgICAqL1xuICAgIGFic3RyYWN0IG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufSIsImltcG9ydCBTdGFjayBmcm9tIFwiLi4vQ29sbGVjdGlvbnMvU3RhY2tcIjtcbmltcG9ydCBTdGF0ZSBmcm9tIFwiLi9TdGF0ZVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBQdXNoIERvd24gQXV0b21hdGEgU3RhdGUgbWFjaGluZS4gU3RhdGVzIGNhbiBhbHNvIGJlIGhpZXJhcmNoaWNhbFxuICogZm9yIG1vcmUgZmxleGliaWxpdHksIGFzIGRlc2NyaWJlZCBpbiBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9zdGF0ZS5odG1sKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVNYWNoaW5lIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG4gICAgLyoqIEEgc3RhY2sgb2YgdGhlIGN1cnJlbnQgc3RhdGVzICovXG4gICAgcHJvdGVjdGVkIHN0YWNrOiBTdGFjazxTdGF0ZT47XG4gICAgLyoqIEEgbWFwZSBvZiBzdGF0ZSBrZXlzIHRvIGFjdHVhbCBzdGF0ZSBpbnN0YW5jZXMgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGVNYXA6IE1hcDxTdGF0ZT47XG4gICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlICovXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRTdGF0ZTogU3RhdGU7XG4gICAgLyoqIEFuIGV2ZW50IHJlY2VpdmVyICovXG4gICAgcHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcbiAgICAvKiogQW4gZXZlbnQgZW1pdHRlciAqL1xuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xuICAgIC8qKiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgU3RhdGVNYWNoaW5lIGlzIGN1cnJlbnRseSBhY3RpdmUgKi9cbiAgICBwcm90ZWN0ZWQgYWN0aXZlOiBib29sZWFuO1xuICAgIC8qKiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgU3RhdGVNYWNoaW5lIHNob3VsZCBlbWl0IGFuIGV2ZW50IG9uIHN0YXRlIGNoYW5nZSAqL1xuICAgIHByb3RlY3RlZCBlbWl0RXZlbnRPblN0YXRlQ2hhbmdlOiBib29sZWFuO1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgZW1pdHRlZCBvbiBzdGF0ZSBjaGFuZ2UgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGVDaGFuZ2VFdmVudE5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RhdGVNYWNoaW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgICB0aGlzLnN0YXRlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2aXR5IHN0YXRlIG9mIHRoaXMgc3RhdGUgbWFjaGluZVxuICAgICAqIEBwYXJhbSBmbGFnIFRydWUgaWYgeW91IHdhbnQgdG8gc2V0IHRoaXMgbWFjaGluZSBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzZXRBY3RpdmUoZmxhZzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZsYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhpcyBzdGF0ZSBtYWNoaW5lIGVtaXQgYW4gZXZlbnQgYW55IHRpbWUgaXRzIHN0YXRlIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gc3RhdGVDaGFuZ2VFdmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXRcbiAgICAgKi9cbiAgICBzZXRFbWl0RXZlbnRPblN0YXRlQ2hhbmdlKHN0YXRlQ2hhbmdlRXZlbnROYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSA9IHN0YXRlQ2hhbmdlRXZlbnROYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoaXMgc3RhdGUgbWFjaGluZSBmcm9tIGVtaXR0aW5nIGV2ZW50cyBvbiBzdGF0ZSBjaGFuZ2UuXG4gICAgICovXG4gICAgY2FuY2VsRW1pdEV2ZW50T25TdGF0ZUNoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoaXMgc3RhdGUgbWFjaGluZSB3aXRoIGFuIGluaXRpYWwgc3RhdGUgYW5kIHNldHMgaXQgcnVubmluZ1xuICAgICAqIEBwYXJhbSBpbml0aWFsU3RhdGUgVGhlIG5hbWUgb2YgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgc3RhdGUgbWFjaGluZVxuICAgICAqL1xuICAgIGluaXRpYWxpemUoaW5pdGlhbFN0YXRlOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlTWFwLmdldChpbml0aWFsU3RhdGUpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB0aGlzLnN0YWNrLnBlZWsoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmUodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0YXRlIHRvIHRoaXMgc3RhdGUgbWFjaGluZVxuICAgICAqIEBwYXJhbSBzdGF0ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGFkZFxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdG8gYWRkXG4gICAgICovXG4gICAgYWRkU3RhdGUoc3RhdGVOYW1lOiBzdHJpbmcsIHN0YXRlOiBTdGF0ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YXRlTWFwLmFkZChzdGF0ZU5hbWUsIHN0YXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBzdGF0ZSBvZiB0aGlzIHN0YXRlIG1hY2hpbmUgdG8gdGhlIHByb3ZpZGVkIHN0cmluZ1xuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RyaW5nIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGNoYW5nZSB0b1xuICAgICAqL1xuICAgIGNoYW5nZVN0YXRlKHN0YXRlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gRXhpdCB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMuY3VycmVudFN0YXRlLm9uRXhpdCgpO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29ycmVjdCBzdGF0ZSBpcyBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICBpZihzdGF0ZSA9PT0gXCJwcmV2aW91c1wiKXtcbiAgICAgICAgICAgIC8vIFBvcCB0aGUgY3VycmVudCBzdGF0ZSBvZmYgdGhlIHN0YWNrXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIG5ldyBzdGF0ZSBmcm9tIHRoZSBzdGF0ZW1hcCBhbmQgcHV0IGl0IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGVNYXAuZ2V0KHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRyZWl2ZSB0aGUgbmV3IHN0YXRlIGZyb20gdGhlIHN0YWNrXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XG5cbiAgICAgICAgLy8gRW1pdCBhbiBldmVudCBpZiB0dXJuZWQgb25cbiAgICAgICAgaWYodGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSwge3N0YXRlOiB0aGlzLmN1cnJlbnRTdGF0ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW50ZXIgdGhlIG5ldyBzdGF0ZVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5vbkVudGVyKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgaW5wdXQuIFRoaXMgaGFwcGVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lJ3MgdXBkYXRlIGN5Y2xlLlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZ2FtZSBldmVudCB0byBwcm9jZXNzXG4gICAgICovXG4gICAgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmFjdGl2ZSl7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5oYW5kbGVJbnB1dChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAaW1wbGVtZW50ZWRcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gRGlzdHJpYnV0ZSBldmVudHNcbiAgICAgICAgd2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWxlZ2F0ZSB0aGUgdXBkYXRlIHRvIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLnVwZGF0ZShkZWx0YVQpO1xuICAgIH1cbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IHsgVGlsZWRUaWxlc2V0RGF0YSB9IGZyb20gXCIuL1RpbGVkRGF0YVwiO1xuXG4vKipcbiAqIFRoZSBkYXRhIHJlcHJlc2VudGF0aW9uIG9mIGEgVGlsZXNldCBmb3IgdGhlIGdhbWUgZW5naW5lLiBUaGlzIHJlcHJlc2VudHMgb25lIGltYWdlLFxuICogd2l0aCBhIHN0YXJ0SW5kZXggaWYgcmVxdWlyZWQgKGFzIGl0IGlzIHdpdGggVGlsZWQgdXNpbmcgdHdvIGltYWdlcyBpbiBvbmUgdGlsc2V0KS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZXNldCB7XG4gICAgLyoqIFRoZSBrZXkgb2YgdGhlIGltYWdlIHVzZWQgYnkgdGhpcyB0aWxlc2V0ICovXG4gICAgcHJvdGVjdGVkIGltYWdlS2V5OiBzdHJpbmc7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlc2V0IGltYWdlICovXG4gICAgcHJvdGVjdGVkIGltYWdlU2l6ZTogVmVjMjtcbiAgICAvKiogVGhlIGluZGV4IG9mIDB0aCBpbWFnZSBvZiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgc3RhcnRJbmRleDogbnVtYmVyO1xuICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaW1hZ2Ugb2YgdGhpcyB0aWxzZXQgKi9cbiAgICBwcm90ZWN0ZWQgZW5kSW5kZXg6IG51bWJlcjtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIHRpbGVzIGluIHRoaXMgdGlsZXNldCAqL1xuICAgIHByb3RlY3RlZCB0aWxlU2l6ZTogVmVjMjtcbiAgICAvKiogVGhlIG51bWJlciBvZiByb3dzIGluIHRoaXMgdGlsZXNldCAqL1xuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xuXG4gICAgLy8gVE9ETzogQ2hhbmdlIHRoaXMgdG8gYmUgbW9yZSBnZW5lcmFsIGFuZCB3b3JrIHdpdGggb3RoZXIgdGlsZXNldCBmb3JtYXRzXG4gICAgY29uc3RydWN0b3IodGlsZXNldERhdGE6IFRpbGVkVGlsZXNldERhdGEpe1xuICAgICAgICAvLyBEZWZlciBoYW5kbGluZyBvZiB0aGUgZGF0YSB0byBhIGhlbHBlciBjbGFzc1xuICAgICAgICB0aGlzLmluaXRGcm9tVGlsZWREYXRhKHRpbGVzZXREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSB0aWxlc2V0IGZyb20gdGhlIGRhdGEgZnJvbSBhIFRpbGVkIGpzb24gZmlsZVxuICAgICAqIEBwYXJhbSB0aWxlZERhdGEgVGhlIHBhcnNlZCBvYmplY3QgZnJvbSBhIFRpbGVkIGpzb24gZmlsZVxuICAgICAqL1xuICAgIGluaXRGcm9tVGlsZWREYXRhKHRpbGVkRGF0YTogVGlsZWRUaWxlc2V0RGF0YSk6IHZvaWQge1xuICAgICAgICB0aGlzLm51bVJvd3MgPSB0aWxlZERhdGEudGlsZWNvdW50L3RpbGVkRGF0YS5jb2x1bW5zO1xuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlZERhdGEuY29sdW1ucztcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gdGlsZWREYXRhLmZpcnN0Z2lkO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gdGhpcy5zdGFydEluZGV4ICsgdGlsZWREYXRhLnRpbGVjb3VudCAtIDE7XG4gICAgICAgIHRoaXMudGlsZVNpemUgPSBuZXcgVmVjMih0aWxlZERhdGEudGlsZXdpZHRoLCB0aWxlZERhdGEudGlsZXdpZHRoKTtcbiAgICAgICAgdGhpcy5pbWFnZUtleSA9IHRpbGVkRGF0YS5pbWFnZTtcbiAgICAgICAgdGhpcy5pbWFnZVNpemUgPSBuZXcgVmVjMih0aWxlZERhdGEuaW1hZ2V3aWR0aCwgdGlsZWREYXRhLmltYWdlaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogR2V0cyB0aGUgaW1hZ2Uga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRpbGVtYXBcbiAgICAgKiBAcmV0dXJucyBUaGUgaW1hZ2Uga2V5IG9mIHRoaXMgdGlsZW1hcFxuICAgICAqL1xuICAgIGdldEltYWdlS2V5KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlS2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBWZWMyIGNvbnRhaW5pbmcgdGhlIGxlZnQgYW5kIHRvcCBvZmZzZXQgZnJvbSB0aGUgaW1hZ2Ugb3JpZ2luIGZvciB0aGlzIHRpbGUuXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgZnJvbSBzdGFydEluZGV4IHRvIGVuZEluZGV4IG9mIHRoaXMgdGlsZXNldFxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBvZmZzZXQgZm9yIHRoZSBzcGVjaWZpZWQgdGlsZS5cbiAgICAgKi9cbiAgICBnZXRJbWFnZU9mZnNldEZvclRpbGUodGlsZUluZGV4OiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0cnVlIGluZGV4XG4gICAgICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRoaXMuc3RhcnRJbmRleDtcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudGlsZVNpemUueDtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudGlsZVNpemUueTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiBuZXcgVmVjMihsZWZ0LCB0b3ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXJ0IGluZGV4XG4gICAgICogQHJldHVybnMgVGhlIHN0YXJ0IGluZGV4XG4gICAgICovXG4gICAgZ2V0U3RhcnRJbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydEluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbGUgc2V0XG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHRpbGUgc2l6ZVxuICAgICAqL1xuICAgIGdldFRpbGVTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZXNldFxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygcm93c1xuICAgICAqL1xuICAgIGdldE51bVJvd3MoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUm93cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGlsc2V0XG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjb2x1bW5zXG4gICAgICovXG4gICAgZ2V0TnVtQ29scygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Db2xzO1xuICAgIH1cblxuICAgIGdldFRpbGVDb3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRJbmRleCAtIHRoaXMuc3RhcnRJbmRleCArIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgdGlsc2V0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgdGlsZSBpbmRleC4gVGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgdGlsc2V0IHVzZXMgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqL1xuICAgIGhhc1RpbGUodGlsZUluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRpbGVJbmRleCA+PSB0aGlzLnN0YXJ0SW5kZXggJiYgdGlsZUluZGV4IDw9IHRoaXMuZW5kSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc2luZ3VsYXIgdGlsZSB3aXRoIGluZGV4IHRpbGVJbmRleCBmcm9tIHRoZSB0aWxlc2V0IGxvY2F0ZWQgYXQgcG9zaXRpb24gZGF0YUluZGV4XG4gICAgICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gdGlsZUluZGV4IFRoZSB2YWx1ZSBvZiB0aGUgdGlsZSB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0gZGF0YUluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgZGF0YSBhcnJheVxuICAgICAqIEBwYXJhbSB3b3JsZFNpemUgVGhlIHNpemUgb2YgdGhlIHdvcmxkXG4gICAgICogQHBhcmFtIG9yaWdpbiBUaGUgdmlld3BvcnQgb3JpZ2luIGluIHRoZSBjdXJyZW50IGxheWVyXG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgdGlsZW1hcFxuICAgICAqL1xuICAgIHJlbmRlclRpbGUoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHRpbGVJbmRleDogbnVtYmVyLCBkYXRhSW5kZXg6IG51bWJlciwgbWF4Q29sczogbnVtYmVyLCBvcmlnaW46IFZlYzIsIHNjYWxlOiBWZWMyLCB6b29tOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGltYWdlID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0SW1hZ2UodGhpcy5pbWFnZUtleSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB0cnVlIGluZGV4XG4gICAgICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRoaXMuc3RhcnRJbmRleDtcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudGlsZVNpemUueDtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudGlsZVNpemUueTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHdvcmxkIHRvIHJlbmRlciB0aGUgdGlsZVxuICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IoKGRhdGFJbmRleCAlIG1heENvbHMpICogd2lkdGggKiBzY2FsZS54KTtcbiAgICAgICAgbGV0IHkgPSBNYXRoLmZsb29yKE1hdGguZmxvb3IoZGF0YUluZGV4IC8gbWF4Q29scykgKiBoZWlnaHQgKiBzY2FsZS55KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBNYXRoLmZsb29yKCh4IC0gb3JpZ2luLngpKnpvb20pLCBNYXRoLmZsb29yKCh5IC0gb3JpZ2luLnkpKnpvb20pLCBNYXRoLmNlaWwod2lkdGggKiBzY2FsZS54ICogem9vbSksIE1hdGguY2VpbChoZWlnaHQgKiBzY2FsZS55ICogem9vbSkpO1xuICAgIH1cbn0iLCJpbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuLyoqXG4gKiBBIHR3by1kaW1lbnNpb25hbCB2ZWN0b3IgKHgsIHkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlYzIge1xuXG5cdC8vIFN0b3JlIHggYW5kIHkgaW4gYW4gYXJyYXlcblx0LyoqIFRoZSBhcnJheSB0aGF0IHN0b3JlcyB0aGUgYWN0dWFsIHZlY3RvciB2YWx1ZXMgeCBhbmQgeSAqL1xuXHRwcml2YXRlIHZlYzogRmxvYXQzMkFycmF5O1xuXHRwdWJsaWMgY3VycmVudFRyYW5zcGFyZW50TGFiZWxzOkFycmF5PExhYmVsPjtcblx0LyoqXHRcblx0ICogV2hlbiB0aGlzIHZlY3RvciBjaGFuZ2VzIGl0cyB2YWx1ZSwgZG8gc29tZXRoaW5nXG5cdCAqL1xuXHRwcml2YXRlIG9uQ2hhbmdlOiBGdW5jdGlvbiA9ICgpID0+IHt9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IFZlYzJcblx0ICogQHBhcmFtIHggVGhlIHggdmFsdWUgb2YgdGhlIHZlY3RvclxuXHQgKiBAcGFyYW0geSBUaGUgeSB2YWx1ZSBvZiB0aGUgdmVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih4OiBudW1iZXIgPSAwLCB5OiBudW1iZXIgPSAwKSB7XG5cdFx0dGhpcy52ZWMgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuXHRcdHRoaXMudmVjWzBdID0geDtcblx0XHR0aGlzLnZlY1sxXSA9IHk7XG5cdH1cblxuXHQvLyBFeHBvc2UgeCBhbmQgeSB3aXRoIGdldHRlcnMgYW5kIHNldHRlcnNcblx0Z2V0IHgoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmVjWzBdO1xuXHR9XG5cblx0c2V0IHgoeDogbnVtYmVyKSB7XG5cdFx0dGhpcy52ZWNbMF0gPSB4O1xuXG5cdFx0aWYodGhpcy5vbkNoYW5nZSl7XG5cdFx0XHR0aGlzLm9uQ2hhbmdlKCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmVjWzFdO1xuXHR9XG5cblx0c2V0IHkoeTogbnVtYmVyKSB7XG5cdFx0dGhpcy52ZWNbMV0gPSB5O1xuXG5cdFx0aWYodGhpcy5vbkNoYW5nZSl7XG5cdFx0XHR0aGlzLm9uQ2hhbmdlKCk7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGdldCBaRVJPKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigwLCAwKTtcblx0fVxuXG5cdHN0YXRpYyByZWFkb25seSBaRVJPX1NUQVRJQyA9IG5ldyBWZWMyKDAsIDApO1xuXG5cdHN0YXRpYyBnZXQgSU5GKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMihJbmZpbml0eSwgSW5maW5pdHkpO1xuXHR9XG5cblx0c3RhdGljIGdldCBVUCgpIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIoMCwgLTEpO1xuXHR9XG5cblx0c3RhdGljIGdldCBET1dOKCkge1xuXHRcdHJldHVybiBuZXcgVmVjMigwLCAxKTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgTEVGVCgpIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIoLTEsIDApO1xuXHR9XG5cblx0c3RhdGljIGdldCBSSUdIVCgpIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIoMSwgMCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuIFRoaXMgdGVuZHMgdG8gYmUgZmFzdGVyLCBzbyB1c2UgaXQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0YWtpbmcgdGhlXG5cdCAqIHNxdWFyZSByb290IGRvZXNuJ3QgbWF0dGVyLCBsaWtlIGZvciBjb21wYXJpbmcgZGlzdGFuY2VzLlxuXHQgKiBAcmV0dXJucyBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvclxuXHQgKi9cblx0bWFnU3EoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy54KnRoaXMueCArIHRoaXMueSp0aGlzLnk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLlxuXHQgKiBAcmV0dXJucyBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXG5cdCAqL1xuXHRtYWcoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMubWFnU3EoKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGl2ZGVzIHggYW5kIHkgYnkgdGhlIG1hZ25pdHVkZSB0byBvYnRhaW4gdGhlIHVuaXQgdmVjdG9yIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhpcyB2ZWN0b3IuXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFzIGEgdW5pdCB2ZWN0b3IuXG5cdCAqL1xuXHRub3JtYWxpemUoKTogVmVjMiB7XG5cdFx0aWYodGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cdFx0bGV0IG1hZyA9IHRoaXMubWFnKCk7XG5cdFx0dGhpcy54IC89IG1hZztcblx0XHR0aGlzLnkgLz0gbWFnO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdvcmtzIGxpa2Ugbm9ybWFsaXplKCksIGJ1dCByZXR1cm5zIGEgbmV3IFZlYzJcblx0ICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHRoYXQgaXMgdGhlIHVuaXQgdmVjdG9yIGZvciB0aGlzIG9uZVxuXHQgKi9cblx0bm9ybWFsaXplZCgpOiBWZWMyIHtcblx0XHRpZih0aGlzLmlzWmVybygpKXtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRcblx0XHRsZXQgbWFnID0gdGhpcy5tYWcoKTtcblx0XHRyZXR1cm4gbmV3IFZlYzIodGhpcy54L21hZywgdGhpcy55L21hZyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgeCBhbmQgeSBlbGVtZW50cyBvZiB0aGlzIHZlY3RvciB0byB6ZXJvLlxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3Rvciwgd2l0aCB4IGFuZCB5IHNldCB0byB6ZXJvLlxuXHQgKi9cblx0emVybygpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5zZXQoMCwgMCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgeCBhbmQgeSBiYXNlZCBvbiB0aGUgYW5nbGUgcHJvdmlkZWQuIEdvZXMgY291bnRlciBjbG9ja3dpc2UuXG5cdCAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvciBhdCB0aGUgc3BlY2lmaWVkIGFuZ2xlXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yLlxuXHQgKi9cblx0c2V0VG9BbmdsZShhbmdsZTogbnVtYmVyLCByYWRpdXM6IG51bWJlciA9IDEpOiBWZWMyIHtcblx0XHR0aGlzLnggPSBNYXRoVXRpbHMuZmxvb3JUb1BsYWNlKE1hdGguY29zKGFuZ2xlKSpyYWRpdXMsIDUpO1xuXHRcdHRoaXMueSA9IE1hdGhVdGlscy5mbG9vclRvUGxhY2UoLU1hdGguc2luKGFuZ2xlKSpyYWRpdXMsIDUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB2ZWN0b3IgdGhhdCBwb2ludCBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXIgb25lXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIHBvaW50IHRvXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgdGhhdCBwb2ludHMgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb25lIHByb3ZpZGVkXG5cdCAqL1xuXHR2ZWNUbyhvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHJldHVybiBuZXcgVmVjMihvdGhlci54IC0gdGhpcy54LCBvdGhlci55IC0gdGhpcy55KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSB2ZWN0b3IgY29udGFpbmluZyB0aGUgZGlyZWN0aW9uIGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBwb2ludCB0b1xuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHRoYXQgcG9pbnRzIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG9uZSBwcm92aWRlZC4gVGhpcyBuZXcgVmVjMiB3aWxsIGJlIGEgdW5pdCB2ZWN0b3IuXG5cdCAqL1xuXHRkaXJUbyhvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLnZlY1RvKG90aGVyKS5ub3JtYWxpemUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBLZWVwcyB0aGUgdmVjdG9yJ3MgZGlyZWN0aW9uLCBidXQgc2V0cyBpdHMgbWFnbml0dWRlIHRvIGJlIHRoZSBwcm92aWRlZCBtYWduaXR1ZGVcblx0ICogQHBhcmFtIG1hZ25pdHVkZSBUaGUgbWFnbml0dWRlIHRoZSB2ZWN0b3Igc2hvdWxkIGJlXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIHdpdGggaXRzIG1hZ25pdHVkZSBzZXQgdG8gdGhlIG5ldyBtYWduaXR1ZGVcblx0ICovXG5cdHNjYWxlVG8obWFnbml0dWRlOiBudW1iZXIpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5zY2FsZShtYWduaXR1ZGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNjYWxlcyB4IGFuZCB5IGJ5IHRoZSBudW1iZXIgcHJvdmlkZWQsIG9yIGlmIHR3byBudW1iZXIgYXJlIHByb3ZpZGVkLCBzY2FsZXMgdGhlbSBpbmRpdmlkdWFsbHkuXG5cdCAqIEBwYXJhbSBmYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgdmVjdG9yLCBvciBmb3Igb25seSB0aGUgeC1jb21wb25lbnQgaWYgeUZhY3RvciBpcyBwcm92aWRlZFxuXHQgKiBAcGFyYW0geUZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB5LWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIHNjYWxpbmdcblx0ICovXG5cdHNjYWxlKGZhY3RvcjogbnVtYmVyLCB5RmFjdG9yOiBudW1iZXIgPSBudWxsKTogVmVjMiB7XG5cdFx0aWYoeUZhY3RvciAhPT0gbnVsbCl7XG5cdFx0XHR0aGlzLnggKj0gZmFjdG9yO1xuXHRcdFx0dGhpcy55ICo9IHlGYWN0b3I7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy54ICo9IGZhY3Rvcjtcblx0XHR0aGlzLnkgKj0gZmFjdG9yO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzY2FsZWQgdmVyc2lvbiBvZiB0aGlzIHZlY3RvciB3aXRob3V0IG1vZGlmeWluZyBpdC5cblx0ICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB5RmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHRoYXQgaGFzIHRoZSB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3IgYWZ0ZXIgc2NhbGluZ1xuXHQgKi9cblx0c2NhbGVkKGZhY3RvcjogbnVtYmVyLCB5RmFjdG9yOiBudW1iZXIgPSBudWxsKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5zY2FsZShmYWN0b3IsIHlGYWN0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJvdGF0ZXMgdGhlIHZlY3RvciBjb3VudGVyLWNsb2Nrd2lzZSBieSB0aGUgYW5nbGUgYW1vdW50IHNwZWNpZmllZFxuXHQgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSBpbiByYWRpYW5zXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIHJvdGF0aW9uLlxuXHQgKi9cblx0cm90YXRlQ0NXKGFuZ2xlOiBudW1iZXIpOiBWZWMyIHtcblx0XHRsZXQgY3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0bGV0IHNuID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdGxldCB0ZW1wWCA9IHRoaXMueCpjcyAtIHRoaXMueSpzbjtcblx0XHRsZXQgdGVtcFkgPSB0aGlzLngqc24gKyB0aGlzLnkqY3M7XG5cdFx0dGhpcy54ID0gdGVtcFg7XG5cdFx0dGhpcy55ID0gdGVtcFk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmVjdG9ycyBjb29yZGluYXRlcyB0byBiZSB0aGUgb25lcyBwcm92aWRlZFxuXHQgKiBAcGFyYW0geCBUaGUgbmV3IHggdmFsdWUgZm9yIHRoaXMgdmVjdG9yXG5cdCAqIEBwYXJhbSB5IFRoZSBuZXcgeSB2YWx1ZSBmb3IgdGhpcyB2ZWN0b3Jcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3Jcblx0ICovXG5cdHNldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IFZlYzIge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgb3RoZXIgVmVjMiBpbnRvIHRoaXMgb25lLlxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gY29weVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciB3aXRoIGl0cyB2YWx1ZXMgc2V0IHRvIHRoZSB2ZWN0b3IgcHJvdmlkZWRcblx0ICovXG5cdGNvcHkob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5zZXQob3RoZXIueCwgb3RoZXIueSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGlzIHZlY3RvciB0aGUgYW5vdGhlciB2ZWN0b3Jcblx0ICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIGFkZCB0byB0aGlzIG9uZVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBhZGRpbmcgdGhlIG9uZSBwcm92aWRlZFxuXHQgKi9cblx0YWRkKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0dGhpcy54ICs9IG90aGVyLng7XG5cdFx0dGhpcy55ICs9IG90aGVyLnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogSW5jcmVtZW50cyB0aGUgZmllbGRzIG9mIHRoaXMgdmVjdG9yLiBCb3RoIGFyZSBpbmNyZW1lbnRlZCB3aXRoIGEsIGlmIG9ubHkgYSBpcyBwcm92aWRlZC5cblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IG51bWJlciB0byBpbmNyZW1lbnQgYnlcblx0ICogQHBhcmFtIGIgVGhlIHNlY29uZCBudW1iZXIgdG8gaW5jcmVtZW50IGJ5XG5cdCAqIEByZXR1cm5zcyBUaGlzIHZlY3RvciBhZnRlciBpbmNyZW1lbnRpbmdcblx0ICovXG5cdGluYyhhOiBudW1iZXIsIGI/OiBudW1iZXIpOiBWZWMyIHtcblx0XHRpZihiID09PSB1bmRlZmluZWQpe1xuXHRcdFx0dGhpcy54ICs9IGE7XG5cdFx0XHR0aGlzLnkgKz0gYTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy54ICs9IGE7XG5cdFx0XHR0aGlzLnkgKz0gYjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU3VidHJhY3RzIGFub3RoZXIgdmVjdG9yIGZyb20gdGhpcyB2ZWN0b3Jcblx0ICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIHN1YnRyYWN0IGZyb20gdGhpcyBvbmVcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgc3VidHJhY3RpbmcgdGhlIG9uZSBwcm92aWRlZFxuXHQgKi9cblx0c3ViKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0dGhpcy54IC09IG90aGVyLng7XG5cdFx0dGhpcy55IC09IG90aGVyLnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogTXVsdGlwbGllcyB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIgdmVjdG9yIGVsZW1lbnQtd2lzZS4gSW4gb3RoZXIgd29yZHMsIHRoaXMueCAqPSBvdGhlci54IGFuZCB0aGlzLnkgKj0gb3RoZXIueVxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gbXVsdGlwbHkgdGhpcyBvbmUgYnlcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgbXVsdGlwbHlpbmcgaXRzIGNvbXBvbmVudHMgYnkgdGhpcyBvbmVcblx0ICovXG5cdG11bHQob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHR0aGlzLnggKj0gb3RoZXIueDtcblx0XHR0aGlzLnkgKj0gb3RoZXIueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZpZGVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgZWxlbWVudC13aXNlLiBJbiBvdGhlciB3b3JkcywgdGhpcy54IC89IG90aGVyLnggYW5kIHRoaXMueSAvPSBvdGhlci55XG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGRpdmlkZSB0aGlzIG9uZSBieVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBkaXZpc2lvblxuXHQgKi9cblx0ZGl2KG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0aWYob3RoZXIueCA9PT0gMCB8fCBvdGhlci55ID09PSAwKSB0aHJvdyBcIkRpdmlkZSBieSB6ZXJvIGVycm9yXCI7XG5cdFx0dGhpcy54IC89IG90aGVyLng7XG5cdFx0dGhpcy55IC89IG90aGVyLnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRG9lcyBhbiBlbGVtZW50IHdpc2UgcmVtYWluZGVyIG9wZXJhdGlvbiBvbiB0aGlzIHZlY3Rvci4gdGhpcy54ICU9IG90aGVyLnggYW5kIHRoaXMueSAlPSBvdGhlci55XG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgdmVjdG9yXG5cdCAqIEByZXR1cm5zIHRoaXMgdmVjdG9yXG5cdCAqL1xuXHRyZW1haW5kZXIob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHR0aGlzLnggPSB0aGlzLnggJSBvdGhlci54O1xuXHRcdHRoaXMueSA9IHRoaXMueSAlIG90aGVyLnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyIHZlY3RvclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIGRpc3RhbmNlIHNxdWFyZWQgdG9cblx0ICogQHJldHVybnMgVGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgdGhlIG9uZSBwcm92aWRlZFxuXHQgKi9cblx0ZGlzdGFuY2VTcVRvKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gKHRoaXMueCAtIG90aGVyLngpKih0aGlzLnggLSBvdGhlci54KSArICh0aGlzLnkgLSBvdGhlci55KSoodGhpcy55IC0gb3RoZXIueSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3Jcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSBkaXN0YW5jZSB0b1xuXHQgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgdGhlIG9uZSBwcm92aWRlZFxuXHQgKi9cblx0ZGlzdGFuY2VUbyhvdGhlcjogVmVjMik6IG51bWJlciB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3FUbyhvdGhlcikpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IHdpdGhcblx0ICogQHJldHVybnMgVGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkLlxuXHQgKi9cblx0ZG90KG90aGVyOiBWZWMyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy54Km90aGVyLnggKyB0aGlzLnkqb3RoZXIueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbmdsZSBjb3VudGVyLWNsb2Nrd2lzZSBpbiByYWRpYW5zIGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlciB2ZWN0b3Jcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgYW5nbGUgdG9cblx0ICogQHJldHVybnMgVGhlIGFuZ2xlLCByb3RhdGluZyBDQ1csIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG90aGVyIHZlY3RvclxuXHQgKi9cblx0YW5nbGVUb0NDVyhvdGhlcjogVmVjMik6IG51bWJlciB7XG5cdFx0bGV0IGRvdCA9IHRoaXMuZG90KG90aGVyKTtcblx0XHRsZXQgZGV0ID0gdGhpcy54Km90aGVyLnkgLSB0aGlzLnkqb3RoZXIueDtcblx0XHRsZXQgYW5nbGUgPSAtTWF0aC5hdGFuMihkZXQsIGRvdCk7XG5cblx0XHRpZihhbmdsZSA8IDApe1xuXHRcdFx0YW5nbGUgKz0gMipNYXRoLlBJO1xuXHRcdH1cblxuXHRcdHJldHVybiBhbmdsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yIHJvdW5kZWQgdG8gMSBkZWNpbWFsIHBvaW50XG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFzIGEgc3RyaW5nXG5cdCAqL1xuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLnRvRml4ZWQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHNcblx0ICogQHBhcmFtIG51bURlY2ltYWxQb2ludHMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cyB0byBjcmVhdGUgYSBzdHJpbmcgdG9cblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSBzdHJpbmdcblx0ICovXG5cdHRvRml4ZWQobnVtRGVjaW1hbFBvaW50czogbnVtYmVyID0gMSk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIFwiKFwiICsgdGhpcy54LnRvRml4ZWQobnVtRGVjaW1hbFBvaW50cykgKyBcIiwgXCIgKyB0aGlzLnkudG9GaXhlZChudW1EZWNpbWFsUG9pbnRzKSArIFwiKVwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHdpdGggdGhlIHNhbWUgY29vcmRpbmF0ZXMgYXMgdGhpcyBvbmUuXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmVcblx0ICovXG5cdGNsb25lKCk6IFZlYzIge1xuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLngsIHRoaXMueSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGFuZCBvdGhlciBoYXZlIHRoZSBFWEFDVCBzYW1lIHggYW5kIHkgKG5vdCBhc3N1cmVkIHRvIGJlIHNhZmUgZm9yIGZsb2F0cylcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY2hlY2sgYWdhaW5zdFxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGUgdHdvIHZlY3RvcnNcblx0ICovXG5cdHN0cmljdEVxdWFscyhvdGhlcjogVmVjMik6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZlY3RvciBhbmQgb3RoZXIgaGF2ZSB0aGUgc2FtZSB4IGFuZCB5XG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNoZWNrIGFnYWluc3Rcblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhlIHR3byB2ZWN0b3JzXG5cdCAqL1xuXHRlcXVhbHMob3RoZXI6IFZlYzIpOiBib29sZWFuIHtcblx0XHRsZXQgeEVxID0gTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCAwLjAwMDAwMDE7XG5cdFx0bGV0IHlFcSA9IE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgMC4wMDAwMDAxO1xuXG5cdFx0cmV0dXJuIHhFcSAmJiB5RXE7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGlzIHRoZSB6ZXJvIHZlY3RvciBleGFjdGx5IChub3QgYXNzdXJlZCB0byBiZSBzYWZlIGZvciBmbG9hdHMpLlxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIHplcm8gdmVjdG9yXG5cdCAqL1xuXHRzdHJpY3RJc1plcm8oKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDA7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgeCBhbmQgeSBmb3IgdGhpcyB2ZWN0b3IgYXJlIGJvdGggemVyby5cblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSB6ZXJvIHZlY3RvclxuXHQgKi9cblx0aXNaZXJvKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiBNYXRoLmFicyh0aGlzLngpIDwgMC4wMDAwMDAxICYmIE1hdGguYWJzKHRoaXMueSkgPCAwLjAwMDAwMDE7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciB0aGlzIHZlY3RvciBpcyBjaGFuZ2VkLlxuXHQgKiBAcGFyYW0gZiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5cdCAqL1xuXHRzZXRPbkNoYW5nZShmOiBGdW5jdGlvbik6IHZvaWQge1xuXHRcdHRoaXMub25DaGFuZ2UgPSBmO1xuXHR9XG5cblx0dG9BcnJheSgpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiB0aGlzLnZlYztcblx0fVxuXG5cdC8qKlxuXHQgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWN0b3JzXG5cdCAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3Jcblx0ICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3Jcblx0ICogQHBhcmFtIHQgVGhlIHRpbWUgb2YgdGhlIGxlcnAsIHdpdGggMCBiZWluZyB2ZWN0b3IgQSwgYW5kIDEgYmVpbmcgdmVjdG9yIEJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiByZXByZXNlbnRpbmcgdGhlIGxlcnAgYmV0d2VlbiB2ZWN0b3IgYSBhbmQgYi5cblx0ICovXG5cdHN0YXRpYyBsZXJwKGE6IFZlYzIsIGI6IFZlYzIsIHQ6IG51bWJlcik6IFZlYzIge1xuXHRcdHJldHVybiBuZXcgVmVjMihNYXRoVXRpbHMubGVycChhLngsIGIueCwgdCksIE1hdGhVdGlscy5sZXJwKGEueSwgYi55LCB0KSk7XG5cdH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcblxuLyoqXG4gKiBBIHV0aWwgY2xhc3MgZm9yIHJlbmRlcmluZyBEZWJ1ZyBtZXNzYWdlcyB0byB0aGUgY2FudmFzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWJ1ZyB7XG5cblx0LyoqIEEgbWFwIG9mIGxvZyBtZXNzYWdlcyB0byBkaXNwbGF5IG9uIHRoZSBzY3JlZW4gKi8gXG5cdHByaXZhdGUgc3RhdGljIGxvZ01lc3NhZ2VzOiBNYXA8c3RyaW5nPiA9IG5ldyBNYXAoKTtcblxuXHQvKiogQW4gYXJyYXkgb2YgZ2FtZSBub2RlcyB0byByZW5kZXIgZGVidWcgaW5mbyBmb3IgKi9cblx0cHJpdmF0ZSBzdGF0aWMgbm9kZXM6IEFycmF5PEdhbWVOb2RlPjtcblxuXHQvKiogVGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciBhbnkgZGVidWcgbWVzc2FnZXMgKi9cblx0cHJpdmF0ZSBzdGF0aWMgZGVidWdSZW5kZXJpbmdDb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cblx0LyoqXHRUaGUgc2l6ZSBvZiB0aGUgZGVidWcgY2FudmFzICovXG5cdHByaXZhdGUgc3RhdGljIGRlYnVnQ2FudmFzU2l6ZTogVmVjMjtcblxuXHQvKiogVGhlIHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCAqL1xuXHRwcml2YXRlIHN0YXRpYyBkZWZhdWx0VGV4dENvbG9yOiBDb2xvciA9IENvbG9yLldISVRFO1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gdGhlIGRlYnVnIHNjcmVlblxuXHQgKiBAcGFyYW0gaWQgQSB1bmlxdWUgSUQgZm9yIHRoaXMgbWVzc2FnZVxuXHQgKiBAcGFyYW0gbWVzc2FnZXMgVGhlIG1lc3NhZ2VzIHRvIHByaW50IHRvIHRoZSBkZWJ1ZyBzY3JlZW5cblx0ICovXG5cdHN0YXRpYyBsb2coaWQ6IHN0cmluZywgLi4ubWVzc2FnZXM6IGFueSk6IHZvaWQge1xuXHRcdC8vIGxldCBtZXNzYWdlID0gXCJcIjtcblx0XHQvLyBmb3IobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspe1xuXHRcdC8vIFx0bWVzc2FnZSArPSBtZXNzYWdlc1tpXS50b1N0cmluZygpO1xuXHRcdC8vIH1cblx0XHQvLyBKb2luIGFsbCBtZXNzYWdlcyB3aXRoIHNwYWNlc1xuXHRcdGxldCBtZXNzYWdlID0gbWVzc2FnZXMubWFwKChtOiBhbnkpID0+IG0udG9TdHJpbmcoKSkuam9pbihcIiBcIik7XG5cdFx0dGhpcy5sb2dNZXNzYWdlcy5hZGQoaWQsIG1lc3NhZ2UpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZXMgYSBhIGtleSBmcm9tIHRoZSBsb2cgYW5kIHN0b3BzIGl0IGZyb20ga2VlcGluZyB1cCBzcGFjZSBvbiB0aGUgc2NyZWVuXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGxvZyBpdGVtIHRvIGNsZWFyXG5cdCAqL1xuXHRzdGF0aWMgY2xlYXJMb2dJdGVtKGlkOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmRlbGV0ZShpZCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbGlzdCBvZiBub2RlcyB0byByZW5kZXIgd2l0aCB0aGUgZGVidWdnZXJcblx0ICogQHBhcmFtIG5vZGVzIFRoZSBuZXcgbGlzdCBvZiBub2Rlc1xuXHQgKi9cblx0c3RhdGljIHNldE5vZGVzKG5vZGVzOiBBcnJheTxHYW1lTm9kZT4pOiB2b2lkIHtcblx0XHR0aGlzLm5vZGVzID0gbm9kZXM7XG5cdH1cblxuXHQvKipcblx0ICogRHJhd3MgYSBib3ggYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGJveFxuXHQgKiBAcGFyYW0gaGFsZlNpemUgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJveFxuXHQgKiBAcGFyYW0gZmlsbGVkIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdGhlIGJveCBpcyBmaWxsZWRcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgYm94IHRvIGRyYXdcblx0ICovXG5cdHN0YXRpYyBkcmF3Qm94KGNlbnRlcjogVmVjMiwgaGFsZlNpemU6IFZlYzIsIGZpbGxlZDogYm9vbGVhbiwgY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0bGV0IGFscGhhID0gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGE7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBjb2xvci5hO1xuXG5cdFx0aWYoZmlsbGVkKXtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsUmVjdChjZW50ZXIueCAtIGhhbGZTaXplLngsIGNlbnRlci55IC0gaGFsZlNpemUueSwgaGFsZlNpemUueCoyLCBoYWxmU2l6ZS55KjIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgbGluZVdpZHRoID0gMjtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVJlY3QoY2VudGVyLnggLSBoYWxmU2l6ZS54LCBjZW50ZXIueSAtIGhhbGZTaXplLnksIGhhbGZTaXplLngqMiwgaGFsZlNpemUueSoyKTtcblx0XHR9XG5cblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgY2lyY2xlIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgYm94XG5cdCAqIEBwYXJhbSBmaWxsZWQgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgY2lyY2xlIGlzIGZpbGxlZFxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBjaXJjbGVcblx0ICovXG5cdHN0YXRpYyBkcmF3Q2lyY2xlKGNlbnRlcjogVmVjMiwgcmFkaXVzOiBudW1iZXIsIGZpbGxlZDogYm9vbGVhbiwgY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0bGV0IGFscGhhID0gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGE7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBjb2xvci5hO1xuXG5cdFx0aWYoZmlsbGVkKXtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBsaW5lV2lkdGggPSAyO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5hcmMoY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHJheSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBmcm9tIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgcmF5XG5cdCAqIEBwYXJhbSB0byBUaGUgZW5kaW5nIHBvc2l0aW9uIG9mIHRoZSByYXlcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgcmF5XG5cdCAqL1xuXHRzdGF0aWMgZHJhd1JheShmcm9tOiBWZWMyLCB0bzogVmVjMiwgY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gMjtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XG5cblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVUbyh0by54LCB0by55KTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHBvaW50IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cblx0ICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gb2YgdGhlIHBvaW50XG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHBvaW50XG5cdCAqL1xuXHRzdGF0aWMgZHJhd1BvaW50KHBvczogVmVjMiwgY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0bGV0IHBvaW50U2l6ZSA9IDY7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsUmVjdChwb3MueCAtIHBvaW50U2l6ZS8yLCBwb3MueSAtIHBvaW50U2l6ZS8yLCBwb2ludFNpemUsIHBvaW50U2l6ZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZGVmYXVsdCByZW5kZXJpbmcgY29sb3IgZm9yIHRleHQgZm9yIHRoZSBkZWJ1Z2dlclxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIHRvIHJlbmRlciB0aGUgdGV4dFxuXHQgKi9cblx0c3RhdGljIHNldERlZmF1bHRUZXh0Q29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy5kZWZhdWx0VGV4dENvbG9yID0gY29sb3I7XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybXMgYW55IG5lY2Vzc2FyeSBzZXR1cCBvcGVyYXRpb25zIG9uIHRoZSBEZWJ1ZyBjYW52YXNcblx0ICogQHBhcmFtIGNhbnZhcyBUaGUgZGVidWcgY2FudmFzXG5cdCAqIEBwYXJhbSB3aWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSBoZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBjYW52YXNcblx0ICogQHJldHVybnMgVGhlIHJlbmRlcmluZyBjb250ZXh0IGV4dHJhY3RlZCBmcm9tIHRoZSBjYW52YXNcblx0ICovXG5cdHN0YXRpYyBpbml0aWFsaXplRGVidWdDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFxuXHRcdHRoaXMuZGVidWdDYW52YXNTaXplID0gbmV3IFZlYzIod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dDtcblx0fVxuXG5cdC8qKiBDbGVhcnMgdGhlIGRlYnVnIGNhbnZhcyAqL1xuXHRzdGF0aWMgY2xlYXJDYW52YXMoKTogdm9pZCB7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuZGVidWdDYW52YXNTaXplLngsIHRoaXMuZGVidWdDYW52YXNTaXplLnkpO1xuXHR9XG5cblx0LyoqIFJlbmRlcnMgdGhlIHRleHQgYW5kIG5vZGVzIHNlbnQgdG8gdGhlIERlYnVnIHN5c3RlbSAqL1xuXHRzdGF0aWMgcmVuZGVyKCk6IHZvaWQge1xuXHRcdHRoaXMucmVuZGVyVGV4dCgpO1xuXHRcdHRoaXMucmVuZGVyTm9kZXMoKTtcblx0fVxuXG5cdC8qKiBSZW5kZXJzIHRoZSB0ZXh0IHNlbnQgdG8gdGhlIERlYnVnIGNhbnZhcyAqL1xuXHRzdGF0aWMgcmVuZGVyVGV4dCgpOiB2b2lkIHtcblx0XHRsZXQgeSA9IDIwO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZvbnQgPSBcIjIwcHggQXJpYWxcIjtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmRlZmF1bHRUZXh0Q29sb3IudG9TdHJpbmcoKTtcblxuXHRcdC8vIERyYXcgYWxsIG9mIHRoZSB0ZXh0XG5cdFx0dGhpcy5sb2dNZXNzYWdlcy5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFRleHQodGhpcy5sb2dNZXNzYWdlcy5nZXQoa2V5KSwgMTAsIHkpXG5cdFx0XHR5ICs9IDMwO1x0XG5cdFx0fSk7XG5cdH1cblxuXHQvKiogUmVuZGVycyB0aGUgbm9kZXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBkZWJ1ZyBjYW52YXMgKi9cblx0c3RhdGljIHJlbmRlck5vZGVzKCk6IHZvaWQge1xuXHRcdGlmKHRoaXMubm9kZXMpe1xuXHRcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuXHRcdFx0XHRub2RlLmRlYnVnUmVuZGVyKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0cyBleHRlbmRzIE9iamVjdCB7XG4gICAgLy8gVGhlIGZwcyBvZiB0aGUgZ2FtZS5cbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2ZnBzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE5VTV9QT0lOVFM6IG51bWJlciA9IDYwO1xuICAgIHByaXZhdGUgc3RhdGljIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgIHByaXZhdGUgc3RhdGljIENBTlZBU19XSURUSDogbnVtYmVyID0gMzAwO1xuICAgIHByaXZhdGUgc3RhdGljIENBTlZBU19IRUlHSFQ6IG51bWJlciA9IDMwMDtcbiAgICBwcml2YXRlIHN0YXRpYyBzdGF0c0RpdjogSFRNTERpdkVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JhcGhDaG9pY2VzOiBIVE1MU2VsZWN0RWxlbWVudDtcblxuICAgIC8vIFF1YWR0cmVlIHN0YXRzXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldkNsZWFyVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dDbGVhclRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHQ2xlYXJUaW1lOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2RmlsbFRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIFNHRmlsbFRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHRmlsbFRpbWU6IG51bWJlcjtcblxuICAgIHByaXZhdGUgc3RhdGljIHByZXZVcGRhdGVUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBTR1VwZGF0ZVRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHVXBkYXRlVGltZTogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldlF1ZXJ5VGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dRdWVyeVRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHUXVlcnlUaW1lOiBudW1iZXI7XG5cbiAgICBzdGF0aWMgaW5pdFN0YXRzKCk6IHZvaWQge1xuICAgICAgICBsZXQgY2FudmFzID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHMtY2FudmFzXCIpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLkNBTlZBU19XSURUSDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuQ0FOVkFTX0hFSUdIVDtcbiAgICAgICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIHRoaXMuc3RhdHNEaXYgPSA8SFRNTERpdkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1kaXNwbGF5XCIpO1xuXG4gICAgICAgIHRoaXMucHJldmZwcyA9IG5ldyBBcnJheSgpO1xuXG4gICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5TR0NsZWFyVGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5hdmdTR0NsZWFyVGltZSA9IDA7XG5cbiAgICAgICAgdGhpcy5wcmV2RmlsbFRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuU0dGaWxsVGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5hdmdTR0ZpbGxUaW1lID0gMDtcblxuICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5hdmdTR1VwZGF0ZVRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5hdmdTR1F1ZXJ5VGltZSA9IDA7XG5cbiAgICAgICAgbGV0IGNsZWFyVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBjbGVhclRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ2NsZWFyXCIpO1xuICAgICAgICBsZXQgZmlsbFRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgZmlsbFRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ2ZpbGxcIik7XG4gICAgICAgIGxldCB1cGRhdGVUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHVwZGF0ZVRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ3VwZGF0ZVwiKTtcbiAgICAgICAgbGV0IHF1ZXJ5VGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBxdWVyeVRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ3F1ZXJ5XCIpO1xuICAgICAgICBsZXQgYnIxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgICBsZXQgYnIyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgICBsZXQgYnIzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuXG4gICAgICAgIHRoaXMuc3RhdHNEaXYuYXBwZW5kKGNsZWFyVGltZSwgYnIxLCBmaWxsVGltZSwgYnIyLCB1cGRhdGVUaW1lLCBicjMsIHF1ZXJ5VGltZSk7XG5cbiAgICAgICAgdGhpcy5ncmFwaENob2ljZXMgPSA8SFRNTFNlbGVjdEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjaGFydC1vcHRpb25cIik7XG4gICAgICAgIGxldCBvcHRpb24xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgb3B0aW9uMS52YWx1ZSA9IFwicHJldmZwc1wiO1xuICAgICAgICBvcHRpb24xLmxhYmVsID0gXCJGUFNcIjtcbiAgICAgICAgbGV0IG9wdGlvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24yLnZhbHVlID0gXCJwcmV2Q2xlYXJUaW1lc1wiO1xuICAgICAgICBvcHRpb24yLmxhYmVsID0gXCJDbGVhciBUaW1lXCI7XG4gICAgICAgIGxldCBvcHRpb24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgb3B0aW9uMy52YWx1ZSA9IFwicHJldkZpbGxUaW1lc1wiO1xuICAgICAgICBvcHRpb24zLmxhYmVsID0gXCJGaWxsIHRpbWVcIjtcbiAgICAgICAgbGV0IG9wdGlvbjQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb240LnZhbHVlID0gXCJwcmV2VXBkYXRlVGltZXNcIjtcbiAgICAgICAgb3B0aW9uNC5sYWJlbCA9IFwiVXBkYXRlIHRpbWVcIjtcbiAgICAgICAgbGV0IG9wdGlvbjUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb241LnZhbHVlID0gXCJwcmV2UXVlcnlUaW1lc1wiO1xuICAgICAgICBvcHRpb241LmxhYmVsID0gXCJRdWVyeSBUaW1lXCI7XG4gICAgICAgIGxldCBvcHRpb25BbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb25BbGwudmFsdWUgPSBcImFsbFwiO1xuICAgICAgICBvcHRpb25BbGwubGFiZWwgPSBcIkFsbFwiO1xuICAgICAgICB0aGlzLmdyYXBoQ2hvaWNlcy5hcHBlbmQob3B0aW9uMSwgb3B0aW9uMiwgb3B0aW9uMywgb3B0aW9uNCwgb3B0aW9uNSwgb3B0aW9uQWxsKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlRlBTKGZwczogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMucHJldmZwcy5wdXNoKGZwcyk7XG4gICAgICAgIGlmKHRoaXMucHJldmZwcy5sZW5ndGggPiBTdGF0cy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgIHRoaXMucHJldmZwcy5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzLnB1c2godGhpcy5hdmdTR0NsZWFyVGltZSk7XG4gICAgICAgICAgICBpZih0aGlzLnByZXZDbGVhclRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMucHVzaCh0aGlzLmF2Z1NHRmlsbFRpbWUpO1xuICAgICAgICAgICAgaWYodGhpcy5wcmV2RmlsbFRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2RmlsbFRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMucHVzaCh0aGlzLmF2Z1NHVXBkYXRlVGltZSk7XG4gICAgICAgICAgICBpZih0aGlzLnByZXZVcGRhdGVUaW1lcy5sZW5ndGggPiB0aGlzLk5VTV9QT0lOVFMpe1xuICAgICAgICAgICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzLnB1c2godGhpcy5hdmdTR1F1ZXJ5VGltZSk7XG4gICAgICAgICAgICBpZih0aGlzLnByZXZRdWVyeVRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVTR1N0YXRzKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvZyhrZXk6IHN0cmluZywgZGF0YTogYW55KTogdm9pZCB7XG4gICAgICAgIGlmKGtleSA9PT0gXCJzZ2NsZWFyXCIpe1xuICAgICAgICAgICAgdGhpcy5TR0NsZWFyVGltZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDEwMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5TR0NsZWFyVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGtleSA9PT0gXCJzZ2ZpbGxcIil7XG4gICAgICAgICAgICB0aGlzLlNHRmlsbFRpbWVzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICBpZih0aGlzLlNHRmlsbFRpbWVzLmxlbmd0aCA+IDEwMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNndXBkYXRlXCIpe1xuICAgICAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICBpZih0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMTAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGtleSA9PT0gXCJzZ3F1ZXJ5XCIpe1xuICAgICAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDEwMDApe1xuICAgICAgICAgICAgICAgIHRoaXMuU0dRdWVyeVRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHN0YXRpYyByZW5kZXIoKTogdm9pZCB7XG4gICAgICAgIC8vIERpc3BsYXkgc3RhdHNcbiAgICAgICAgdGhpcy5kcmF3Q2hhcnRzKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGRyYXdDaGFydHMoKXtcbiAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuQ0FOVkFTX1dJRFRILCB0aGlzLkNBTlZBU19IRUlHSFQpO1xuXG4gICAgICAgIGxldCBwYXJhbVN0cmluZyA9IHRoaXMuZ3JhcGhDaG9pY2VzLnZhbHVlO1xuXG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZmcHNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZmcHM7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5CTFVFLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZDbGVhclRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2Q2xlYXJUaW1lcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLlJFRC50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2RmlsbFRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2RmlsbFRpbWVzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuR1JFRU4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldlVwZGF0ZVRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2VXBkYXRlVGltZXM7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5DWUFOLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZRdWVyeVRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2UXVlcnlUaW1lcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLk9SQU5HRS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBkcmF3Q2hhcnQocGFyYW06IEFycmF5PG51bWJlcj4sIGNvbG9yOiBzdHJpbmcpe1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IENvbG9yLkJMQUNLLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMTAsIDEwKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygxMCwgdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTApO1xuICAgICAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5DQU5WQVNfV0lEVEggLSAxMCwgdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTApO1xuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4KC4uLnBhcmFtKTtcbiAgICAgICAgbGV0IHByZXZYID0gMTA7XG4gICAgICAgIGxldCBwcmV2WSA9IHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwIC0gcGFyYW1bMF0vbWF4Kih0aGlzLkNBTlZBU19IRUlHSFQtMjApO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBwYXJhbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgZnBzID0gcGFyYW1baV07XG4gICAgICAgICAgICBsZXQgeCA9IDEwICsgaSoodGhpcy5DQU5WQVNfV0lEVEggLSAyMCkvdGhpcy5OVU1fUE9JTlRTO1xuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCAtIGZwcy9tYXgqKHRoaXMuQ0FOVkFTX0hFSUdIVC0yMClcbiAgICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5jdHgubW92ZVRvKHByZXZYLCBwcmV2WSk7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICBwcmV2WCA9IHg7XG4gICAgICAgICAgICBwcmV2WSA9IHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlU0dTdGF0cygpe1xuICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMuYXZnU0dDbGVhclRpbWUgPSB0aGlzLlNHQ2xlYXJUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dDbGVhclRpbWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLmF2Z1NHRmlsbFRpbWUgPSB0aGlzLlNHRmlsbFRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgIHRoaXMuYXZnU0dVcGRhdGVUaW1lID0gdGhpcy5TR1VwZGF0ZVRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5hdmdTR1F1ZXJ5VGltZSA9IHRoaXMuU0dRdWVyeVRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ2NsZWFyXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIGNsZWFyIHRpbWU6IFwiICsgdGhpcy5hdmdTR0NsZWFyVGltZTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ2ZpbGxcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgZmlsbCB0aW1lOiBcIiArIHRoaXMuYXZnU0dGaWxsVGltZTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ3VwZGF0ZVwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyB1cGRhdGUgdGltZTogXCIgKyB0aGlzLmF2Z1NHVXBkYXRlVGltZTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ3F1ZXJ5XCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIHF1ZXJ5IHRpbWU6IFwiICsgdGhpcy5hdmdTR1F1ZXJ5VGltZTtcbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4vRXZlbnRRdWV1ZVwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcblxuLyoqXG4gKiBBbiBldmVudCBlbWl0dGVyIG9iamVjdCBvdGhlciBzeXN0ZW1zIGNhbiB1c2UgdG8gaG9vayBpbnRvIHRoZSBFdmVudFF1ZXVlLlxuICogUHJvdmlkZXMgYW4gZWFzeSBpbnRlcmZhY2UgZm9yIGZpcmluZyBvZmYgZXZlbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbWl0dGVyIHtcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBFdmVudFF1ZXVlICovXG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcblxuXHQvKiogQ3JlYXRlcyBhIG5ldyBFbWl0dGVyICovXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXQgYW5kIGV2ZW50IG9mIHR5cGUgZXZlbnRUeXBlIHdpdGggdGhlIGRhdGEgcGFja2V0IGRhdGFcblx0ICogQHBhcmFtIGV2ZW50VHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBvZmZcblx0ICogQHBhcmFtIGRhdGEgQSBAcmVmZXJlbmNlW01hcF0gb3IgcmVjb3JkIGNvbnRhaW5pbmcgYW55IGRhdGEgYWJvdXQgdGhlIGV2ZW50XG5cdCAqL1xuXHRmaXJlRXZlbnQoZXZlbnRUeXBlOiBzdHJpbmcsIGRhdGE6IE1hcDxhbnk+IHwgUmVjb3JkPHN0cmluZywgYW55PiA9IG51bGwpOiB2b2lkIHtcblx0XHR0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQobmV3IEdhbWVFdmVudChldmVudFR5cGUsIGRhdGEpKTtcblx0fVxufSIsImltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL1F1ZXVlXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuL1JlY2VpdmVyXCI7XG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4vR2FtZUV2ZW50VHlwZVwiO1xuXG4vKipcbiAqIFRoZSBtYWluIGV2ZW50IHN5c3RlbSBvZiB0aGUgZ2FtZSBlbmdpbmUuXG4gKiBFdmVudHMgYXJlIHNlbnQgdG8gdGhlIEV2ZW50UXVldWUsIHdoaWNoIGhhbmRsZXMgZGlzdHJpYnV0aW9uIHRvIGFueSBzeXN0ZW1zIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgdGhvc2UgZXZlbnRzLlxuICogVGhpcyBhbGxvd3MgZm9yIGhhbmRsaW5nIG9mIGlucHV0IHdpdGhvdXQgaGF2aW5nIGNsYXNzZXMgZGlyZWN0bHkgaG9vayBpbnRvIGphdmFzY3JpcHQgZXZlbnQgaGFuZGxlcywgXG4gKiBhbmQgYWxsb3dzIG90aGVyd2lzZSBzZXBhcmF0ZSBjbGFzc2VzIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlciBjbGVhbmx5LCBzdWNoIGFzIGEgUGxheWVyIG9iamVjdCBcbiAqIHJlcXVlc3RpbmcgYSBzb3VuZCBiZSBwbGF5ZWQgYnkgdGhlIGF1ZGlvIHN5c3RlbS5cbiAqIFxuICogVGhlIGRpc3RyaWJ1dGlvbiBvZiBAcmVmZXJlbmNlW0dhbWVFdmVudF1zIGhhcHBlbnMgYXMgZm9sbG93czpcbiAqIFxuICogRXZlbnRzIGFyZSByZWNpZXZlZCB0aHJvdWdob3V0IGEgZnJhbWUgYW5kIGFyZSBxdWV1ZWQgdXAgYnkgdGhlIEV2ZW50UXVldWUuXG4gKiBBdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGZyYW1lLCBldmVudHMgYXJlIHNlbnQgb3V0IHRvIGFueSByZWNlaXZlcnMgdGhhdCBhcmUgaG9va2VkIGludG8gdGhlIGV2ZW50IHR5cGUuXG4gKiBAcmVmZXJlbmNlW1JlY2VpdmVyXXMgYXJlIHRoZW4gZnJlZSB0byBwcm9jZXNzIGV2ZW50cyBhcyB0aGV5IHNlZSBmaXQuXG4gKiBcbiAqIE92ZXJhbGwsIHRoZSBFdmVudFF1ZXVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIHNvbWV0aGluZyBzaW1pbGFyIHRvIGFuIGVtYWlsIHNlcnZlcixcbiAqIGFuZCB0aGUgQHJlZmVyZW5jZVtSZWNlaXZlcl1zIGNhbiBiZSBjb25zaWRlcmVkIGFzIHRoZSBjbGllbnQgaW5ib3hlcy5cbiAqIFxuICogU2VlIEBsaW5rKEdhbWUgUHJvZ3JhbW1pbmcgUGF0dGVybnMpKGh0dHBzOi8vZ2FtZXByb2dyYW1taW5ncGF0dGVybnMuY29tL2V2ZW50LXF1ZXVlLmh0bWwpIGZvciBtb3JlIGRpc2N1c3Npb24gb24gRXZlbnRRdWV1ZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRRdWV1ZSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEV2ZW50UXVldWUgPSBudWxsO1xuICAgIFxuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHZpc2libGUgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IE1BWF9TSVpFOiBudW1iZXI7XG4gICAgXG4gICAgLyoqIFRoZSBhY3R1YWwgcXVldWUgb2YgZXZlbnRzICovXG4gICAgcHJpdmF0ZSBxOiBRdWV1ZTxHYW1lRXZlbnQ+O1xuICAgIFxuICAgIC8qKiBUaGUgbWFwIG9mIHJlY2VpdmVycyByZWdpc3RlcmVkIGZvciBhbiBldmVudCBuYW1lICovXG5cdHByaXZhdGUgcmVjZWl2ZXJzOiBNYXA8QXJyYXk8UmVjZWl2ZXI+PjtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5NQVhfU0laRSA9IDIwMDtcbiAgICAgICAgdGhpcy5xID0gbmV3IFF1ZXVlPEdhbWVFdmVudD4odGhpcy5NQVhfU0laRSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXJzID0gbmV3IE1hcDxBcnJheTxSZWNlaXZlcj4+KCk7XG5cdH1cbiAgICBcbiAgICAvKiogUmV0cmlldmVzIHRoZSBpbnN0YW5jZSBvZiB0aGUgU2luZ2xldG9uIEV2ZW50UXVldWUgKi9cblx0c3RhdGljIGdldEluc3RhbmNlKCk6IEV2ZW50UXVldWUge1xuXHRcdGlmKHRoaXMuaW5zdGFuY2UgPT09IG51bGwpe1xuXHRcdFx0dGhpcy5pbnN0YW5jZSA9IG5ldyBFdmVudFF1ZXVlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlO1xuXHR9XG5cbiAgICAvKiogQWRkcyBhbiBldmVudCB0byB0aGUgRXZlbnRRdWV1ZS5cbiAgICAgKiBUaGlzIGlzIGV4cG9zZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIGdhbWUgZW5naW5lIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRW1pdHRlcl0gY2xhc3MgKi9cbiAgICBhZGRFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMucS5lbnF1ZXVlKGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVzIGEgcmVjZWl2ZXIgd2l0aCBhIHR5cGUgb2YgZXZlbnQuIEV2ZXJ5IHRpbWUgdGhpcyBldmVudCBhcHBlYXJzIGluIHRoZSBmdXR1cmUsXG4gICAgICogaXQgd2lsbCBiZSBnaXZlbiB0byB0aGUgcmVjZWl2ZXIgKGFuZCBhbnkgb3RoZXJzIHdhdGNoaW5nIHRoYXQgdHlwZSkuXG4gICAgICogVGhpcyBpcyBleHBvc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBnYW1lIGVuZ2luZSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW1JlY2VpdmVyXSBjbGFzc1xuICAgICAqIEBwYXJhbSByZWNlaXZlciBUaGUgZXZlbnQgcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvciB0eXBlcyBvZiBldmVudHMgdG8gc3Vic2NyaWJlIHRvXG4gICAgICovXG4gICAgc3Vic2NyaWJlKHJlY2VpdmVyOiBSZWNlaXZlciwgdHlwZTogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHZvaWQge1xuICAgICAgICBpZih0eXBlIGluc3RhbmNlb2YgQXJyYXkpe1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMgYW4gYXJyYXksIHN1YnNjcmliZSB0byBhbGwgZXZlbnQgdHlwZXNcbiAgICAgICAgICAgIGZvcihsZXQgdCBvZiB0eXBlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RlbmVyKHJlY2VpdmVyLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdGVuZXIocmVjZWl2ZXIsIHR5cGUpO1xuICAgICAgICB9XG5cdH1cblxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyB0aGUgc3BlY2lmaWVkIHJlY2VpdmVyIGZyb20gYWxsIGV2ZW50cywgb3IgZnJvbSB3aGF0ZXZlciBldmVudHMgYXJlIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIFRoZSByZWNlaXZlciB0byB1bnN1YnNjcmliZVxuICAgICAqIEBwYXJhbSBrZXlzIFRoZSBldmVudHMgdG8gdW5zdWJzY3JpYmUgZnJvbS4gSWYgbm9uZSBhcmUgcHJvdmlkZWQsIHVuc3Vic2NyaWJlIGZyb20gYWxsXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUocmVjZWl2ZXI6IFJlY2VpdmVyLCAuLi5ldmVudHM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlcnMuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgICAgICAgLy8gSWYga2V5cyB3ZXJlIHByb3ZpZGVkLCBvbmx5IGNvbnRpbnVlIGlmIHRoaXMga2V5IGlzIG9uZSBvZiB0aGVtXG4gICAgICAgICAgICBpZihldmVudHMubGVuZ3RoID4gMCAmJiBldmVudHMuaW5kZXhPZihldmVudE5hbWUpID09PSAtMSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiBvdXIgcmVjZWl2ZXIgZm9yIHRoaXMga2V5XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnJlY2VpdmVycy5nZXQoZXZlbnROYW1lKS5pbmRleE9mKHJlY2VpdmVyKTtcblxuICAgICAgICAgICAgLy8gSWYgYW4gaW5kZXggd2FzIGZvdW5kLCByZW1vdmUgdGhlIHJlY2VpdmVyXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gLTEpe1xuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2ZXJzLmdldChldmVudE5hbWUpLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVjZWl2ZXIgYW5kIHRoZSB0eXBlXG5cdHByaXZhdGUgYWRkTGlzdGVuZXIocmVjZWl2ZXI6IFJlY2VpdmVyLCB0eXBlOiBzdHJpbmcpOiB2b2lkIHtcblx0XHRpZih0aGlzLnJlY2VpdmVycy5oYXModHlwZSkpe1xuXHRcdFx0dGhpcy5yZWNlaXZlcnMuZ2V0KHR5cGUpLnB1c2gocmVjZWl2ZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnJlY2VpdmVycy5hZGQodHlwZSwgW3JlY2VpdmVyXSk7XG5cdFx0fVxuXHR9XG4gICAgXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHdoaWxlKHRoaXMucS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGVhY2ggZXZlbnRcblx0XHRcdGxldCBldmVudCA9IHRoaXMucS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIGEgcmVjZWl2ZXIgaGFzIHRoaXMgZXZlbnQgdHlwZSwgc2VuZCBpdCB0aGUgZXZlbnRcbiAgICAgICAgICAgIGlmKHRoaXMucmVjZWl2ZXJzLmhhcyhldmVudC50eXBlKSl7XG4gICAgICAgICAgICAgICAgZm9yKGxldCByZWNlaXZlciBvZiB0aGlzLnJlY2VpdmVycy5nZXQoZXZlbnQudHlwZSkpe1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5yZWNlaXZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cdFx0XHR9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIGEgcmVjZWl2ZXIgaXMgc3Vic2NyaWJlZCB0byBhbGwgZXZlbnRzLCBzZW5kIGl0IHRoZSBldmVudFxuICAgICAgICAgICAgaWYodGhpcy5yZWNlaXZlcnMuaGFzKEdhbWVFdmVudFR5cGUuQUxMKSl7XG4gICAgICAgICAgICAgICAgZm9yKGxldCByZWNlaXZlciBvZiB0aGlzLnJlY2VpdmVycy5nZXQoR2FtZUV2ZW50VHlwZS5BTEwpKXtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIlxuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW4tZ2FtZSBldmVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVFdmVudCB7XG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoZSBldmVudCAqL1xuICAgIHB1YmxpYyB0eXBlOiBzdHJpbmc7XG4gICAgLyoqIFRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgZXZlbnQgKi9cbiAgICBwdWJsaWMgZGF0YTogTWFwPGFueT47XG4gICAgLyoqIFRoZSB0aW1lIG9mIHRoZSBldmVudCBpbiBtcyAqL1xuXHRwdWJsaWMgdGltZTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHYW1lRXZlbnQuXG4gICAgICogVGhpcyBpcyBoYW5kbGVkIGltcGxpY2l0bHkgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFbWl0dGVyXSBjbGFzc1xuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBHYW1lRXZlbnRcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSBjb250YWluZWQgYnkgdGhlIEdhbWVFdmVudFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgZGF0YTogTWFwPGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbCkge1xuICAgICAgICAvLyBQYXJzZSB0aGUgZ2FtZSBldmVudCBkYXRhXG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwPGFueT4oKTtcbiAgICAgICAgfSBlbHNlIGlmICghKGRhdGEgaW5zdGFuY2VvZiBNYXApKXtcbiAgICAgICAgICAgIC8vIGRhdGEgaXMgYSByYXcgb2JqZWN0LCB1bnBhY2tcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXA8YW55PigpO1xuICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gZGF0YSl7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmFkZChrZXksIGRhdGFba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIHR5cGUgb2YgdGhlIEdhbWVFdmVudFxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgR2FtZUV2ZW50IGlzIHRoZSBzcGVjaWZpZWQgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzVHlwZSh0eXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgR2FtZUV2ZW50IGFzIGEgc3RyaW5nXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgR2FtZUV2ZW50XG4gICAgICovXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArIFwiOiBAXCIgKyB0aGlzLnRpbWU7XG4gICAgfVxufSIsIi8vIEBpZ25vcmVQYWdlXG5cbmV4cG9ydCBlbnVtIEdhbWVFdmVudFR5cGUge1xuXHQvKipcblx0ICogTW91c2UgRG93biBldmVudC4gSGFzIGRhdGE6IHtwb3NpdGlvbjogVmVjMiAtIE1vdXNlIFBvc2l0aW9ufVxuXHQgKi9cblx0TU9VU0VfRE9XTiA9IFwibW91c2VfZG93blwiLFxuXHQvKipcblx0ICogTW91c2UgVXAgZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cblx0ICovXG5cdE1PVVNFX1VQID0gXCJtb3VzZV91cFwiLFxuXHQvKipcblx0ICogTW91c2UgTW92ZSBldmVudC4gSGFzIGRhdGE6IHtwb3NpdGlvbjogVmVjMiAtIE1vdXNlIFBvc2l0aW9ufVxuXHQgKi9cblx0TU9VU0VfTU9WRSA9IFwibW91c2VfbW92ZVwiLFxuXG5cdC8qKlxuXHQgKiBLZXkgRG93biBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZyAtIFRoZSBrZXkgdGhhdCBpcyBkb3dufVxuXHQgKi9cblx0S0VZX0RPV04gPSBcImtleV9kb3duXCIsXG5cblx0LyoqXG5cdCAqIEtleSBVcCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZyAtIFRoZSBrZXkgdGhhdCBpcyB1cH1cblx0ICovXG5cdEtFWV9VUCA9IFwia2V5X3VwXCIsXG5cblx0LyoqXG5cdCAqIENhbnZhcyBCbHVyIGV2ZW50LiBIYXMgZGF0YToge31cblx0ICovXG5cdENBTlZBU19CTFVSID0gXCJjYW52YXNfYmx1clwiLFxuXG5cdC8qKlxuXHQgKiBNb3VzZSB3aGVlbCB1cCBldmVudC4gSGFzIGRhdGE6IHt9XG5cdCAqL1xuXHRXSEVFTF9VUCA9IFwid2hlZWxfdXBcIixcblxuXHQvKipcblx0ICogTW91c2Ugd2hlZWwgZG93biBldmVudC4gSGFzIGRhdGE6IHt9XG5cdCAqL1xuXHRXSEVFTF9ET1dOID0gXCJ3aGVlbF9kb3duXCIsXG5cblx0LyoqXG5cdCAqIFN0YXJ0IFJlY29yZGluZyBldmVudC4gSGFzIGRhdGE6IHtyZWNvcmRpbmc6IEFic3RyYWN0UmVjb3JkaW5nfVxuXHQgKi9cblx0U1RBUlRfUkVDT1JESU5HID0gXCJzdGFydF9yZWNvcmRpbmdcIixcblxuXHQvKipcblx0ICogU3RvcCBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0U1RPUF9SRUNPUkRJTkcgPSBcInN0b3BfcmVjb3JkaW5nXCIsXG5cdFxuXHQvKipcblx0ICogUGxheSBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0UExBWV9SRUNPUkRJTkcgPSBcInBsYXlfcmVjb3JkaW5nXCIsXG5cblx0LyoqXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4gfVxuXHQgKi9cblx0UExBWV9TT1VORCA9IFwicGxheV9zb3VuZFwiLFxuXG5cdC8qKlxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nfVxuXHQgKi9cblx0U1RPUF9TT1VORCA9IFwic3RvcF9zb3VuZFwiLFxuXG5cdC8qKlxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlIH1cblx0ICovXG4gXHRQTEFZX1NGWCA9IFwicGxheV9zZnhcIixcblxuIFx0LyoqXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4gfVxuXHQgKi9cbiAgXHRQTEFZX01VU0lDID0gXCJwbGF5X211c2ljXCIsXG5cblx0LyoqXG5cdCAqIE11dGUgYXVkaW8gY2hhbm5lbCBldmVudC4gSGFzIGRhdGE6IHtjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlfVxuXHQgKi9cblx0TVVURV9DSEFOTkVMID0gXCJtdXRlX2NoYW5uZWxcIixcblxuXHQvKipcblx0ICogVW5tdXRlIGF1ZGlvIGNoYW5uZWwgZXZlbnQuIEhhcyBkYXRhOiB7Y2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZX1cblx0ICovXG5cdFVOTVVURV9DSEFOTkVMID0gXCJ1bm11dGVfY2hhbm5lbFwiLFxuXG5cdC8qKlxuXHQgKiBFbmNvbXBhc3NlcyBhbGwgZXZlbnQgdHlwZXMuIFVzZWQgZm9yIHJlY2VpdmVycyBvbmx5LlxuXHQgKi9cblx0QUxMID0gXCJhbGxcIixcblxuXHQvKiogXG5cdCAqIERpc2FibGVzIHJldmVpdmluZyBpbnB1dCBmcm9tIHRoZSB1c2VyIGZvciB0aGUgc3BlY2lmaWVkIGlucHV0cy4gSGFzIGRhdGE6IHtpbnB1dHM6IElucHV0SGFubGRlcnNbXX1cblx0ICovXG5cdERJU0FCTEVfVVNFUl9JTlBVVCA9IFwiZGlzYWJsZV91c2VyX2lucHV0XCIsXG5cblx0LyoqIFxuXHQgKiBFbmFibGVzIHJlY2VpdmluZyBpbnB1dCBmcm9tIHRoZSB1c2VyIGZvciB0aGUgc3BlY2lmaWVkIGlucHV0cy4gSGFzIGRhdGE6IHtpbnB1dHM6IElucHV0SGFuZGxlcnNbXX1cblx0ICovXG5cdEVOQUJMRV9VU0VSX0lOUFVUID0gXCJlbmFibGVfdXNlcl9pbnB1dFwiLFxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VycyBhIHNjZW5lIGNoYW5nZS4gSGFzIGRhdGE6IHtzY2VuZTogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQgZXh0ZW5kcyBTY2VuZSwgaW5pdDogUmVjb3JkPHN0cmluZywgYW55Pn1cblx0ICovXG5cdENIQU5HRV9TQ0VORSA9IFwiY2hhbmdlX3NjZW5lXCJcbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9RdWV1ZVwiO1xuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4vRXZlbnRRdWV1ZVwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcblxuLyoqXG4gKiBSZWNlaXZlcyBzdWJzY3JpYmVkIGV2ZW50cyBmcm9tIHRoZSBFdmVudFF1ZXVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNlaXZlciB7XG5cdC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHRoaXMgUmVjZWl2ZXIgY2FuIGhvbGQgYXQgb25lIHRpbWUgKi9cblx0cmVhZG9ubHkgTUFYX1NJWkU6IG51bWJlcjtcblxuXHQvKiogVGhlIGluYm94IG9mIHRoZSBSZWNlaXZlciAqL1xuXHRwcml2YXRlIHE6IFF1ZXVlPEdhbWVFdmVudD47XG5cblx0LyoqIENyZWF0ZXMgYSBuZXcgUmVjZWl2ZXIgKi9cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLk1BWF9TSVpFID0gMjAwO1xuICAgICAgICB0aGlzLnEgPSBuZXcgUXVldWUodGhpcy5NQVhfU0laRSk7XG5cdH1cblxuXHRkZXN0cm95KCl7XG5cdFx0RXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpLnVuc3Vic2NyaWJlKHRoaXMpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkcyB0aGVzZSB0eXBlcyBvZiBldmVudHMgdG8gdGhpcyByZWNlaXZlcidzIHF1ZXVlIGV2ZXJ5IHVwZGF0ZS5cblx0ICogQHBhcmFtIGV2ZW50VHlwZXMgVGhlIHR5cGVzIG9mIGV2ZW50cyB0aGlzIHJlY2VpdmVyIHdpbGwgYmUgc3Vic2NyaWJlZCB0b1xuXHQgKi9cblx0c3Vic2NyaWJlKGV2ZW50VHlwZXM6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcblx0XHRFdmVudFF1ZXVlLmdldEluc3RhbmNlKCkuc3Vic2NyaWJlKHRoaXMsIGV2ZW50VHlwZXMpO1xuXHRcdHRoaXMucS5jbGVhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gZXZlbnQgdG8gdGhlIHF1ZXVlIG9mIHRoaXMgcmVjaWV2ZXIuIFRoaXMgaXMgdXNlZCBieSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSB0byBkaXN0cmlidXRlIGV2ZW50c1xuXHQgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHJlY2VpdmVcblx0ICovXG5cdHJlY2VpdmUoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuXHRcdHRyeXtcblx0XHR0aGlzLnEuZW5xdWV1ZShldmVudCk7XG5cdFx0fSBjYXRjaChlKXtcblx0XHRcdGNvbnNvbGUud2FybihcIlJlY2VpdmVyIG92ZXJmbG93IGZvciBldmVudCBcIiArIGV2ZW50LnRvU3RyaW5nKCkpO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBuZXh0IGV2ZW50IGZyb20gdGhlIHJlY2VpdmVyJ3MgcXVldWVcblx0ICogQHJldHVybnMgVGhlIG5leHQgR2FtZUV2ZW50XG5cdCAqL1xuXHRnZXROZXh0RXZlbnQoKTogR2FtZUV2ZW50IHtcblx0XHRyZXR1cm4gdGhpcy5xLmRlcXVldWUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMb29rcyBhdCB0aGUgbmV4dCBldmVudCBpbiB0aGUgcmVjZWl2ZXIncyBxdWV1ZSwgYnV0IGRvZXNuJ3QgcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXVlXG5cdCAqIEByZXR1cm5zIFRoZSBuZXh0IEdhbWVFdmVudFxuXHQgKi9cblx0cGVla05leHRFdmVudCgpOiBHYW1lRXZlbnQge1xuXHRcdHJldHVybiB0aGlzLnEucGVla05leHQoKVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVjZWl2ZXIgaGFzIGFueSBldmVudHMgaW4gaXRzIHF1ZXVlXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbm90aGVyIGV2ZW50LCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGhhc05leHRFdmVudCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5xLmhhc0l0ZW1zKCk7XG5cdH1cblxuXHQvKipcblx0ICogSWdub3JlIGFsbCBldmVudHMgdGhpcyBmcmFtZVxuXHQgKi9cblx0aWdub3JlRXZlbnRzKCk6IHZvaWQge1xuXHRcdHRoaXMucS5jbGVhcigpO1xuXHR9XG59IiwiaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcblxuLyoqXG4gKiBSZWNlaXZlcyBpbnB1dCBldmVudHMgZnJvbSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSBhbmQgYWxsb3dzIGZvciBlYXN5IGFjY2VzcyBvZiBpbmZvcm1hdGlvbiBhYm91dCBpbnB1dCBieSBvdGhlciBzeXN0ZW1zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0IHtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQcmVzc2VkOiBib29sZWFuO1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZUp1c3RQcmVzc2VkOiBib29sZWFuO1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZUJ1dHRvblByZXNzZWQ6IG51bWJlcjtcblxuXHRwcml2YXRlIHN0YXRpYyBrZXlKdXN0UHJlc3NlZDogTWFwPGJvb2xlYW4+O1xuXHRwcml2YXRlIHN0YXRpYyBrZXlQcmVzc2VkOiBNYXA8Ym9vbGVhbj47XG5cblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQb3NpdGlvbjogVmVjMjtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQcmVzc1Bvc2l0aW9uOiBWZWMyO1xuXG5cdHByaXZhdGUgc3RhdGljIHNjcm9sbERpcmVjdGlvbjogbnVtYmVyO1xuXHRwcml2YXRlIHN0YXRpYyBqdXN0U2Nyb2xsZWQ6IGJvb2xlYW47XG5cblx0cHJpdmF0ZSBzdGF0aWMgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcblx0cHJpdmF0ZSBzdGF0aWMgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXHRwcml2YXRlIHN0YXRpYyB2aWV3cG9ydDogVmlld3BvcnQ7XG5cblx0cHJpdmF0ZSBzdGF0aWMga2V5TWFwOiBNYXA8QXJyYXk8c3RyaW5nPj47XG5cblx0cHJpdmF0ZSBzdGF0aWMga2V5c0Rpc2FibGVkOiBib29sZWFuO1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZURpc2FibGVkOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgSW5wdXQgb2JqZWN0XG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBBIHJlZmVyZW5jZSB0byB0aGUgdmlld3BvcnQgb2YgdGhlIGdhbWVcblx0ICovXG5cdHN0YXRpYyBpbml0aWFsaXplKHZpZXdwb3J0OiBWaWV3cG9ydCwga2V5TWFwOiBBcnJheTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pikge1xuXHRcdElucHV0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XG5cdFx0SW5wdXQubW91c2VQcmVzc2VkID0gZmFsc2U7XG5cdFx0SW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IGZhbHNlO1xuXHRcdElucHV0LnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQgPSBuZXcgTWFwPGJvb2xlYW4+KCk7XG5cdFx0SW5wdXQua2V5UHJlc3NlZCA9IG5ldyBNYXA8Ym9vbGVhbj4oKTtcblx0XHRJbnB1dC5tb3VzZVBvc2l0aW9uID0gbmV3IFZlYzIoMCwgMCk7XG5cdFx0SW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uID0gbmV3IFZlYzIoMCwgMCk7XG5cdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcblx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gZmFsc2U7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBrZXltYXBcblx0XHRJbnB1dC5rZXlNYXAgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBBZGQgYWxsIGtleXMgdG8gdGhlIGtleW1hcFxuXHRcdGZvciAobGV0IGVudHJ5IGluIGtleU1hcCkge1xuXHRcdFx0bGV0IG5hbWUgPSBrZXlNYXBbZW50cnldLm5hbWU7XG5cdFx0XHRsZXQga2V5cyA9IGtleU1hcFtlbnRyeV0ua2V5cztcblx0XHRcdElucHV0LmtleU1hcC5hZGQobmFtZSwga2V5cyk7XG5cdFx0fVxuXG5cdFx0SW5wdXQuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcblx0XHQvLyBTdWJzY3JpYmUgdG8gYWxsIGlucHV0IGV2ZW50c1xuXHRcdElucHV0LmV2ZW50UXVldWUuc3Vic2NyaWJlKElucHV0LnJlY2VpdmVyLCBbR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOLCBHYW1lRXZlbnRUeXBlLk1PVVNFX1VQLCBHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsXG5cdFx0R2FtZUV2ZW50VHlwZS5LRVlfRE9XTiwgR2FtZUV2ZW50VHlwZS5LRVlfVVAsIEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIsIEdhbWVFdmVudFR5cGUuV0hFRUxfVVAsIEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTl0pO1xuXHR9XG5cblx0c3RhdGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIFJlc2V0IHRoZSBqdXN0UHJlc3NlZCB2YWx1ZXMgdG8gZmFsc2Vcblx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gZmFsc2U7XG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XG5cdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gZmFsc2U7XG5cdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcblxuXHRcdHdoaWxlIChJbnB1dC5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xuXHRcdFx0bGV0IGV2ZW50ID0gSW5wdXQucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XG5cblx0XHRcdC8vIEhhbmRsZSBlYWNoIGV2ZW50IHR5cGVcblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04pIHtcblx0XHRcdFx0SW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IHRydWU7XG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NlZCA9IHRydWU7XG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbiA9IGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIik7XG5cdFx0XHRcdElucHV0Lm1vdXNlQnV0dG9uUHJlc3NlZCA9IGV2ZW50LmRhdGEuZ2V0KFwiYnV0dG9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NT1VTRV9VUCkge1xuXHRcdFx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSkge1xuXHRcdFx0XHRJbnB1dC5tb3VzZVBvc2l0aW9uID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuS0VZX0RPV04pIHtcblx0XHRcdFx0bGV0IGtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xuXHRcdFx0XHQvLyBIYW5kbGUgc3BhY2UgYmFyXG5cdFx0XHRcdGlmIChrZXkgPT09IFwiIFwiKSB7XG5cdFx0XHRcdFx0a2V5ID0gXCJzcGFjZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghSW5wdXQua2V5UHJlc3NlZC5nZXQoa2V5KSkge1xuXHRcdFx0XHRcdElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIHRydWUpO1xuXHRcdFx0XHRcdElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuS0VZX1VQKSB7XG5cdFx0XHRcdGxldCBrZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHNwYWNlIGJhclxuXHRcdFx0XHRpZiAoa2V5ID09PSBcIiBcIikge1xuXHRcdFx0XHRcdGtleSA9IFwic3BhY2VcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIpIHtcblx0XHRcdFx0SW5wdXQuY2xlYXJLZXlQcmVzc2VzKClcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuV0hFRUxfVVApIHtcblx0XHRcdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gLTE7XG5cdFx0XHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTikge1xuXHRcdFx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAxO1xuXHRcdFx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGNsZWFyS2V5UHJlc3NlcygpOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgZmFsc2UpKTtcblx0XHRJbnB1dC5rZXlQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGtleSB3YXMgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cblx0ICogSWYgdGhlIGtleSBpcyBzdGlsbCBwcmVzc2VkIGZyb20gbGFzdCBmcmFtZSBhbmQgd2Fzbid0IHJlLXByZXNzZWQsIElucHV0IHdpbGwgcmV0dXJuIGZhbHNlLlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXlcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzS2V5SnVzdFByZXNzZWQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZiAoSW5wdXQua2V5SnVzdFByZXNzZWQuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5nZXQoa2V5KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBrZXlzIHRoYXQgYXJlIG5ld2x5IHByZXNzZWQgSW5wdXQgZnJhbWUuXG5cdCAqIElmIGEga2V5IGlzIHN0aWxsIHByZXNzZWQgZnJvbSBsYXN0IGZyYW1lIGFuZCB3YXNuJ3QgcmUtcHJlc3NlZCwgaXQgd2lsbCBub3QgYmUgaW4gSW5wdXQgbGlzdC5cblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBuZXdseSBwcmVzc2VkIGtleXMuXG5cdCAqL1xuXHRzdGF0aWMgZ2V0S2V5c0p1c3RQcmVzc2VkKCk6IEFycmF5PHN0cmluZz4ge1xuXHRcdGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBbXTtcblxuXHRcdGxldCBrZXlzID0gQXJyYXk8c3RyaW5nPigpO1xuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdGlmIChJbnB1dC5rZXlKdXN0UHJlc3NlZC5nZXQoa2V5KSkge1xuXHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4ga2V5cztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEga2V5IGlzIGJlaW5nIHByZXNzZWQuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleVxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXkgaXMgY3VycmVudGx5IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzS2V5UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcblxuXHRcdGlmIChJbnB1dC5rZXlQcmVzc2VkLmhhcyhrZXkpKSB7XG5cdFx0XHRyZXR1cm4gSW5wdXQua2V5UHJlc3NlZC5nZXQoa2V5KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoYW5nZXMgdGhlIGJpbmRpbmcgb2YgYW4gaW5wdXQgbmFtZSB0byBrZXlzXG5cdCAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XG5cdCAqIEBwYXJhbSBrZXlzIFRoZSBjb3JyZXNwb25kaW5nIGtleXNcblx0ICovXG5cdHN0YXRpYyBjaGFuZ2VLZXlCaW5kaW5nKGlucHV0TmFtZTogc3RyaW5nLCBrZXlzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG5cdFx0SW5wdXQua2V5TWFwLnNldChpbnB1dE5hbWUsIGtleXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBhbGwga2V5IGJpbmRpbmdzXG5cdCAqL1xuXHRzdGF0aWMgY2xlYXJBbGxLZXlCaW5kaW5ncygpOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlNYXAuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGlucHV0IHdhcyBqdXN0IHByZXNzZWQgdGhpcyBmcmFtZVxuXHQgKiBAcGFyYW0gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnB1dCB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc0p1c3RQcmVzc2VkKGlucHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0aWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKElucHV0LmtleU1hcC5oYXMoaW5wdXROYW1lKSkge1xuXHRcdFx0Y29uc3Qga2V5cyA9IElucHV0LmtleU1hcC5nZXQoaW5wdXROYW1lKTtcblx0XHRcdGxldCBqdXN0UHJlc3NlZCA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuXHRcdFx0XHRqdXN0UHJlc3NlZCA9IGp1c3RQcmVzc2VkIHx8IElucHV0LmlzS2V5SnVzdFByZXNzZWQoa2V5KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGp1c3RQcmVzc2VkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gaW5wdXQgaXMgY3VycmVudGx5IHByZXNzZWRcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgaXMgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNQcmVzc2VkKGlucHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0aWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKElucHV0LmtleU1hcC5oYXMoaW5wdXROYW1lKSkge1xuXHRcdFx0Y29uc3Qga2V5cyA9IElucHV0LmtleU1hcC5nZXQoaW5wdXROYW1lKTtcblx0XHRcdGxldCBwcmVzc2VkID0gZmFsc2U7XG5cblx0XHRcdGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG5cdFx0XHRcdHByZXNzZWQgPSBwcmVzc2VkIHx8IElucHV0LmlzS2V5UHJlc3NlZChrZXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJlc3NlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHQvKipcblx0ICogXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxuXHQgKiBAcGFyYW0gbW91c2VCdXR0b24gT3B0aW9uYWxseSBzcGVjaWZ5IHdoaWNoIG1vdXNlIGNsaWNrIHlvdSB3YW50IHRvIGtub3cgd2FzIHByZXNzZWQuIFxuXHQgKiAwIGZvciBsZWZ0IGNsaWNrLCAxIGZvciBtaWRkbGUgY2xpY2ssIDIgZm9yIHJpZ2h0IGNsaWNrLlxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtb3VzZSB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc01vdXNlSnVzdFByZXNzZWQobW91c2VCdXR0b24/OiBudW1iZXIpOiBib29sZWFuIHtcblx0XHRpZiAobW91c2VCdXR0b24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIElucHV0Lm1vdXNlSnVzdFByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQgJiYgbW91c2VCdXR0b24gPT0gdGhpcy5tb3VzZUJ1dHRvblByZXNzZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBJbnB1dC5tb3VzZUp1c3RQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBwcmVzc2VkXG5cdCAqIEBwYXJhbSBtb3VzZUJ1dHRvbiBPcHRpb25hbGx5IHNwZWNpZnkgd2hpY2ggbW91c2UgY2xpY2sgeW91IHdhbnQgdG8ga25vdyB3YXMgcHJlc3NlZC4gXG5cdCAqIDAgZm9yIGxlZnQgY2xpY2ssIDEgZm9yIG1pZGRsZSBjbGljaywgMiBmb3IgcmlnaHQgY2xpY2suXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc01vdXNlUHJlc3NlZChtb3VzZUJ1dHRvbj86IG51bWJlcik6IGJvb2xlYW4ge1xuXHRcdGlmIChtb3VzZUJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkICYmIG1vdXNlQnV0dG9uID09IHRoaXMubW91c2VCdXR0b25QcmVzc2VkO1xuXHRcdH1cblx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGUgdXNlciBzY3JvbGxlZCBvciBub3Rcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdXNlciBqdXN0IHNjcm9sbGVkIElucHV0IGZyYW1lLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBkaWRKdXN0U2Nyb2xsKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiBJbnB1dC5qdXN0U2Nyb2xsZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzY3JvbGxcblx0ICogQHJldHVybnMgLTEgaWYgdGhlIHVzZXIgc2Nyb2xsZWQgdXAsIDEgaWYgdGhleSBzY3JvbGxlZCBkb3duXG5cdCAqL1xuXHRzdGF0aWMgZ2V0U2Nyb2xsRGlyZWN0aW9uKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIElucHV0LnNjcm9sbERpcmVjdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWVyJ3MgbW91c2Vcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiBJbnB1dC5tb3VzZVBvc2l0aW9uLnNjYWxlZCgxIC8gdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXllcidzIG1vdXNlIGluIHRoZSBnYW1lIHdvcmxkLFxuXHQgKiB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHZpZXdwb3J0XG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXG5cdCAqL1xuXHRzdGF0aWMgZ2V0R2xvYmFsTW91c2VQb3NpdGlvbigpOiBWZWMyIHtcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQb3NpdGlvbi5jbG9uZSgpLnNjYWxlKDEgLyB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKS5hZGQoSW5wdXQudmlld3BvcnQuZ2V0T3JpZ2luKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXG5cdCAqL1xuXHRzdGF0aWMgZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiBJbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgbW91c2UgcHJlc3MgaW4gdGhlIGdhbWUgd29ybGQsXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbi5jbG9uZSgpLmFkZChJbnB1dC52aWV3cG9ydC5nZXRPcmlnaW4oKSk7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZXMgYWxsIGtleXByZXNzIGFuZCBtb3VzZSBjbGljayBpbnB1dHNcblx0ICovXG5cdHN0YXRpYyBkaXNhYmxlSW5wdXQoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gdHJ1ZTtcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGFsbCBrZXlwcmVzcyBhbmQgbW91c2UgY2xpY2sgaW5wdXRzXG5cdCAqL1xuXHRzdGF0aWMgZW5hYmxlSW5wdXQoKTogdm9pZCB7XG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gZmFsc2U7XG5cdFx0SW5wdXQubW91c2VEaXNhYmxlZCA9IGZhbHNlO1xuXHR9XG59IiwiaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuXG5leHBvcnQgZW51bSBJbnB1dEhhbmRsZXJzIHtcbiAgICBNT1VTRV9ET1dOID0gMCxcbiAgICBNT1VTRV9VUCA9IDEsXG4gICAgQ09OVEVYVF9NRU5VID0gMixcbiAgICBNT1VTRV9NT1ZFID0gMyxcbiAgICBLRVlfRE9XTiA9IDQsXG4gICAgS0VZX1VQID0gNSwgXG4gICAgT05fQkxVUiA9IDYsXG4gICAgT05fV0hFRUwgPSA3XG59XG5cbi8qKlxuICogSGFuZGxlcyBjb21tdW5pY2F0aW9uIHdpdGggdGhlIHdlYiBicm93c2VyIHRvIHJlY2VpdmUgYXN5bmNocm9ub3VzIGV2ZW50cyBhbmQgc2VuZCB0aGVtIHRvIHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0SGFuZGxlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XG4gICAgcHJpdmF0ZSBlbmFibGVkOiBib29sZWFuW107XG4gICAgcHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XG4gICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5wdXRIYW5kbGVyXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgZ2FtZSBjYW52YXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KXtcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IG5ldyBBcnJheTxib29sZWFuPiguLi5bdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV0pO1xuXHRcdFxuICAgICAgICBjYW52YXMub25tb3VzZWRvd24gPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VEb3duKGV2ZW50LCBjYW52YXMpO1xuICAgICAgICBjYW52YXMub25tb3VzZXVwID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlVXAoZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVDb250ZXh0TWVudTtcbiAgICAgICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlTW92ZShldmVudCwgY2FudmFzKTtcbiAgICAgICAgZG9jdW1lbnQub25rZXlkb3duID0gdGhpcy5oYW5kbGVLZXlEb3duO1xuICAgICAgICBkb2N1bWVudC5vbmtleXVwID0gdGhpcy5oYW5kbGVLZXlVcDtcbiAgICAgICAgZG9jdW1lbnQub25ibHVyID0gdGhpcy5oYW5kbGVCbHVyO1xuICAgICAgICBkb2N1bWVudC5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVCbHVyO1xuICAgICAgICBkb2N1bWVudC5vbndoZWVsID0gdGhpcy5oYW5kbGVXaGVlbDtcblxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEdhbWVFdmVudFR5cGUuRElTQUJMRV9VU0VSX0lOUFVUKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoR2FtZUV2ZW50VHlwZS5FTkFCTEVfVVNFUl9JTlBVVCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdhbWVFdmVudFR5cGUuRElTQUJMRV9VU0VSX0lOUFVUOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlSGFuZGxlcnMoZXZlbnQuZGF0YS5nZXQoXCJpbnB1dHNcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHYW1lRXZlbnRUeXBlLkVOQUJMRV9VU0VSX0lOUFVUOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVIYW5kbGVycyhldmVudC5kYXRhLmdldChcImlucHV0c1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgZXZlbnQgd2l0aCB0eXBlOiAke2V2ZW50LnR5cGV9IGNhdWdodCBpbiBJbnB1dEhhbmRsZXIudHNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBlbmFibGVIYW5kbGVycyhoYW5kbGVyczogSW5wdXRIYW5kbGVyc1tdKTogdm9pZCB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiB0aGlzLmVuYWJsZWRbaGFuZGxlcl0gPSB0cnVlKTtcbiAgICB9XG4gICAgcHVibGljIGRpc2FibGVIYW5kbGVycyhoYW5kbGVyczogSW5wdXRIYW5kbGVyc1tdKTogdm9pZCB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiB0aGlzLmVuYWJsZWRbaGFuZGxlcl0gPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZURvd24gPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWRbSW5wdXRIYW5kbGVycy5NT1VTRV9ET1dOXSkgcmV0dXJuO1xuXHRcdGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGxldCBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfRE9XTiwge3Bvc2l0aW9uOiBwb3MsIGJ1dHRvbjogYnV0dG9ufSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VVcCA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZFtJbnB1dEhhbmRsZXJzLk1PVVNFX0RPV05dKSByZXR1cm47XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfVVAsIHtwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VNb3ZlID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkW0lucHV0SGFuZGxlcnMuTU9VU0VfTU9WRV0pIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5NT1VTRV9NT1ZFLCB7cG9zaXRpb246IHBvc30pO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUtleURvd24gPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWRbSW5wdXRIYW5kbGVycy5LRVlfRE9XTl0pIHJldHVybjtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuZ2V0S2V5KGV2ZW50KTtcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5LRVlfRE9XTiwge2tleToga2V5fSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlS2V5VXAgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWRbSW5wdXRIYW5kbGVycy5LRVlfVVBdKSByZXR1cm47XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdldEtleShldmVudCk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuS0VZX1VQLCB7a2V5OiBrZXl9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVCbHVyID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZFtJbnB1dEhhbmRsZXJzLk9OX0JMVVJdKSByZXR1cm47XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIsIHt9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVDb250ZXh0TWVudSA9IChldmVudDogRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVXaGVlbCA9IChldmVudDogV2hlZWxFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZFtJbnB1dEhhbmRsZXJzLk9OX1dIRUVMXSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgbGV0IGdhbWVFdmVudDogR2FtZUV2ZW50O1xuICAgICAgICBpZihldmVudC5kZWx0YVkgPCAwKXtcbiAgICAgICAgICAgIGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5XSEVFTF9VUCwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLldIRUVMX0RPV04sIHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0S2V5KGtleUV2ZW50OiBLZXlib2FyZEV2ZW50KXtcbiAgICAgICAgcmV0dXJuIGtleUV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogVmVjMiB7XG4gICAgICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgeCA9IG1vdXNlRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgbGV0IHkgPSBtb3VzZUV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpO1xuICAgIH1cbn0iLCJpbXBvcnQge30gZnJvbSBcIi4uLy4uL2luZGV4XCI7ICAvLyBUaGlzIGltcG9ydCBhbGxvd3MgdXMgdG8gbW9kaWZ5IHRoZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgdG8gYWRkIGV4dHJhIGZ1bmN0aW9uYWxpdHlcbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgZW52aXJvbm1lbnQgb2YgdGhlIGdhbWUgZW5naW5lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudmlyb25tZW50SW5pdGlhbGl6ZXIge1xuICAgIHN0YXRpYyBzZXR1cCgpe1xuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeDogbnVtYmVyLCB5OiBudW1iZXIsIHc6IG51bWJlciwgaDogbnVtYmVyLCByOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgICAgIC8vIENsYW1wIHRoZSByYWRpdXMgYmV0d2VlbiAwIGFuZCB0aGUgbWluIG9mIHRoZSB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgIGlmKHIgPCAwKSByID0gMDtcbiAgICAgICAgICAgIGlmKHIgPiBNYXRoLm1pbih3LCBoKSkgciA9IE1hdGgubWluKHcsIGgpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHJvdW5kZWQgcmVjdFxuICAgICAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBUb3BcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyB3IC0gciwgeSk7XG4gICAgICAgICAgICB0aGlzLmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHIsIHIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIFJpZ2h0XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoLCByKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyByLCB5ICsgaCk7XG4gICAgICAgICAgICB0aGlzLmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHIsIHIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIExlZnRcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkgKyByKTtcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCwgeSwgeCArIHIsIHksIHIpXG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2VSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHIpe1xuICAgICAgICAgICAgdGhpcy5yb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByKTtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbFJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcil7XG4gICAgICAgICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xuICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XG5cbi8qKlxuICogQSBnYW1lIGxvb3Agd2l0aCBhIGZpeGVkIHVwZGF0ZSB0aW1lIGFuZCBhIHZhcmlhYmxlIHJlbmRlciB0aW1lLlxuICogRXZlcnkgZnJhbWUsIHRoZSBnYW1lIHVwZGF0ZXMgdW50aWwgYWxsIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuICogSWYgdG9vIG11Y2ggdGltZSBoYXMgcGFzc2VkLCBzdWNoIGFzIGlmIHRoZSBsYXN0IHVwZGF0ZSB3YXMgdG9vIHNsb3csIFxuICogb3IgaWYgdGhlIGJyb3dzZXIgd2FzIHB1dCBpbnRvIHRoZSBiYWNrZ3JvdW5kLCB0aGUgbG9vcCB3aWxsIHBhbmljIGFuZCBkaXNjYXJkIHRpbWUuXG4gKiBBIHJlbmRlciBoYXBwZW5zIGF0IHRoZSBlbmQgb2YgZXZlcnkgZnJhbWUuIFRoaXMgaGFwcGVucyBhcyBmYXN0IGFzIHBvc3NpYmxlIHVubGVzcyBzcGVjaWZpZWQuXG4gKiBBIGxvb3Agb2YgdGhpcyB0eXBlIGFsbG93cyBmb3IgZGV0ZXJtaW5pc3RpYyBiZWhhdmlvciAtIE5vIG1hdHRlciB3aGF0IHRoZSBmcmFtZSByYXRlIGlzLCB0aGUgdXBkYXRlIHNob3VsZCBiZWhhdmUgdGhlIHNhbWUsIFxuICogYXMgaXQgaXMgb2NjdXJpbmcgaW4gYSBmaXhlZCBpbnRlcnZhbC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRVcGRhdGVHYW1lTG9vcCBleHRlbmRzIEdhbWVMb29wIHtcblxuXHQvKiogVGhlIG1heCBhbGxvd2VkIHVwZGF0ZSBmcHMuKi9cbiAgICBwcml2YXRlIG1heFVwZGF0ZUZQUzogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgdGltZXN0ZXAgZm9yIGVhY2ggdXBkYXRlLiBUaGlzIGlzIHRoZSBkZWx0YVQgcGFzc2VkIHRvIHVwZGF0ZSBjYWxscy4gKi9cblx0cHJpdmF0ZSB1cGRhdGVUaW1lc3RlcDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBhcmUgeWV0IHRvIHNpbXVsYXRlLiAqL1xuICAgIHByaXZhdGUgZnJhbWVEZWx0YTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSB0aW1lIHdoZW4gdGhlIGxhc3QgZnJhbWUgd2FzIGRyYXduLiAqL1xuICAgIHByaXZhdGUgbGFzdEZyYW1lVGltZTogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgbWluaW11bSB0aW1lIHdlIHdhbnQgdG8gd2FpdCBiZXR3ZWVuIGdhbWUgZnJhbWVzLiAqL1xuICAgIHByaXZhdGUgbWluRnJhbWVEZWxheTogbnVtYmVyO1xuXG5cdC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGUgZ2FtZS4gKi9cblx0cHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xuXG5cdC8qKiBUaGUgYWN0dWFsIGZwcyBvZiB0aGUgZ2FtZS4gKi9cbiAgICBwcml2YXRlIGZwczogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgdGltZSBiZXR3ZWVuIGZwcyBtZWFzdXJlbWVudCB1cGRhdGVzLiAqL1xuICAgIHByaXZhdGUgZnBzVXBkYXRlSW50ZXJ2YWw6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgbGFzdCBmcHMgdXBkYXRlLiAqL1xuICAgIHByaXZhdGUgbGFzdEZwc1VwZGF0ZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZnJhbWVzIHNpbmNlIHRoZSBsYXN0IGZwcyB1cGRhdGUgd2FzIGRvbmUuICovXG4gICAgcHJpdmF0ZSBmcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaGFzIHN0YXJ0ZWQuICovXG4gICAgcHJpdmF0ZSBzdGFydGVkOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBpcyBwYXVzZWQgKi9cbiAgICBwcml2YXRlIHBhdXNlZDogYm9vbGVhbjtcbiAgICBcbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGlzIGN1cnJlbnRseSBydW5uaW5nLiAqL1xuICAgIHByaXZhdGUgcnVubmluZzogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHVwZGF0ZSBzdGVwcyB0aGlzIGl0ZXJhdGlvbiBvZiB0aGUgZ2FtZSBsb29wLiAqL1xuICAgIHByaXZhdGUgbnVtVXBkYXRlU3RlcHM6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuICAgICAgICB0aGlzLm1heFVwZGF0ZUZQUyA9IDYwO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcbiAgICAgICAgdGhpcy5mcmFtZURlbHRhID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5taW5GcmFtZURlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuZnBzID0gdGhpcy5tYXhVcGRhdGVGUFM7ICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnBzIHRvIHRoZSBtYXggYWxsb3dlZCBmcHNcbiAgICAgICAgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCA9IDEwMDA7XG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcblx0fVxuXG5cdGdldEZQUygpOiBudW1iZXIge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0LyoqXG4gICAgICogVXBkYXRlcyB0aGUgZnJhbWUgY291bnQgYW5kIHN1bSBvZiB0aW1lIGZvciB0aGUgZnJhbWVyYXRlIG9mIHRoZSBnYW1lXG4gICAgICogQHBhcmFtIHRpbWVzdGVwIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlRlBTKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZnBzID0gMC45ICogdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgKiAxMDAwIC8gKHRpbWVzdGFtcCAtIHRoaXMubGFzdEZwc1VwZGF0ZSkgKygxIC0gMC45KSAqIHRoaXMuZnBzO1xuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcblxuICAgICAgICBEZWJ1Zy5sb2coXCJmcHNcIiwgXCJGUFM6IFwiICsgdGhpcy5mcHMudG9GaXhlZCgxKSk7XG4gICAgICAgIFN0YXRzLnVwZGF0ZUZQUyh0aGlzLmZwcyk7XG4gICAgfVxuXG5cdCAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGh5c2ljcyBmcmFtZXJhdGUgb2YgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gaW5pdE1heCBUaGUgbWF4IGZyYW1lcmF0ZVxuICAgICAqL1xuICAgIHNldE1heFVwZGF0ZUZQUyhpbml0TWF4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYXhVcGRhdGVGUFMgPSBpbml0TWF4O1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXhpbXVtIHJlbmRlcmluZyBmcmFtZXJhdGVcbiAgICAgKiBAcGFyYW0gbWF4RlBTIFRoZSBtYXggZnJhbWVyYXRlXG4gICAgICovXG4gICAgc2V0TWF4RlBTKG1heEZQUzogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDEwMDAvbWF4RlBTO1xuXHR9XG5cdFxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgZ2FtZSBsb29wIHBhbmljcywgaS5lLiBpdCB0cmllcyB0byBwcm9jZXNzIHRvbyBtdWNoIHRpbWUgaW4gYW4gZW50aXJlIGZyYW1lLlxuXHQgKiBUaGlzIHdpbGwgcmVzZXQgdGhlIGFtb3VudCBvZiB0aW1lIGJhY2sgdG8gemVyby5cblx0ICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB0aW1lIHdlIGFyZSBkaXNjYXJkaW5nIGZyb20gcHJvY2Vzc2luZy5cblx0ICovXG5cdHJlc2V0RnJhbWVEZWx0YSgpIDogbnVtYmVyIHtcbiAgICAgICAgbGV0IG9sZEZyYW1lRGVsdGEgPSB0aGlzLmZyYW1lRGVsdGE7XG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XG4gICAgICAgIHJldHVybiBvbGRGcmFtZURlbHRhO1xuICAgIH1cblxuXHQvKipcbiAgICAgKiBTdGFydHMgdXAgdGhlIGdhbWUgbG9vcCBhbmQgY2FsbHMgdGhlIGZpcnN0IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAqL1xuXHRzdGFydCgpOiB2b2lkIHtcbiAgICAgICAgaWYoIXRoaXMuc3RhcnRlZCl7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHRoaXMuZG9GaXJzdEZyYW1lKHRpbWVzdGFtcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF1c2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXN1bWUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuICAgICAqIFRoZSBmaXJzdCBnYW1lIGZyYW1lIC0gaW5pdGlhbGl6ZXMgdGhlIGZpcnN0IGZyYW1lIHRpbWUgYW5kIGJlZ2lucyB0aGUgcmVuZGVyXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQgIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9kb1JlbmRlcigpO1xuXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodCkgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgYW55IHByb2Nlc3NpbmcgdGhhdCBuZWVkcyB0byBiZSBkb25lIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhbWVcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZSBvZiB0aGUgZnJhbWUgaW4gbXNcblx0ICovXG5cdHByb3RlY3RlZCBzdGFydEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Ly8gVXBkYXRlIHRoZSBhbW91bnQgb2YgdGltZSB3ZSBuZWVkIG91ciB1cGRhdGUgdG8gcHJvY2Vzc1xuXHRcdHRoaXMuZnJhbWVEZWx0YSArPSB0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcmFtZVRpbWU7XG5cblx0XHQvLyBTZXQgdGhlIG5ldyB0aW1lIG9mIHRoZSBsYXN0IGZyYW1lXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGVzdGltYXRlIG9mIHRoZSBmcmFtZXJhdGVcbiAgICAgICAgaWYodGltZXN0YW1wID4gdGhpcy5sYXN0RnBzVXBkYXRlICsgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCl7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZQUyh0aW1lc3RhbXApO1xuICAgICAgICB9XG5cblx0XHQvLyBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBmcmFtZXNcbiAgICAgICAgdGhpcy5mcmFtZSsrO1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSsrO1xuXHR9XG5cblx0LyoqXG4gICAgICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZS4gVXBkYXRlcyB1bnRpbCB0aGUgY3VycmVudCB0aW1lIGlzIHJlYWNoZWQuIFJlbmRlcnMgb25jZVxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBkb0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIElmIGEgcGF1c2Ugd2FzIGV4ZWN1dGVkLCBzdG9wIGRvaW5nIHRoZSBsb29wLlxuICAgICAgICBpZih0aGlzLnBhdXNlZCl7IFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWVzdCBhbmltYXRpb24gZnJhbWUgdG8gcHJlcGFyZSBmb3IgYW5vdGhlciB1cGRhdGUgb3IgcmVuZGVyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHQpID0+IHRoaXMuZG9GcmFtZSh0KSk7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIHRyeWluZyB0byByZW5kZXIgdG9vIHNvb24sIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmKHRpbWVzdGFtcCA8IHRoaXMubGFzdEZyYW1lVGltZSArIHRoaXMubWluRnJhbWVEZWxheSl7XG4gICAgICAgICAgICByZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEEgZnJhbWUgaXMgYWN0dWFsbHkgaGFwcGVuaW5nXG5cdFx0dGhpcy5zdGFydEZyYW1lKHRpbWVzdGFtcCk7XG5cblx0XHQvLyBVcGRhdGUgd2hpbGUgdGhlcmUgaXMgc3RpbGwgdGltZSB0byBtYWtlIHVwLiBJZiB3ZSBkbyB0b28gbWFueSB1cGRhdGUgc3RlcHMsIHBhbmljIGFuZCBleGl0IHRoZSBsb29wLlxuXHRcdHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xuXHRcdGxldCBwYW5pYyA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlKHRoaXMuZnJhbWVEZWx0YSA+PSB0aGlzLnVwZGF0ZVRpbWVzdGVwKXtcblx0XHRcdC8vIERvIGFuIHVwZGF0ZVxuXHRcdFx0dGhpcy5fZG9VcGRhdGUodGhpcy51cGRhdGVUaW1lc3RlcC8xMDAwKTtcblx0XHRcdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSB1cGRhdGUgc3RlcCB0aW1lIGZyb20gdGhlIHRpbWUgd2UgaGF2ZSB0byBwcm9jZXNzXG4gICAgICAgICAgICB0aGlzLmZyYW1lRGVsdGEgLT0gdGhpcy51cGRhdGVUaW1lc3RlcDtcblxuXHRcdFx0Ly8gSW5jcmVtZW50IHN0ZXBzIGFuZCBjaGVjayBpZiB3ZSd2ZSBkb25lIHRvbyBtYW55XG4gICAgICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzKys7XG4gICAgICAgICAgICBpZih0aGlzLm51bVVwZGF0ZVN0ZXBzID4gMTAwKXtcbiAgICAgICAgICAgICAgICBwYW5pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGVzIGFyZSBkb25lLCByZW5kZXJcbiAgICAgICAgdGhpcy5fZG9SZW5kZXIoKTtcblxuICAgICAgICAvLyBXcmFwIHVwIHRoZSBmcmFtZVxuICAgICAgICB0aGlzLmZpbmlzaEZyYW1lKHBhbmljKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZSBhbmQgaGFuZGxlcyB0aGUgcGFuaWMgc3RhdGUgaWYgdGhlcmUgaXMgb25lXG5cdCAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgbG9vcCBwYW5pY2tlZFxuXHQgKi9cblx0cHJvdGVjdGVkIGZpbmlzaEZyYW1lKHBhbmljOiBib29sZWFuKTogdm9pZCB7XG5cdFx0aWYocGFuaWMpIHtcbiAgICAgICAgICAgIHZhciBkaXNjYXJkZWRUaW1lID0gTWF0aC5yb3VuZCh0aGlzLnJlc2V0RnJhbWVEZWx0YSgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFpbiBsb29wIHBhbmlja2VkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBicm93c2VyIHRhYiB3YXMgcHV0IGluIHRoZSBiYWNrZ3JvdW5kLiBEaXNjYXJkaW5nICcgKyBkaXNjYXJkZWRUaW1lICsgJ21zJyk7XG4gICAgICAgIH1cblx0fVxuXG59IiwiaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XG5pbXBvcnQgSW5wdXRIYW5kbGVyIGZyb20gXCIuLi9JbnB1dC9JbnB1dEhhbmRsZXJcIjtcbmltcG9ydCBSZWNvcmRlciBmcm9tIFwiLi4vUGxheWJhY2svRXZlbnRSZWNvcmRlclwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuLi9TY2VuZS9TY2VuZU1hbmFnZXJcIjtcbmltcG9ydCBBdWRpb01hbmFnZXIgZnJvbSBcIi4uL1NvdW5kL0F1ZGlvTWFuYWdlclwiO1xuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyXCI7XG5pbXBvcnQgQ2FudmFzUmVuZGVyZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9DYW52YXNSZW5kZXJlclwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IEdhbWVPcHRpb25zIGZyb20gXCIuL0dhbWVPcHRpb25zXCI7XG5pbXBvcnQgR2FtZUxvb3AgZnJvbSBcIi4vR2FtZUxvb3BcIjtcbmltcG9ydCBGaXhlZFVwZGF0ZUdhbWVMb29wIGZyb20gXCIuL0ZpeGVkVXBkYXRlR2FtZUxvb3BcIjtcbmltcG9ydCBFbnZpcm9ubWVudEluaXRpYWxpemVyIGZyb20gXCIuL0Vudmlyb25tZW50SW5pdGlhbGl6ZXJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XG5pbXBvcnQgV2ViR0xSZW5kZXJlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBSZWNvcmRpbmdNYW5hZ2VyIGZyb20gXCIuLi9QbGF5YmFjay9QbGF5YmFja01hbmFnZXJcIjtcbmltcG9ydCBJbnB1dFJlcGxheWVyIGZyb20gXCIuLi9QbGF5YmFjay9FdmVudFJlcGxheWVyXCI7XG5pbXBvcnQgeyBUaW1lclN0YXRlIH0gZnJvbSBcIi4uL1RpbWluZy9UaW1lclwiO1xuaW1wb3J0IFBsYXliYWNrTWFuYWdlciBmcm9tIFwiLi4vUGxheWJhY2svUGxheWJhY2tNYW5hZ2VyXCI7XG5cbi8qKlxuICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZSBlbmdpbmUuXG4gKiBIYW5kbGVzIHRoZSB1cGRhdGUgb3JkZXIsIGFuZCBpbml0aWFsaXplcyBhbGwgc3Vic3lzdGVtcy5cbiAqIFRoZSBHYW1lIG1hbmFnZXMgdGhlIHVwZGF0ZSBjeWNsZSwgYW5kIHJlcXVlc3RzIGFuaW1hdGlvbiBmcmFtZXMgdG8gcmVuZGVyIHRvIHRoZSBicm93c2VyLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcbiAgICBnYW1lT3B0aW9uczogR2FtZU9wdGlvbnM7XG4gICAgcHJpdmF0ZSBzaG93RGVidWc6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBzaG93U3RhdHM6IGJvb2xlYW47XG5cbiAgICAvLyBUaGUgZ2FtZSBsb29wXG4gICAgcHJpdmF0ZSBsb29wOiBHYW1lTG9vcDtcblxuICAgIC8vIEdhbWUgY2FudmFzIGFuZCBpdHMgd2lkdGggYW5kIGhlaWdodFxuICAgIHJlYWRvbmx5IEdBTUVfQ0FOVkFTOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICByZWFkb25seSBERUJVR19DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xuXHRyZWFkb25seSBXSURUSDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IEhFSUdIVDogbnVtYmVyO1xuICAgIHByaXZhdGUgdmlld3BvcnQ6IFZpZXdwb3J0O1xuICAgIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBjbGVhckNvbG9yOiBDb2xvcjtcbiAgICBcbiAgICAvLyBBbGwgb2YgdGhlIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIHRoYXQgbmVlZCB0byBydW4gaGVyZVxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XG5cdHByaXZhdGUgaW5wdXRIYW5kbGVyOiBJbnB1dEhhbmRsZXI7XG5cdHByaXZhdGUgcGxheWJhY2tNYW5hZ2VyOiBQbGF5YmFja01hbmFnZXI7XG4gICAgcHJpdmF0ZSByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICBwcml2YXRlIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyO1xuICAgIHByaXZhdGUgYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXI7XG4gICAgcHJpdmF0ZSByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHYW1lXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIEdhbWUgaW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pil7XG4gICAgICAgIC8vIEJlZm9yZSBhbnl0aGluZyBlbHNlLCBidWlsZCB0aGUgZW52aXJvbm1lbnRcbiAgICAgICAgRW52aXJvbm1lbnRJbml0aWFsaXplci5zZXR1cCgpO1xuXG4gICAgICAgIC8vIFR5cGVjYXN0IHRoZSBjb25maWcgb2JqZWN0IHRvIGEgR2FtZUNvbmZpZyBvYmplY3RcbiAgICAgICAgdGhpcy5nYW1lT3B0aW9ucyA9IEdhbWVPcHRpb25zLnBhcnNlKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuc2hvd0RlYnVnID0gdGhpcy5nYW1lT3B0aW9ucy5zaG93RGVidWc7XG4gICAgICAgIHRoaXMuc2hvd1N0YXRzID0gdGhpcy5nYW1lT3B0aW9ucy5zaG93U3RhdHM7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgZ2FtZSBsb29wXG4gICAgICAgIHRoaXMubG9vcCA9IG5ldyBGaXhlZFVwZGF0ZUdhbWVMb29wKCk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBnYW1lIGNhbnZhcyBhbmQgZ2l2ZSBpdCBhIGJhY2tncm91bmQgY29sb3JcbiAgICAgICAgdGhpcy5HQU1FX0NBTlZBUyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbWUtY2FudmFzXCIpO1xuICAgICAgICB0aGlzLkRFQlVHX0NBTlZBUyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlYnVnLWNhbnZhc1wiKTtcbiAgICBcbiAgICAgICAgLy8gR2l2ZSB0aGUgY2FudmFzIGEgc2l6ZSBhbmQgZ2V0IHRoZSByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICB0aGlzLldJRFRIID0gdGhpcy5nYW1lT3B0aW9ucy5jYW52YXNTaXplLng7XG4gICAgICAgIHRoaXMuSEVJR0hUID0gdGhpcy5nYW1lT3B0aW9ucy5jYW52YXNTaXplLnk7XG5cbiAgICAgICAgLy8gVGhpcyBzdGVwIE1VU1QgaGFwcGVuIGJlZm9yZSB0aGUgcmVzb3VyY2UgbWFuYWdlciBkb2VzIGFueXRoaW5nXG4gICAgICAgIGlmKHRoaXMuZ2FtZU9wdGlvbnMudXNlV2ViR0wpe1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gbmV3IFdlYkdMUmVuZGVyZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IG5ldyBDYW52YXNSZW5kZXJlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUdhbWVXaW5kb3coKTtcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLnJlbmRlcmluZ01hbmFnZXIuaW5pdGlhbGl6ZUNhbnZhcyh0aGlzLkdBTUVfQ0FOVkFTLCB0aGlzLldJRFRILCB0aGlzLkhFSUdIVCk7XG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IG5ldyBDb2xvcih0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuciwgdGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLmcsIHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5iKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIGRlYnVnZ2luZyBhbmQgc3RhdHNcbiAgICAgICAgRGVidWcuaW5pdGlhbGl6ZURlYnVnQ2FudmFzKHRoaXMuREVCVUdfQ0FOVkFTLCB0aGlzLldJRFRILCB0aGlzLkhFSUdIVCk7XG4gICAgICAgIFN0YXRzLmluaXRTdGF0cygpO1xuXG4gICAgICAgIGlmKHRoaXMuZ2FtZU9wdGlvbnMuc2hvd1N0YXRzKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzdGF0cyBvdXRwdXQgYW5kIG1ha2UgaXQgbm8gbG9uZ2VyIGhpZGRlblxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0c1wiKS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpemUgdGhlIHZpZXdwb3J0IHRvIHRoZSBnYW1lIGNhbnZhc1xuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gbmV3IFZlYzIodGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KGNhbnZhc1NpemUsIHRoaXMuZ2FtZU9wdGlvbnMuem9vbUxldmVsKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIGFsbCBuZWNlc3NhcnkgZ2FtZSBzdWJzeXN0ZW1zXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIgPSBuZXcgSW5wdXRIYW5kbGVyKHRoaXMuR0FNRV9DQU5WQVMpO1xuICAgICAgICBJbnB1dC5pbml0aWFsaXplKHRoaXMudmlld3BvcnQsIHRoaXMuZ2FtZU9wdGlvbnMuaW5wdXRzKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIgPSBuZXcgU2NlbmVNYW5hZ2VyKHRoaXMudmlld3BvcnQsIHRoaXMucmVuZGVyaW5nTWFuYWdlcik7XG4gICAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMucGxheWJhY2tNYW5hZ2VyID0gbmV3IFBsYXliYWNrTWFuYWdlcigpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgdGhlIGdhbWUgd2luZG93IHRoYXQgaG9sZHMgdGhlIGNhbnZhc2VzXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplR2FtZVdpbmRvdygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZ2FtZVdpbmRvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FtZS13aW5kb3dcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdGhlIGhlaWdodCBvZiB0aGUgZ2FtZSB3aW5kb3dcbiAgICAgICAgZ2FtZVdpbmRvdy5zdHlsZS53aWR0aCA9IHRoaXMuV0lEVEggKyBcInB4XCI7XG4gICAgICAgIGdhbWVXaW5kb3cuc3R5bGUuaGVpZ2h0ID0gdGhpcy5IRUlHSFQgKyBcInB4XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIHRoZSBTY2VuZU1hbmFnZXIgZnJvbSB0aGUgR2FtZVxuICAgICAqIEByZXR1cm5zIFRoZSBTY2VuZU1hbmFnZXJcbiAgICAgKi9cbiAgICBnZXRTY2VuZU1hbmFnZXIoKTogU2NlbmVNYW5hZ2VyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVNYW5hZ2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgZ2FtZVxuICAgICAqL1xuICAgIHN0YXJ0KEluaXRpYWxTY2VuZTogbmV3ICguLi5hcmdzOiBhbnkpID0+IFNjZW5lLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgICAgIC8vIFNldCB0aGUgdXBkYXRlIGZ1bmN0aW9uIG9mIHRoZSBsb29wXG4gICAgICAgIHRoaXMubG9vcC5kb1VwZGF0ZSA9IChkZWx0YVQ6IG51bWJlcikgPT4gdGhpcy51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBTZXQgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiB0aGUgbG9vcFxuICAgICAgICB0aGlzLmxvb3AuZG9SZW5kZXIgPSAoKSA9PiB0aGlzLnJlbmRlcigpO1xuXG4gICAgICAgIC8vIFByZWxvYWQgcmVnaXN0cnkgaXRlbXNcbiAgICAgICAgUmVnaXN0cnlNYW5hZ2VyLnByZWxvYWQoKTtcblxuICAgICAgICAvLyBMb2FkIHRoZSBpdGVtcyB3aXRoIHRoZSByZXNvdXJjZSBtYW5hZ2VyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLmxvYWRSZXNvdXJjZXNGcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSdyZSBkb25lIGxvYWRpbmcsIHN0YXJ0IHRoZSBsb29wXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZpbmlzaGVkIFByZWxvYWQgLSBsb2FkaW5nIGZpcnN0IHNjZW5lXCIpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShJbml0aWFsU2NlbmUsIHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubG9vcC5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFsbCBuZWNlc3Nhcnkgc3Vic3lzdGVtcyBvZiB0aGUgZ2FtZS4gRGVmZXJzIHNjZW5lIHVwZGF0ZXMgdG8gdGhlIHNjZW5lTWFuYWdlclxuICAgICAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWUgc2luZSB0aGUgbGFzdCB1cGRhdGVcbiAgICAgKi9cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgLy8gSGFuZGxlIGFsbCBldmVudHMgdGhhdCBoYXBwZW5lZCBzaW5jZSB0aGUgc3RhcnQgb2YgdGhlIGxhc3QgbG9vcFxuICAgICAgICAgICAgdGhpcy5ldmVudFF1ZXVlLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0IGhhbmRsZXIgLSBkaXNhYmxpbmcvZW5hYmxpbmcgdXNlciBpbnB1dFxuICAgICAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgZGF0YSBzdHJ1Y3R1cmVzIHNvIGdhbWUgb2JqZWN0cyBjYW4gc2VlIHRoZSBpbnB1dFxuICAgICAgICAgICAgSW5wdXQudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVjb3JkaW5nIG9mIHRoZSBnYW1lXG4gICAgICAgICAgICB0aGlzLnBsYXliYWNrTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBzY2VuZXNcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHNvdW5kc1xuICAgICAgICAgICAgdGhpcy5hdWRpb01hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIExvYWQgb3IgdW5sb2FkIGFueSByZXNvdXJjZXMgaWYgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIHRoaXMubG9vcC5wYXVzZSgpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgRXJyb3IgaW4gVXBkYXRlIC0gQ3Jhc2hpbmcgZ3JhY2VmdWxseVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhbnZhcyBhbmQgZGVmZXJzIHNjZW5lIHJlbmRlcmluZyB0byB0aGUgc2NlbmVNYW5hZ2VyLiBSZW5kZXJzIHRoZSBkZWJ1ZyBjYW52YXNcbiAgICAgKi9cbiAgICByZW5kZXIoKTogdm9pZCB7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYW52YXNlc1xuICAgICAgICAgICAgRGVidWcuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLmNsZWFyKHRoaXMuY2xlYXJDb2xvcik7XG5cbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnJlbmRlcigpO1xuXG4gICAgICAgICAgICAvLyBIYWNreSBkZWJ1ZyBtb2RlXG4gICAgICAgICAgICBpZihJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiZ1wiKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RGVidWcgPSAhdGhpcy5zaG93RGVidWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlYnVnIHJlbmRlclxuICAgICAgICAgICAgaWYodGhpcy5zaG93RGVidWcpe1xuICAgICAgICAgICAgICAgIERlYnVnLnJlbmRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLnNob3dTdGF0cyl7XG4gICAgICAgICAgICAgICAgU3RhdHMucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICB0aGlzLmxvb3AucGF1c2UoKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuY2F1Z2h0IEVycm9yIGluIFJlbmRlciAtIENyYXNoaW5nIGdyYWNlZnVsbHlcIik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBOdWxsRnVuYyBmcm9tIFwiLi4vRGF0YVR5cGVzL0Z1bmN0aW9ucy9OdWxsRnVuY1wiO1xuXG4vKipcbiAqIFRoZSBtYWluIGdhbWUgbG9vcCBvZiB0aGUgZ2FtZS4gS2VlcHMgdHJhY2sgb2YgZnBzIGFuZCBoYW5kbGVzIHNjaGVkdWxpbmcgb2YgdXBkYXRlcyBhbmQgcmVuZGVyaW5nLlxuICogVGhpcyBjbGFzcyBpcyBsZWZ0IGFic3RyYWN0LCBzbyB0aGF0IGEgc3ViY2xhc3MgY2FuIGhhbmRsZSBleGFjdGx5IGhvdyB0aGUgbG9vcCBpcyBzY2hlZHVsZWQuXG4gKiBGb3IgYW4gZXhhbXBsZSBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgZ2FtZSBsb29wIHNjaGVkdWxpbmcsIGNoZWNrIG91dCBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9nYW1lLWxvb3AuaHRtbClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR2FtZUxvb3Age1xuXG5cdC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIHVwZGF0ZSBvY2N1cnMgKi9cblx0cHJvdGVjdGVkIF9kb1VwZGF0ZTogRnVuY3Rpb24gPSBOdWxsRnVuYztcblxuXHRzZXQgZG9VcGRhdGUodXBkYXRlOiBGdW5jdGlvbil7XG5cdFx0dGhpcy5fZG9VcGRhdGUgPSB1cGRhdGU7XG5cdH1cblxuXHQvKiogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIHJlbmRlciBvY2N1cnMgKi9cblx0cHJvdGVjdGVkIF9kb1JlbmRlcjogRnVuY3Rpb24gPSBOdWxsRnVuYztcblxuXG5cdHNldCBkb1JlbmRlcihyZW5kZXI6IEZ1bmN0aW9uKXtcblx0XHR0aGlzLl9kb1JlbmRlciA9IHJlbmRlcjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBGUFMgb2YgdGhlIGdhbWVcblx0ICovXG5cdGFic3RyYWN0IGdldEZQUygpOiBudW1iZXI7XG5cblx0LyoqXG4gICAgICogU3RhcnRzIHVwIHRoZSBnYW1lIGxvb3BcbiAgICAgKi9cblx0YWJzdHJhY3Qgc3RhcnQoKTogdm9pZDtcblxuXHQvKipcblx0ICogUGF1c2VzIHRoZSBnYW1lIGxvb3AsIHVzdWFsbHkgZm9yIGFuIGVycm9yIGNvbmRpdGlvbi5cblx0ICovXG5cdGFic3RyYWN0IHBhdXNlKCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlc3VtZXMgdGhlIGdhbWUgbG9vcC5cblx0ICovXG5cdGFic3RyYWN0IHJlc3VtZSgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSdW5zIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgZ2FtZS4gTm8gdXBkYXRlIG9jY3VycyBoZXJlLCBvbmx5IGEgcmVuZGVyLlxuXHQgKiBUaGlzIGlzIG5lZWRlZCB0byBpbml0aWFsaXplIGRlbHRhIHRpbWUgdmFsdWVzXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJ1biBiZWZvcmUgYW55IHVwZGF0ZXMgb3IgdGhlIHJlbmRlciBvZiBhIGZyYW1lLlxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcblx0ICovXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBzdGFydEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcblxuXHQvKipcblx0ICogVGhlIGNvcmUgb2YgdGhlIGZyYW1lLCB3aGVyZSBhbnkgbmVjZXNzYXJ5IHVwZGF0ZXMgb2NjdXIsIGFuZCB3aGVyZSBhIHJlbmRlciBoYXBwZW5zXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IGRvRnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBXcmFwcyB1cCB0aGUgZnJhbWVcblx0ICogQHBhcmFtIHBhbmljIFdoZXRoZXIgb3Igbm90IHRoZSB1cGRhdGUgY3ljbGUgcGFuaWNrZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRvbyBtYW55IHVwZGF0ZXMgdHJ5IHRvIGhhcHBlbiBpbiBhIHNpbmdsZSBmcmFtZVxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IGZpbmlzaEZyYW1lKHBhbmljOiBib29sZWFuKTogdm9pZDtcbn0iLCIvLyBAaWdub3JlUGFnZVxuXG4vKiogVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgQHJlZmVyZW5jZVtHYW1lTG9vcF0gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVPcHRpb25zIHtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgY2FudmFzU2l6ZToge3g6IG51bWJlciwgeTogbnVtYmVyfTtcblxuICAgIC8qIFRoZSBkZWZhdWx0IGxldmVsIG9mIHpvb20gKi9cbiAgICB6b29tTGV2ZWw6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgY29sb3IgdG8gY2xlYXIgdGhlIGNhbnZhcyB0byBlYWNoIGZyYW1lICovXG4gICAgY2xlYXJDb2xvcjoge3I6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXJ9XG5cbiAgICAvKiBBIGxpc3Qgb2YgaW5wdXQgYmluZGluZ3MgKi9cbiAgICBpbnB1dHM6IEFycmF5PHtuYW1lOiBzdHJpbmcsIGtleXM6IEFycmF5PHN0cmluZz59PjtcblxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRoZSBkZWJ1ZyByZW5kZXJpbmcgc2hvdWxkIG9jY3VyICovXG4gICAgc2hvd0RlYnVnOiBib29sZWFuO1xuXG4gICAgLyogV2hldGhlciBvciBub3QgdGhlIHN0YXRzIHJlbmRlcmluZyBzaG91bGQgb2NjdXIgKi9cbiAgICBzaG93U3RhdHM6IGJvb2xlYW47XG5cbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0byB1c2Ugd2ViR0wgKi9cbiAgICB1c2VXZWJHTDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZGF0YSBpbiB0aGUgcmF3IG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGdhbWUgb3B0aW9ucyBhcyBhIFJlY29yZFxuICAgICAqIEByZXR1cm5zIEEgdmVyc2lvbiBvZiB0aGUgb3B0aW9ucyBjb252ZXJ0ZWQgdG8gYSBHYW1lT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2Uob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IEdhbWVPcHRpb25zIHtcbiAgICAgICAgbGV0IGdPcHQgPSBuZXcgR2FtZU9wdGlvbnMoKTtcblxuICAgICAgICBnT3B0LmNhbnZhc1NpemUgPSBvcHRpb25zLmNhbnZhc1NpemUgPyBvcHRpb25zLmNhbnZhc1NpemUgOiB7eDogODAwLCB5OiA2MDB9O1xuICAgICAgICBnT3B0Lnpvb21MZXZlbCA9IG9wdGlvbnMuem9vbUxldmVsID8gb3B0aW9ucy56b29tTGV2ZWwgOiAxO1xuICAgICAgICBnT3B0LmNsZWFyQ29sb3IgPSBvcHRpb25zLmNsZWFyQ29sb3IgPyBvcHRpb25zLmNsZWFyQ29sb3IgOiB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NX07XG4gICAgICAgIGdPcHQuaW5wdXRzID0gb3B0aW9ucy5pbnB1dHMgPyBvcHRpb25zLmlucHV0cyA6IFtdO1xuICAgICAgICBnT3B0LnNob3dEZWJ1ZyA9ICEhb3B0aW9ucy5zaG93RGVidWc7XG4gICAgICAgIGdPcHQuc2hvd1N0YXRzID0gISFvcHRpb25zLnNob3dTdGF0cztcbiAgICAgICAgZ09wdC51c2VXZWJHTCA9ICEhb3B0aW9ucy51c2VXZWJHTDtcblxuICAgICAgICByZXR1cm4gZ09wdDtcbiAgICB9XG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuL0dhbWVOb2RlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWdpb24gZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1JlZ2lvblwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9DaXJjbGVcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi9VSUVsZW1lbnRzL0xhYmVsXCI7XG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW4gdGhlIGdhbWUgd29ybGQgdGhhdCBjYW4gYmUgZHJhd24gdG8gdGhlIHNjcmVlblxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDYW52YXNOb2RlIGV4dGVuZHMgR2FtZU5vZGUgaW1wbGVtZW50cyBSZWdpb24ge1xuXHRwcml2YXRlIF9zaXplOiBWZWMyO1xuXHRwcml2YXRlIF9zY2FsZTogVmVjMjtcblx0cHJpdmF0ZSBfYm91bmRhcnk6IEFBQkI7XG5cdHByaXZhdGUgX2hhc0N1c3RvbVNoYWRlcjogYm9vbGVhbjtcblx0cHJpdmF0ZSBfY3VzdG9tU2hhZGVyS2V5OiBzdHJpbmc7XG5cdHByaXZhdGUgX2FscGhhOiBudW1iZXI7XG5cdFxuXHQvKiogQSBmbGFnIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgQ2FudmFzTm9kZSBpcyB2aXNpYmxlICovXG5cdHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXHRcblx0Y29uc3RydWN0b3IoKXtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuX3NpemUgPSBuZXcgVmVjMigwLCAwKTtcblx0XHR0aGlzLl9zaXplLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2l6ZUNoYW5nZWQoKSk7XG5cdFx0dGhpcy5fc2NhbGUgPSBuZXcgVmVjMigxLCAxKTtcblx0XHR0aGlzLl9zY2FsZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNjYWxlQ2hhbmdlZCgpKTtcblx0XHR0aGlzLl9ib3VuZGFyeSA9IG5ldyBBQUJCKCk7XG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xuXHRcdHRoaXMuX2hhc0N1c3RvbVNoYWRlciA9IGZhbHNlO1xuXHR9XG5cblx0Z2V0IGFscGhhKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2FscGhhO1xuXHR9XG5cblx0c2V0IGFscGhhKGE6IG51bWJlcikge1xuXHRcdHRoaXMuX2FscGhhID0gYTtcblx0fVxuXG5cdGdldCBzaXplKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl9zaXplO1xuXHR9XG5cblx0c2V0IHNpemUoc2l6ZTogVmVjMil7XG5cdFx0dGhpcy5fc2l6ZSA9IHNpemU7XG5cdFx0Ly8gRW50ZXIgYXMgYSBsYW1iZGEgdG8gYmluZCBcInRoaXNcIlxuXHRcdHRoaXMuX3NpemUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zaXplQ2hhbmdlZCgpKTtcblx0XHR0aGlzLnNpemVDaGFuZ2VkKCk7XG5cdH1cblx0XG5cdGdldCBzY2FsZSgpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGU7XG5cdH1cblxuXHRzZXQgc2NhbGUoc2NhbGU6IFZlYzIpe1xuXHRcdHRoaXMuX3NjYWxlID0gc2NhbGU7XG5cdFx0Ly8gRW50ZXIgYXMgYSBsYW1iZGEgdG8gYmluZCBcInRoaXNcIlxuXHRcdHRoaXMuX3NjYWxlLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2NhbGVDaGFuZ2VkKCkpO1xuXHRcdHRoaXMuc2NhbGVDaGFuZ2VkKCk7XG5cdH1cblxuXHRzZXQgc2NhbGVYKHZhbHVlOiBudW1iZXIpIHtcblx0XHR0aGlzLnNjYWxlLnggPSB2YWx1ZTtcblx0fVxuXG5cdHNldCBzY2FsZVkodmFsdWU6IG51bWJlcikge1xuXHRcdHRoaXMuc2NhbGUueSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IGhhc0N1c3RvbVNoYWRlcigpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faGFzQ3VzdG9tU2hhZGVyO1xuXHR9XG5cblx0Z2V0IGN1c3RvbVNoYWRlcktleSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9jdXN0b21TaGFkZXJLZXk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0cHJvdGVjdGVkIHBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHRzdXBlci5wb3NpdGlvbkNoYW5nZWQoKTtcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XG5cdH1cblxuXHQvKiogQ2FsbGVkIGlmIHRoZSBzaXplIHZlY3RvciBpcyBjaGFuZ2VkIG9yIHJlcGxhY2VkLiAqL1xuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xuXHR9XG5cblx0LyoqIENhbGxlZCBpZiB0aGUgc2NhbGUgdmVjdG9yIGlzIGNoYW5nZWQgb3IgcmVwbGFjZWQgKi9cblx0cHJvdGVjdGVkIHNjYWxlQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XG5cdH1cblxuXHQvLyBAZG9jSWdub3JlXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHBvc2l0aW9uLCBzaXplLCBvciBzY2FsZSBvZiB0aGUgQ2FudmFzTm9kZSBpcyBjaGFuZ2VkLiBVcGRhdGVzIHRoZSBib3VuZGFyeS4gKi9cblx0cHJpdmF0ZSB1cGRhdGVCb3VuZGFyeSgpOiB2b2lkIHtcblx0XHR0aGlzLl9ib3VuZGFyeS5jZW50ZXIuc2V0KHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KTtcblx0XHR0aGlzLl9ib3VuZGFyeS5oYWxmU2l6ZS5zZXQodGhpcy5zaXplLngqdGhpcy5zY2FsZS54LzIsIHRoaXMuc2l6ZS55KnRoaXMuc2NhbGUueS8yKTtcblx0fVxuXHRcblx0Z2V0IGJvdW5kYXJ5KCk6IEFBQkIge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZGFyeTtcblx0fVxuXG5cdGdldCBzaXplV2l0aFpvb20oKTogVmVjMiB7XG5cdFx0bGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuYm91bmRhcnkuaGFsZlNpemUuY2xvbmUoKS5zY2FsZWQoem9vbSwgem9vbSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGN1c3RvbSBzaGFkZXIgdG8gdGhpcyBDYW52YXNOb2RlXG5cdCAqIEBwYXJhbSBrZXkgVGhlIHJlZ2lzdHJ5IGtleSBvZiB0aGUgU2hhZGVyVHlwZVxuXHQgKi9cblx0dXNlQ3VzdG9tU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XG5cdFx0dGhpcy5faGFzQ3VzdG9tU2hhZGVyID0gdHJ1ZTtcblx0XHR0aGlzLl9jdXN0b21TaGFkZXJLZXkgPSBrZXk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCAoeCwgeSkgaXMgaW5zaWRlIG9mIHRoaXMgY2FudmFzIG9iamVjdFxuXHQgKiBAcGFyYW0geCBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcblx0ICogQHBhcmFtIHkgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBvaW50XG5cdCAqIEByZXR1cm5zIEEgZmxhZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBub2RlIGNvbnRhaW5zIHRoZSBwb2ludC5cblx0ICovXG5cdGNvbnRhaW5zKHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kYXJ5LmNvbnRhaW5zUG9pbnQobmV3IFZlYzIoeCwgeSkpO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGRlYnVnUmVuZGVyKCk6IHZvaWQge1xuXHRcdERlYnVnLmRyYXdCb3godGhpcy5yZWxhdGl2ZVBvc2l0aW9uLCB0aGlzLnNpemVXaXRoWm9vbSwgZmFsc2UsIENvbG9yLkJMVUUpO1xuXHRcdHN1cGVyLmRlYnVnUmVuZGVyKCk7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJcIjtcbmltcG9ydCBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcbmltcG9ydCBQb3NpdGlvbmVkIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Qb3NpdGlvbmVkXCI7XG5pbXBvcnQgeyBpc1JlZ2lvbiB9IGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb25cIjtcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBEZWJ1Z1JlbmRlcmFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0RlYnVnUmVuZGVyYWJsZVwiO1xuaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgVHdlZW5Db250cm9sbGVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2VlbkNvbnRyb2xsZXJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlXCI7XG5pbXBvcnQgR29hcEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvR29hcC9Hb2FwQUlcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGluIHRoZSBnYW1lIHdvcmxkLlxuICogVG8gY29uc3RydWN0IEdhbWVOb2Rlcywgc2VlIHRoZSBAcmVmZXJlbmNlW1NjZW5lXSBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTm9kZSBpbXBsZW1lbnRzIFBvc2l0aW9uZWQsIFVuaXF1ZSwgVXBkYXRlYWJsZSwgUGh5c2ljYWwsIEFjdG9yLCBEZWJ1Z1JlbmRlcmFibGUge1xuXHQvKi0tLS0tLS0tLS0gUE9TSVRJT05FRCAtLS0tLS0tLS0tKi9cblx0cHJpdmF0ZSBfcG9zaXRpb246IFZlYzI7XG5cblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cblx0cHJpdmF0ZSBfaWQ6IG51bWJlcjtcblxuXHQvKi0tLS0tLS0tLS0gUEhZU0lDQUwgLS0tLS0tLS0tLSovXG5cdGhhc1BoeXNpY3M6IGJvb2xlYW4gPSBmYWxzZTtcblx0bW92aW5nOiBib29sZWFuID0gZmFsc2U7XG5cdGZyb3plbjogYm9vbGVhbiA9IGZhbHNlO1xuXHRvbkdyb3VuZDogYm9vbGVhbiA9IGZhbHNlO1xuXHRvbldhbGw6IGJvb2xlYW4gPSBmYWxzZTtcblx0b25DZWlsaW5nOiBib29sZWFuID0gZmFsc2U7XG5cdGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXHRjb2xsaXNpb25TaGFwZTogU2hhcGU7XG5cdGNvbGxpZGVyT2Zmc2V0OiBWZWMyO1xuXHRpc1N0YXRpYzogYm9vbGVhbjtcblx0aXNDb2xsaWRhYmxlOiBib29sZWFuO1xuXHRpc1RyaWdnZXI6IGJvb2xlYW47XG5cdHRyaWdnZXJNYXNrOiBudW1iZXI7XG5cdHRyaWdnZXJFbnRlcnM6IEFycmF5PHN0cmluZz47XG5cdHRyaWdnZXJFeGl0czogQXJyYXk8c3RyaW5nPjtcblx0X3ZlbG9jaXR5OiBWZWMyO1xuXHRzd2VwdFJlY3Q6IEFBQkI7XG5cdGNvbGxpZGVkV2l0aFRpbGVtYXA6IGJvb2xlYW47XG5cdGdyb3VwOiBudW1iZXI7XG5cdGlzUGxheWVyOiBib29sZWFuO1xuXHRpc0NvbGxpZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdC8qLS0tLS0tLS0tLSBBQ1RPUiAtLS0tLS0tLS0tKi9cblx0X2FpOiBBSSB8IEdvYXBBSTtcblx0YWlBY3RpdmU6IGJvb2xlYW47XG5cdHBhdGg6IE5hdmlnYXRpb25QYXRoO1xuXHRwYXRoZmluZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdC8qLS0tLS0tLS0tLSBHRU5FUkFMIC0tLS0tLS0tLS0qL1xuXHQvKiogQW4gZXZlbnQgcmVjZWl2ZXIuICovXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG5cdC8qKiBBbiBldmVudCBlbWl0dGVyLiAqL1xuXHRwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBzY2VuZSB0aGlzIEdhbWVOb2RlIGlzIGEgcGFydCBvZi4gKi9cblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblx0LyoqIFRoZSB2aXN1YWwgbGF5ZXIgdGhpcyBHYW1lTm9kZSByZXNpZGVzIGluLiAqL1xuXHRwcm90ZWN0ZWQgbGF5ZXI6IExheWVyO1xuXHQvKiogQSB1dGlsaXR5IHRoYXQgYWxsb3dzIHRoZSB1c2Ugb2YgdHdlZW5zIG9uIHRoaXMgR2FtZU5vZGUgKi9cblx0dHdlZW5zOiBUd2VlbkNvbnRyb2xsZXI7XG5cdC8qKiBBIHR3ZWVuYWJsZSBwcm9wZXJ0eSBmb3Igcm90YXRpb24uIERvZXMgbm90IGFmZmVjdCB0aGUgYm91bmRpbmcgYm94IG9mIHRoaXMgR2FtZU5vZGUgLSBPbmx5IHJlbmRlcmluZy4gKi9cblx0cm90YXRpb246IG51bWJlcjtcblx0LyoqIFRoZSBvcGFjaXR5IHZhbHVlIG9mIHRoaXMgR2FtZU5vZGUgKi9cblx0YWJzdHJhY3Qgc2V0IGFscGhhKGE6IG51bWJlcik7XG5cblx0YWJzdHJhY3QgZ2V0IGFscGhhKCk6IG51bWJlcjtcblxuXHQvLyBDb25zdHJ1Y3RvciBkb2NzIGFyZSBpZ25vcmVkLCBhcyB0aGUgdXNlciBzaG91bGQgTk9UIGNyZWF0ZSBuZXcgR2FtZU5vZGVzIHdpdGggYSByYXcgY29uc3RydWN0b3Jcblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xuXHRcdHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xuXHRcdHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXHRcdHRoaXMudHdlZW5zID0gbmV3IFR3ZWVuQ29udHJvbGxlcih0aGlzKTtcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblx0fVxuXG5cdGRlc3Ryb3koKXtcblx0XHR0aGlzLnR3ZWVucy5kZXN0cm95KCk7XG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cblx0XHRpZih0aGlzLmhhc1BoeXNpY3Mpe1xuXHRcdFx0dGhpcy5yZW1vdmVQaHlzaWNzKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fYWkpe1xuXHRcdFx0dGhpcy5fYWkuZGVzdHJveSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2FpO1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZW1vdmVBY3Rvcih0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLnNjZW5lLnJlbW92ZSh0aGlzKTtcblxuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTm9kZSh0aGlzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLSBQT1NJVElPTkVEIC0tLS0tLS0tLS0qL1xuXHRnZXQgcG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuXHR9XG5cblx0c2V0IHBvc2l0aW9uKHBvczogVmVjMikge1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gcG9zO1xuXHRcdHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xuXHRcdHRoaXMucG9zaXRpb25DaGFuZ2VkKCk7XG5cdH1cblxuXHRnZXQgcmVsYXRpdmVQb3NpdGlvbigpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5wb3NpdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBwb2ludCB0byBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgem9vbSBhbmQgb3JpZ2luIG9mIHRoaXMgbm9kZVxuXHQgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNvbnZlclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcblx0ICovXG5cdGluUmVsYXRpdmVDb29yZGluYXRlcyhwb2ludDogVmVjMik6IFZlYzIge1xuXHRcdGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aGlzKTtcblx0XHRsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG5cdFx0cmV0dXJuIHBvaW50LmNsb25lKCkuc3ViKG9yaWdpbikuc2NhbGUoem9vbSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gVU5JUVVFIC0tLS0tLS0tLS0qL1xuXHRnZXQgaWQoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH1cblxuXHRzZXQgaWQoaWQ6IG51bWJlcikge1xuXHRcdC8vIGlkIGNhbiBvbmx5IGJlIHNldCBvbmNlXG5cdFx0aWYodGhpcy5faWQgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHR0aGlzLl9pZCA9IGlkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBcIkF0dGVtcHRlZCB0byBhc3NpZ24gaWQgdG8gb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgaWQuXCJcblx0XHR9XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gUEhZU0lDQUwgLS0tLS0tLS0tLSovXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdG8gbW92ZSB0aGUgb2JqZWN0LlxuICAgICAqL1xuXHRtb3ZlKHZlbG9jaXR5OiBWZWMyKTogdm9pZCB7XG5cdFx0aWYodGhpcy5mcm96ZW4pIHJldHVybjtcblx0XHR0aGlzLm1vdmluZyA9IHRydWU7XG5cdFx0dGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcblx0fTtcblxuXHRtb3ZlT25QYXRoKHNwZWVkOiBudW1iZXIsIHBhdGg6IE5hdmlnYXRpb25QYXRoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5mcm96ZW4gfHwgcGF0aC5pc0RvbmUoKSkgcmV0dXJuO1xuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0bGV0IGRpciA9IHBhdGguZ2V0TW92ZURpcmVjdGlvbih0aGlzKTtcblx0XHR0aGlzLm1vdmluZyA9IHRydWU7XG5cdFx0dGhpcy5wYXRoZmluZGluZyA9IHRydWU7XG5cdFx0dGhpcy5fdmVsb2NpdHkgPSBkaXIuc2NhbGUoc3BlZWQpO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSB3aXRoIHdoaWNoIHRoZSBvYmplY3Qgd2lsbCBtb3ZlLlxuICAgICAqL1xuXHRmaW5pc2hNb3ZlKCk6IHZvaWQge1xuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5wb3NpdGlvbi5hZGQodGhpcy5fdmVsb2NpdHkpO1xuXHRcdGlmKHRoaXMucGF0aGZpbmRpbmcpe1xuXHRcdFx0dGhpcy5wYXRoLmhhbmRsZVBhdGhQcm9ncmVzcyh0aGlzKTtcblx0XHRcdHRoaXMucGF0aCA9IG51bGw7XG5cdFx0XHR0aGlzLnBhdGhmaW5kaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdC8qKlxuXHQgKiBAcGFyYW0gY29sbGlzaW9uU2hhcGUgVGhlIGNvbGxpZGVyIGZvciB0aGlzIG9iamVjdC4gSWYgdGhpcyBoYXMgYSByZWdpb24gKGltcGxlbWVudHMgUmVnaW9uKSxcblx0ICogaXQgd2lsbCBiZSB1c2VkIHdoZW4gbm8gY29sbGlzaW9uIHNoYXBlIGlzIHNwZWNpZmllZCAob3IgaWYgY29sbGlzaW9uIHNoYXBlIGlzIG51bGwpLlxuXHQgKiBAcGFyYW0gaXNDb2xsaWRhYmxlIFdoZXRoZXIgdGhpcyBpcyBjb2xsaWRhYmxlIG9yIG5vdC4gVHJ1ZSBieSBkZWZhdWx0LlxuXHQgKiBAcGFyYW0gaXNTdGF0aWMgV2hldGhlciB0aGlzIGlzIHN0YXRpYyBvciBub3QuIEZhbHNlIGJ5IGRlZmF1bHRcblx0ICovXG5cdGFkZFBoeXNpY3MoY29sbGlzaW9uU2hhcGU/OiBTaGFwZSwgY29sbGlkZXJPZmZzZXQ/OiBWZWMyLCBpc0NvbGxpZGFibGU6IGJvb2xlYW4gPSB0cnVlLCBpc1N0YXRpYzogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgcGh5c2ljcyB2YXJpYWJsZXNcblx0XHR0aGlzLmhhc1BoeXNpY3MgPSB0cnVlO1xuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xuXHRcdHRoaXMub25XYWxsID0gZmFsc2U7XG5cdFx0dGhpcy5vbkNlaWxpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdFx0dGhpcy5pc0NvbGxpZGFibGUgPSBpc0NvbGxpZGFibGU7XG5cdFx0dGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuXHRcdHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG5cdFx0dGhpcy50cmlnZ2VyTWFzayA9IDA7XG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzID0gbmV3IEFycmF5KDMyKTtcblx0XHR0aGlzLnRyaWdnZXJFeGl0cyA9IG5ldyBBcnJheSgzMik7XG5cdFx0dGhpcy5fdmVsb2NpdHkgPSBWZWMyLlpFUk87XG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBuZXcgQUFCQigpO1xuXHRcdHRoaXMuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xuXHRcdHRoaXMuZ3JvdXAgPSAtMTtcdFx0XHRcdFx0Ly8gVGhlIGRlZmF1bHQgZ3JvdXAsIGNvbGxpZGVzIHdpdGggZXZlcnl0aGluZ1xuXG5cdFx0Ly8gU2V0IHRoZSBjb2xsaXNpb24gc2hhcGUgaWYgcHJvdmlkZWQsIG9yIHNpbXBseSB1c2UgdGhlIHRoZSByZWdpb24gaWYgdGhlcmUgaXMgb25lLlxuXHRcdGlmKGNvbGxpc2lvblNoYXBlKXtcblx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUgPSBjb2xsaXNpb25TaGFwZTtcblx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbjtcblx0XHR9IGVsc2UgaWYgKGlzUmVnaW9uKHRoaXMpKSB7XG5cdFx0XHQvLyBJZiB0aGUgZ2FtZW5vZGUgaGFzIGEgcmVnaW9uIGFuZCBubyBvdGhlciBpcyBzcGVjaWZpZWQsIHVzZSB0aGF0XG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gKDxhbnk+dGhpcykuYm91bmRhcnkuY2xvbmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgXCJObyBjb2xsaXNpb24gc2hhcGUgc3BlY2lmaWVkIGZvciBwaHlzaWNzIG9iamVjdC5cIlxuXHRcdH1cblxuXHRcdC8vIElmIHdlIHdlcmUgcHJvdmlkZWQgd2l0aCBhIGNvbGxpZGVyIG9mZnNldCwgc2V0IGl0LiBPdGhlcndpc2UgdGhlcmUgaXMgbm8gb2Zmc2V0LCBzbyB1c2UgdGhlIHplcm8gdmVjdG9yXG5cdFx0aWYoY29sbGlkZXJPZmZzZXQpe1xuXHRcdFx0dGhpcy5jb2xsaWRlck9mZnNldCA9IGNvbGxpZGVyT2Zmc2V0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gVmVjMi5aRVJPO1xuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN3ZXB0IHJlY3Rcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IHRoaXMuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCk7XG5cblx0XHQvLyBSZWdpc3RlciB0aGUgb2JqZWN0IHdpdGggcGh5c2ljc1xuXHRcdHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5yZWdpc3Rlck9iamVjdCh0aGlzKTtcblx0fVxuXG5cdC8qKiBSZW1vdmVzIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3Mgc3lzdGVtICovXG4gICAgcmVtb3ZlUGh5c2ljcygpOiB2b2lkIHtcblx0XHQvLyBSZW1vdmUgdGhpcyBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJcblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuZGVyZWdpc3Rlck9iamVjdCh0aGlzKTtcblxuXHRcdC8vIE51bGxpZnkgYWxsIHBoeXNpY3MgZmllbGRzXG5cdFx0dGhpcy5oYXNQaHlzaWNzID0gZmFsc2U7XG5cdFx0dGhpcy5tb3ZpbmcgPSBmYWxzZTtcblx0XHR0aGlzLm9uR3JvdW5kID0gZmFsc2U7XG5cdFx0dGhpcy5vbldhbGwgPSBmYWxzZTtcblx0XHR0aGlzLm9uQ2VpbGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cdFx0dGhpcy5pc0NvbGxpZGFibGUgPSBmYWxzZTtcblx0XHR0aGlzLmlzU3RhdGljID0gZmFsc2U7XG5cdFx0dGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcblx0XHR0aGlzLnRyaWdnZXJNYXNrID0gMDtcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnMgPSBudWxsO1xuXHRcdHRoaXMudHJpZ2dlckV4aXRzID0gbnVsbDtcblx0XHR0aGlzLl92ZWxvY2l0eSA9IFZlYzIuWkVSTztcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IG51bGw7XG5cdFx0dGhpcy5jb2xsaWRlZFdpdGhUaWxlbWFwID0gZmFsc2U7XG5cdFx0dGhpcy5ncm91cCA9IC0xO1xuXHRcdHRoaXMuY29sbGlzaW9uU2hhcGUgPSBudWxsO1xuXHRcdHRoaXMuY29sbGlkZXJPZmZzZXQgPSBWZWMyLlpFUk87XG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBudWxsO1xuXHR9XG5cblx0LyoqIERpc2FibGVzIHBoeXNpY3MgbW92ZW1lbnQgZm9yIHRoaXMgbm9kZSAqL1xuXHRmcmVlemUoKTogdm9pZCB7XG5cdFx0dGhpcy5mcm96ZW4gPSB0cnVlO1xuXHR9XG5cblx0LyoqIFJlZW5hYmxlcyBwaHlzaWNzIG1vdmVtZW50IGZvciB0aGlzIG5vZGUgKi9cblx0dW5mcmVlemUoKTogdm9pZCB7XG5cdFx0dGhpcy5mcm96ZW4gPSBmYWxzZTtcblx0fVxuXG4gICAgLyoqIFByZXZlbnRzIHRoaXMgb2JqZWN0IGZyb20gcGFydGljaXBhdGluZyBpbiBhbGwgY29sbGlzaW9ucyBhbmQgdHJpZ2dlcnMuIEl0IGNhbiBzdGlsbCBtb3ZlLiAqL1xuICAgIGRpc2FibGVQaHlzaWNzKCk6IHZvaWQge1xuXHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cdH1cblxuICAgIC8qKiBFbmFibGVzIHRoaXMgb2JqZWN0IHRvIHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIGRpc2FibGVQaHlzaWNzIHdhcyBjYWxsZWQgKi9cbiAgICBlbmFibGVQaHlzaWNzKCk6IHZvaWQge1xuXHRcdHRoaXMuYWN0aXZlID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb2xsaWRlciBmb3IgdGhpcyBHYW1lTm9kZVxuXHQgKiBAcGFyYW0gY29sbGlkZXIgVGhlIG5ldyBjb2xsaWRlciB0byB1c2Vcblx0ICovXG5cdHNldENvbGxpc2lvblNoYXBlKGNvbGxpZGVyOiBTaGFwZSk6IHZvaWQge1xuXHRcdHRoaXMuY29sbGlzaW9uU2hhcGUgPSBjb2xsaWRlcjtcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlci5jb3B5KHRoaXMucG9zaXRpb24pO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdC8qKlxuICAgICAqIFNldHMgdGhpcyBvYmplY3QgdG8gYmUgYSB0cmlnZ2VyIGZvciBhIHNwZWNpZmljIGdyb3VwXG4gICAgICogQHBhcmFtIGdyb3VwIFRoZSBuYW1lIG9mIHRoZSBncm91cCB0aGF0IGFjdGl2YXRlcyB0aGUgdHJpZ2dlclxuICAgICAqIEBwYXJhbSBvbkVudGVyIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIHdoZW4gdGhpcyB0cmlnZ2VyIGlzIGFjdGl2YXRlZFxuICAgICAqIEBwYXJhbSBvbkV4aXQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIHRyaWdnZXIgc3RvcHMgYmVpbmcgYWN0aXZhdGVkXG4gICAgICovXG4gICAgc2V0VHJpZ2dlcihncm91cDogc3RyaW5nLCBvbkVudGVyOiBzdHJpbmcsIG9uRXhpdDogc3RyaW5nKTogdm9pZCB7XG5cdFx0Ly8gTWFrZSB0aGlzIG9iamVjdCBhIHRyaWdnZXJcblx0XHR0aGlzLmlzVHJpZ2dlciA9IHRydWU7XG5cblx0XHQvLyBHZXQgdGhlIG51bWJlciBvZiB0aGUgcGh5c2ljcyBsYXllclxuXHRcdGxldCBsYXllck51bWJlciA9IHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5nZXRHcm91cE51bWJlcihncm91cCk7XG5cblx0XHRpZihsYXllck51bWJlciA9PT0gMCl7XG5cdFx0XHRjb25zb2xlLndhcm4oYFRyaWdnZXIgZm9yIEdhbWVOb2RlICR7dGhpcy5pZH0gbm90IHNldCAtIGdyb3VwIFwiJHtncm91cH1cIiB3YXMgbm90IHJlY29nbml6ZWQgYnkgdGhlIHBoeXNpY3MgbWFuYWdlci5gKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBBZGQgdGhpcyB0byB0aGUgdHJpZ2dlciBtYXNrXG5cdFx0dGhpcy50cmlnZ2VyTWFzayB8PSBsYXllck51bWJlcjtcblxuXHRcdC8vIExheWVyIG51bWJlcnMgYXJlIGJpdHMsIHNvIGdldCB3aGljaCBiaXQgaXQgaXNcblx0XHRsZXQgaW5kZXggPSBNYXRoLmxvZzIobGF5ZXJOdW1iZXIpO1xuXG5cdFx0Ly8gU2V0IHRoZSBldmVudCBuYW1lc1xuXHRcdHRoaXMudHJpZ2dlckVudGVyc1tpbmRleF0gPSBvbkVudGVyO1xuXHRcdHRoaXMudHJpZ2dlckV4aXRzW2luZGV4XSA9IG9uRXhpdDtcblx0fTtcblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0LyoqXG5cdCAqIEBwYXJhbSBncm91cCBUaGUgcGh5c2ljcyBncm91cCB0aGlzIG5vZGUgc2hvdWxkIGJlbG9uZyB0b1xuXHQgKi9cblx0c2V0R3JvdXAoZ3JvdXA6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5zZXRHcm91cCh0aGlzLCBncm91cCk7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW5lZFxuXHRnZXRMYXN0VmVsb2NpdHkoKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZlbG9jaXR5O1xuXHR9XG5cblx0LyotLS0tLS0tLS0tIEFDVE9SIC0tLS0tLS0tLS0qL1xuXHRnZXQgYWkoKTogQUkgfCBHb2FwQUkge1xuXHRcdHJldHVybiB0aGlzLl9haTtcblx0fVxuXG5cdHNldCBhaShhaTogQUkgfCBHb2FwQUkpIHtcblx0XHRpZighdGhpcy5fYWkpe1xuXHRcdFx0Ly8gSWYgd2UgaGF2ZW4ndCBiZWVuIHByZXZpb3VzbHkgaGFkIGFuIGFpLCByZWdpc3RlciB1cyB3aXRoIHRoZSBhaSBtYW5hZ2VyXG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlZ2lzdGVyQWN0b3IodGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWkgPSBhaTtcblx0XHR0aGlzLmFpQWN0aXZlID0gdHJ1ZTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRhZGRBSTxUIGV4dGVuZHMgQUkgfCBHb2FwQUk+KGFpOiBzdHJpbmcgfCAobmV3ICgpID0+IFQpLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55PiwgdHlwZT86IG51bWJlcik6IHZvaWQge1xuXHRcdGlmKCF0aGlzLl9haSl7XG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlZ2lzdGVyQWN0b3IodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIGFpID09PSBcInN0cmluZ1wiKXtcblx0XHRcdHRoaXMuX2FpID0gdGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5nZW5lcmF0ZUFJKGFpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYWkgPSBuZXcgYWkoKTtcblx0XHR9XG5cblx0XHQvLyBRdWVzdGlvbiwgaG93IG11Y2ggZG8gd2Ugd2FudCBkaWZmZXJlbnQgdHlwZSBvZiBBSSB0byBiZSBoYW5kbGVkIHRoZSBzYW1lLCBpLmUuIHNob3VsZCBHb2FwQUkgYW5kIEFJIHNpbWlsYXIgbWV0aG9kcyBhbmQgc2lnbmF0dXJlcyBmb3IgdGhlIHNha2Ugb2YgdW5pdHlcblx0XHR0aGlzLl9haS5pbml0aWFsaXplQUkodGhpcywgb3B0aW9ucyk7XG5cblx0XHR0aGlzLmFpQWN0aXZlID0gdHJ1ZTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRzZXRBSUFjdGl2ZShhY3RpdmU6IGJvb2xlYW4sIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHR0aGlzLmFpQWN0aXZlID0gYWN0aXZlO1xuXHRcdGlmKHRoaXMuYWlBY3RpdmUpe1xuXHRcdFx0dGhpcy5haS5hY3RpdmF0ZShvcHRpb25zKTtcblx0XHR9XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gVFdFRU5BQkxFIFBST1BFUlRJRVMgLS0tLS0tLS0tLSovXG5cdHNldCBwb3NpdGlvblgodmFsdWU6IG51bWJlcikge1xuXHRcdHRoaXMucG9zaXRpb24ueCA9IHZhbHVlO1xuXHR9XG5cblx0c2V0IHBvc2l0aW9uWSh2YWx1ZTogbnVtYmVyKSB7XG5cdFx0dGhpcy5wb3NpdGlvbi55ID0gdmFsdWU7XG5cdH1cblxuXHRhYnN0cmFjdCBzZXQgc2NhbGVYKHZhbHVlOiBudW1iZXIpO1xuXG5cdGFic3RyYWN0IHNldCBzY2FsZVkodmFsdWU6IG51bWJlcik7XG5cblx0LyotLS0tLS0tLS0tIEdBTUUgTk9ERSAtLS0tLS0tLS0tKi9cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNjZW5lIGZvciB0aGlzIG9iamVjdC5cblx0ICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvLlxuXHQgKi9cblx0c2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHNjZW5lIHRoaXMgb2JqZWN0IGlzIGluLiBcblx0ICogQHJldHVybnMgVGhlIHNjZW5lIHRoaXMgb2JqZWN0IGJlbG9uZ3MgdG9cblx0Ki9cblx0Z2V0U2NlbmUoKTogU2NlbmUge1xuXHRcdHJldHVybiB0aGlzLnNjZW5lO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxheWVyIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAcGFyYW0gbGF5ZXIgVGhlIGxheWVyIHRoaXMgb2JqZWN0IHdpbGwgYmUgb24uXG5cdCAqL1xuXHRzZXRMYXllcihsYXllcjogTGF5ZXIpOiB2b2lkIHtcblx0XHR0aGlzLmxheWVyID0gbGF5ZXI7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGF5ZXIgdGhpcyBvYmplY3QgaXMgb24uXG5cdCAqIEByZXR1cm5zIFRoaXMgbGF5ZXIgdGhpcyBvYmplY3QgaXMgb24uXG5cdCovXG5cdGdldExheWVyKCk6IExheWVyIHtcblx0XHRyZXR1cm4gdGhpcy5sYXllcjtcblx0fVxuXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHBvc2l0aW9uIHZlY3RvciBpcyBtb2RpZmllZCBvciByZXBsYWNlZCAqL1xuXHRwcm90ZWN0ZWQgcG9zaXRpb25DaGFuZ2VkKCk6IHZvaWQge1xuXHRcdGlmKHRoaXMuY29sbGlzaW9uU2hhcGUpe1xuXHRcdFx0aWYodGhpcy5jb2xsaWRlck9mZnNldCl7XG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLmNvbGxpZGVyT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoaXMgR2FtZU5vZGVcblx0ICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZXN0ZXAgb2YgdGhlIHVwZGF0ZS5cblx0ICovXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIERlZmVyIGV2ZW50IGhhbmRsaW5nIHRvIEFJLlxuXHRcdHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xuXHRcdFx0dGhpcy5fYWkuaGFuZGxlRXZlbnQodGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGRlYnVnUmVuZGVyKCk6IHZvaWQge1xuXHRcdC8vIERyYXcgdGhlIHBvc2l0aW9uIG9mIHRoaXMgR2FtZU5vZGVcblx0XHREZWJ1Zy5kcmF3UG9pbnQodGhpcy5yZWxhdGl2ZVBvc2l0aW9uLCBDb2xvci5CTFVFKTtcblxuXHRcdC8vIElmIHZlbG9jaXR5IGlzIG5vdCB6ZXJvLCBkcmF3IGEgdmVjdG9yIGZvciBpdFxuXHRcdGlmKHRoaXMuX3ZlbG9jaXR5ICYmICF0aGlzLl92ZWxvY2l0eS5pc1plcm8oKSl7XG5cdFx0XHREZWJ1Zy5kcmF3UmF5KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgdGhpcy5fdmVsb2NpdHkuY2xvbmUoKS5zY2FsZVRvKDIwKS5hZGQodGhpcy5yZWxhdGl2ZVBvc2l0aW9uKSwgQ29sb3IuQkxVRSk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhpcyBoYXMgYSBjb2xsaWRlciwgZHJhdyBpdFxuXHRcdGlmKHRoaXMuY29sbGlzaW9uU2hhcGUpe1xuXHRcdFx0bGV0IGNvbG9yID0gdGhpcy5pc0NvbGxpZGluZyA/IENvbG9yLlJFRCA6IENvbG9yLkdSRUVOO1xuXG5cdFx0XHRpZih0aGlzLmlzVHJpZ2dlcil7XG5cdFx0XHRcdGNvbG9yID0gQ29sb3IuTUFHRU5UQTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29sb3IuYSA9IDAuMjtcblxuXHRcdFx0aWYodGhpcy5jb2xsaXNpb25TaGFwZSBpbnN0YW5jZW9mIEFBQkIpe1xuXHRcdFx0XHREZWJ1Zy5kcmF3Qm94KHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyKSwgdGhpcy5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZS5zY2FsZWQodGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKSksIHRydWUsIGNvbG9yKTtcblx0XHRcdH0gZWxzZSBpZih0aGlzLmNvbGxpc2lvblNoYXBlIGluc3RhbmNlb2YgQ2lyY2xlKXtcblx0XHRcdFx0RGVidWcuZHJhd0NpcmNsZSh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyh0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciksIHRoaXMuY29sbGlzaW9uU2hhcGUuaHcqdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKSwgdHJ1ZSwgY29sb3IpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZW51bSBUd2VlbmFibGVQcm9wZXJ0aWVze1xuXHRwb3NYID0gXCJwb3NpdGlvblhcIixcblx0cG9zWSA9IFwicG9zaXRpb25ZXCIsXG5cdHNjYWxlWCA9IFwic2NhbGVYXCIsXG5cdHNjYWxlWSA9IFwic2NhbGVZXCIsXG5cdHJvdGF0aW9uID0gXCJyb3RhdGlvblwiLFxuXHRhbHBoYSA9IFwiYWxwaGFcIlxufSIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBnYW1lIG9iamVjdCB0aGF0IGRvZXNuJ3QgcmVseSBvbiBhbnkgcmVzb3VyY2VzIHRvIHJlbmRlciAtIGl0IGlzIGRyYXduIHRvIHRoZSBzY3JlZW4gYnkgdGhlIGNhbnZhc1xuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHcmFwaGljIGV4dGVuZHMgQ2FudmFzTm9kZSB7XG4gICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgR3JhcGhpYyAqL1xuICAgIGNvbG9yOiBDb2xvcjtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBDb2xvci5SRUQ7XG4gICAgfVxuXG4gICAgZ2V0IGFscGhhKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuY29sb3IuYTtcblx0fVxuXG5cdHNldCBhbHBoYShhOiBudW1iZXIpIHtcblx0XHR0aGlzLmNvbG9yLmEgPSBhO1xuXHR9XG5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoZSBHcmFwaGljLiBERVBSRUNBVEVEXG4gICAgICogQHBhcmFtIGNvbG9yIFRoZSBuZXcgY29sb3Igb2YgdGhlIEdyYXBoaWMuXG4gICAgICovXG4gICAgc2V0Q29sb3IoY29sb3I6IENvbG9yKXtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIHNldCBjb2xvclIocjogbnVtYmVyKXtcbiAgICAgICAgdGhpcy5jb2xvci5yID0gcjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JSKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yLnI7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yRyhnOiBudW1iZXIpe1xuICAgICAgICB0aGlzLmNvbG9yLmcgPSBnO1xuICAgIH1cblxuICAgIGdldCBjb2xvckcoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IuZztcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCKGI6IG51bWJlcil7XG4gICAgICAgIHRoaXMuY29sb3IuYiA9IGI7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5iO1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9HcmFwaGljXCI7XG5pbXBvcnQgTGluZSBmcm9tIFwiLi9MaW5lXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGVHcmFwaCBleHRlbmRzIEdyYXBoaWMge1xuICAgIHByb3RlY3RlZCBfZW5kOiBWZWMyO1xuICAgIHByb3RlY3RlZCByOm51bWJlcjtcbiAgICBib3JkZXJDb2xvcjogQ29sb3I7XG5cbiAgICAvKiogVGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgKi9cbiAgICBib3JkZXJXaWR0aDogbnVtYmVyO1xuICAgIGNvbnN0cnVjdG9yKGNlbnRlcjogVmVjMiwgcjpudW1iZXIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5idWlsZENpcmNsZSgpO1xuICAgICAgICAvLyBEb2VzIHRoaXMgcmVhbGx5IGhhdmUgYSBtZWFuaW5nIGZvciBsaW5lcz9cbiAgICAgICAgXG4gICAgfVxuICAgIHByaXZhdGUgYnVpbGRDaXJjbGUoKXtcbiAgICAgICAgXG4gICAgICAgIGZvcihsZXQgaSA9IDA7aTw9MipNYXRoLlBJO2kgKz0wLjAxKXtcbiAgICAgICAgICAgIGxldCB4ID0gTWF0aC5zaW4oaSkgK3RoaXMucjtcbiAgICAgICAgICAgIGxldCB5ID0gTWF0aC5jb3MoaSkrdGhpcy5yO1xuICAgICAgICAgICAgbGV0IGVuZD0gbmV3IFZlYzIoeCwgeSk7XG4gICAgICAgICAgICBuZXcgTGluZSh0aGlzLmNlbnRlcixlbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBjZW50ZXIocG9zOiBWZWMyKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvcztcbiAgICB9XG5cbiAgICBnZXQgY2VudGVyKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgZW5kKHBvczogVmVjMil7XG4gICAgICAgIHRoaXMuX2VuZCA9IHBvcztcbiAgICB9XG5cbiAgICBnZXQgZW5kKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kO1xuICAgIH1cbiAgICBzZXRCb3JkZXJDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgZ2V0Qm9yZGVyQ29sb3IoKTogQ29sb3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib3JkZXIgd2lkdGggb2YgdGhpcyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgc2V0Qm9yZGVyV2lkdGgod2lkdGg6IG51bWJlcil7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSB3aWR0aDtcbiAgICB9XG5cbiAgICBnZXRCb3JkZXJXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICB9XG59IiwiaW1wb3J0IENpcmNsZSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1NoYXBlcy9DaXJjbGVcIjtcblxuZXhwb3J0IGVudW0gR3JhcGhpY1R5cGUge1xuXHRQT0lOVCA9IFwiUE9JTlRcIixcblx0UkVDVCA9IFwiUkVDVFwiLFxuXHRMSU5FID0gXCJMSU5FXCIsXG5cdFBBUlRJQ0xFID0gXCJQQVJUSUNMRVwiLFxuXHRDSVJDTEUgPSBcIkNJUkNMRVwiLFxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZSBleHRlbmRzIEdyYXBoaWMge1xuICAgIHByb3RlY3RlZCBfZW5kOiBWZWMyO1xuICAgIHRoaWNrbmVzczogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3Ioc3RhcnQ6IFZlYzIsIGVuZDogVmVjMil7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMudGhpY2tuZXNzID0gMjtcblxuICAgICAgICAvLyBEb2VzIHRoaXMgcmVhbGx5IGhhdmUgYSBtZWFuaW5nIGZvciBsaW5lcz9cbiAgICAgICAgdGhpcy5zaXplLnNldCg1LCA1KTtcbiAgICB9XG5cbiAgICBzZXQgc3RhcnQocG9zOiBWZWMyKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvcztcbiAgICB9XG5cbiAgICBnZXQgc3RhcnQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICAgIH1cblxuICAgIHNldCBlbmQocG9zOiBWZWMyKXtcbiAgICAgICAgdGhpcy5fZW5kID0gcG9zO1xuICAgIH1cblxuICAgIGdldCBlbmQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmQ7XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuL1BvaW50XCI7XG5cbi8qKlxuICogLSBQb3NpdGlvbiBYXG4tIFZlbG9jaXR5IChzcGVlZCBhbmQgZGlyZWN0aW9uKSBYXG4tIENvbG9yIFhcbi0gTGlmZXRpbWUgXG4tIEFnZSBjYW4gYmUgaGFuZGxlZCBhcyBsaWZldGltZVxuLSBTaGFwZSBYXG4tIFNpemUgWFxuLSBUcmFuc3BhcmVuY3kgWFxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFydGljbGUgZXh0ZW5kcyBQb2ludCB7XG4gICAgYWdlOiBudW1iZXI7XG5cbiAgICBpblVzZTogYm9vbGVhbjtcblxuICAgIHZlbDogVmVjMjtcblxuICAgIG1hc3M6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCBzaXplOiBWZWMyLCBtYXNzOiBudW1iZXIpIHtcbiAgICAgICAgLy8gQXJlIHdlIG1ha2luZyB0aGlzIGEgY2lyY2xlP1xuICAgICAgICBzdXBlcihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuaW5Vc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXNzID0gbWFzcztcbiAgICB9XG5cbiAgICBzZXRQYXJ0aWNsZUFjdGl2ZShsaWZldGltZTogbnVtYmVyLCBwb3NpdGlvbjogVmVjMikge1xuICAgICAgICB0aGlzLmFnZSA9IGxpZmV0aW1lO1xuICAgICAgICB0aGlzLmluVXNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIGRlY3JlbWVudEFnZShkZWNheTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuYWdlIC09IGRlY2F5O1xuICAgIH1cblxuICAgIHNldFBhcnRpY2xlSW5hY3RpdmUoKXtcbiAgICAgICAgdGhpcy5pblVzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzZXQgdmVsWSh5OiBudW1iZXIpe1xuICAgICAgICB0aGlzLnZlbC55ID0geTtcbiAgICB9XG5cbiAgICBnZXQgdmVsWSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWwueTtcbiAgICB9XG5cblxufSIsImltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9HcmFwaGljXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcblxuLyoqIEEgYmFzaWMgcG9pbnQgdG8gYmUgZHJhd24gb24gdGhlIHNjcmVlbi4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50IGV4dGVuZHMgR3JhcGhpYyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMikge1xuICAgICAgICAvLyBBcmUgd2UgbWFraW5nIHRoaXMgYSBjaXJjbGU/XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zaXplLnNldCg1LCA1KTtcbiAgICB9XG59IiwiaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuXG4vKiogQSBiYXNpYyByZWN0YW5nbGUgdG8gYmUgZHJhd24gb24gdGhlIHNjcmVlbi4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3QgZXh0ZW5kcyBHcmFwaGljIHtcblxuICAgIC8qKiBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBSZWN0ICovXG4gICAgYm9yZGVyQ29sb3I6IENvbG9yO1xuXG4gICAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgYm9yZGVyICovXG4gICAgYm9yZGVyV2lkdGg6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCBzaXplOiBWZWMyKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvcmRlciBjb2xvciBvZiB0aGlzIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgYm9yZGVyIGNvbG9yXG4gICAgICovXG4gICAgc2V0Qm9yZGVyQ29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIGdldEJvcmRlckNvbG9yKCk6IENvbG9yIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIHdpZHRoIG9mIHRoaXMgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIGluIHBpeGVsc1xuICAgICAqL1xuICAgIHNldEJvcmRlcldpZHRoKHdpZHRoOiBudW1iZXIpe1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gd2lkdGg7XG4gICAgfVxuXG4gICAgZ2V0Qm9yZGVyV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9yZGVyV2lkdGg7XG4gICAgfVxufSIsImltcG9ydCBTcHJpdGUgZnJvbSBcIi4vU3ByaXRlXCI7XG5pbXBvcnQgQW5pbWF0aW9uTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvQW5pbWF0aW9uTWFuYWdlclwiO1xuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9VSUVsZW1lbnRzL0xhYmVsXCI7XG4vKiogQW4gc3ByaXRlIHdpdGggc3BlY2lmaWVkIGFuaW1hdGlvbiBmcmFtZXMuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZSB7XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGlzIHNwcml0ZSBzaGVldCAqL1xuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XG4gICBcbiAgICBnZXQgY29scygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Db2xzO1xuICAgIH1cblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhpcyBzcHJpdGUgc2hlZXQgKi9cbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xuXG4gICAgZ2V0IHJvd3MoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUm93cztcbiAgICB9XG5cbiAgICAvKiogVGhlIGFuaW1hdGlvbk1hbmFnZXIgZm9yIHRoaXMgc3ByaXRlICovXG4gICAgYW5pbWF0aW9uOiBBbmltYXRpb25NYW5hZ2VyO1xuXG4gICAgY29uc3RydWN0b3Ioc3ByaXRlc2hlZXQ6IFNwcml0ZXNoZWV0KXtcbiAgICAgICAgc3VwZXIoc3ByaXRlc2hlZXQubmFtZSk7XG4gICAgICAgIHRoaXMubnVtQ29scyA9IHNwcml0ZXNoZWV0LmNvbHVtbnM7XG4gICAgICAgIHRoaXMubnVtUm93cyA9IHNwcml0ZXNoZWV0LnJvd3M7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSBzcHJpdGUgdG8gdGhlIHNwcml0ZSBzaXplIHNwZWNpZmllZCBieSB0aGUgc3ByaXRlc2hlZXRcbiAgICAgICAgdGhpcy5zaXplLnNldChzcHJpdGVzaGVldC5zcHJpdGVXaWR0aCwgc3ByaXRlc2hlZXQuc3ByaXRlSGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb25NYW5hZ2VyKHRoaXMpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgYW5pbWF0aW9ucyB0byB0aGUgYW5pbWF0ZWQgc3ByaXRlXG4gICAgICAgIGZvcihsZXQgYW5pbWF0aW9uIG9mIHNwcml0ZXNoZWV0LmFuaW1hdGlvbnMpe1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkKGFuaW1hdGlvbi5uYW1lLCBhbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW1hZ2Ugb2Zmc2V0IGZvciB0aGUgY3VycmVudCBpbmRleCBvZiBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IHdlJ3JlIGF0IGluIHRoZSBhbmltYXRpb25cbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgaW1hZ2Ugb2Zmc2V0XG4gICAgICovXG4gICAgZ2V0QW5pbWF0aW9uT2Zmc2V0KGluZGV4OiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKChpbmRleCAlIHRoaXMubnVtQ29scykgKiB0aGlzLnNpemUueCwgTWF0aC5mbG9vcihpbmRleCAvIHRoaXMubnVtQ29scykgKiB0aGlzLnNpemUueSk7XG4gICAgfVxufSIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9DYW52YXNOb2RlXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vVUlFbGVtZW50cy9MYWJlbFwiO1xuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBzcHJpdGUgLSBhbiBpbi1nYW1lIGltYWdlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcml0ZSBleHRlbmRzIENhbnZhc05vZGUge1xuICAgIC8qKiBUaGUgaWQgb2YgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlTWFuYWdlciAqL1xuICAgIGltYWdlSWQ6IHN0cmluZztcbiAgICAvKiogVGhlIG9mZnNldCBvZiB0aGUgc3ByaXRlIGluIGFuIGF0bGFzIGltYWdlICovXG4gICAgaW1hZ2VPZmZzZXQ6IFZlYzI7XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB4LWF4aXMgc2hvdWxkIGJlIGludmVydGVkIG9uIHJlbmRlciAqL1xuICAgIGludmVydFg6IGJvb2xlYW47XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB5LWF4aXMgc2hvdWxkIGJlIGludmVydGVkIG9uIHJlbmRlciAqL1xuICAgIGludmVydFk6IGJvb2xlYW47XG4gICAgcHVibGljIGN1cnJlbnRUcmFuc3BhcmVudExhYmVsczpBcnJheTxMYWJlbD47XG4gICAgY29uc3RydWN0b3IoaW1hZ2VJZDogc3RyaW5nKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbWFnZUlkID0gaW1hZ2VJZDtcbiAgICAgICAgbGV0IGltYWdlID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0SW1hZ2UodGhpcy5pbWFnZUlkKTtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IFZlYzIoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBWZWMyLlpFUk87XG4gICAgICAgIHRoaXMuaW52ZXJ0WCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludmVydFkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBmcm9tICgwLCAwKSBpbiB0aGUgaW1hZ2UncyBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBvZiB0aGUgc3ByaXRlIGZyb20gKDAsIDApIGluIGltYWdlIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgc2V0SW1hZ2VPZmZzZXQob2Zmc2V0OiBWZWMyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XG5pbXBvcnQgeyBUaWxlZFRpbGVtYXBEYXRhLCBUaWxlZExheWVyRGF0YSB9IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9QaHlzaWNzTWFuYWdlclwiO1xuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgdGlsZW1hcCAtIHRoaXMgY2FuIGNvbnNpc3Qgb2YgYSBjb21iaW5hdGlvbiBvZiB0aWxlc2V0cyBpbiBvbmUgbGF5ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgVGlsZW1hcCBleHRlbmRzIENhbnZhc05vZGUge1xuXG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSB0aWxlc2V0cyB0aGF0IHRoaXMgdGlsZW1hcCB1c2VzICovXG4gICAgcHJvdGVjdGVkIHRpbGVzZXRzOiBBcnJheTxUaWxlc2V0PjtcbiAgICAvKiogVGhlIHNpemUgb2YgYSB0aWxlIGluIHRoaXMgdGlsZW1hcCAqL1xuICAgIHByb3RlY3RlZCB0aWxlU2l6ZTogVmVjMjtcbiAgICAvKiogQW4gYXJyYXkgb2YgdGlsZSBkYXRhICovXG4gICAgcHJvdGVjdGVkIGRhdGE6IEFycmF5PG51bWJlcj47XG4gICAgLyoqIEFuIGFycmF5IG9mIHRpbGUgY29sbGlzaW9uIGRhdGEgKi9cbiAgICBwcm90ZWN0ZWQgY29sbGlzaW9uTWFwOiBBcnJheTxib29sZWFuPjtcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIHRpbGVtYXAgKi9cbiAgICBwcm90ZWN0ZWQgX25hbWU6IHN0cmluZztcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0aWxlbWFwICovXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcbiAgICAvKiogVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSB0aWxlbWFwICovXG4gICAgcHJvdGVjdGVkIG51bVJvd3M6IG51bWJlcjtcbiAgICBcblxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBubyBsb25nZXIgYmUgc3BlY2lmaWMgdG8gVGlsZWRcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhLCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD4sIHNjYWxlOiBWZWMyKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy50aWxlc2V0cyA9IHRpbGVzZXRzO1xuICAgICAgICB0aGlzLnRpbGVTaXplID0gbmV3IFZlYzIoMCwgMCk7XG4gICAgICAgIHRoaXMubmFtZSA9IGxheWVyLm5hbWU7XG4gICAgICAgIHRoaXMubnVtQ29scyA9IHRpbGVtYXBEYXRhLndpZHRoO1xuICAgICAgICB0aGlzLm51bVJvd3MgPSB0aWxlbWFwRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgbGV0IHRpbGVjb3VudCA9IDA7XG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlc2V0cyl7XG4gICAgICAgICAgICB0aWxlY291bnQgKz0gdGlsZXNldC5nZXRUaWxlQ291bnQoKSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcCA9IG5ldyBBcnJheSh0aWxlY291bnQpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmVyIHBhcnNpbmcgb2YgdGhlIGRhdGEgdG8gY2hpbGQgY2xhc3NlcyAtIHRoaXMgYWxsb3dzIGZvciBpc29tZXRyaWMgdnMuIG9ydGhvZ3JhcGhpYyB0aWxlbWFwcyBhbmQgaGFuZGxpbmcgb2YgVGlsZWQgZGF0YSBvciBvdGhlciBkYXRhXG4gICAgICAgIHRoaXMucGFyc2VUaWxlbWFwRGF0YSh0aWxlbWFwRGF0YSwgbGF5ZXIpO1xuICAgICAgICB0aGlzLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcbiAgICB9XG4gICAgXG4gICAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9uYW1lOyB9XG4gICAgcHVibGljIHNldCBuYW1lKG5hbWU6IHN0cmluZykgeyB0aGlzLl9uYW1lID0gbmFtZTsgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgcHVibGljIGdldFRpbGUoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRUaWxlSW5kZXgoY29sLCByb3cpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7IHJldHVybiAtMTsgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcHMgYmFja2luZyBhcnJheS5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIGluIHJvdy1jb2x1bW4gZm9ybWF0IGluIHRoZSBiYWNraW5nIGFycmF5IG9mIHRoZSB0aWxlbWFwXG4gICAgICogQHJldHVybnMgdGhlIGluZGV4IG9mIHBvc2l0aW9uIGluIHRoZSB0aWxlbWFwXG4gICAgICovXG4gICAgcHVibGljIGdldFRpbGVJbmRleChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBpZiAoY29sIDwgMCB8fCBjb2wgPj0gdGhpcy5udW1Db2xzIHx8IHJvdyA8IDAgfHwgcm93ID49IHRoaXMubnVtUm93cykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3cgKiB0aGlzLm51bUNvbHMgKyBjb2w7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbHVtbiBhbmQgcm93IG9mIGEgdGlsZSBpbiB0aGUgdGlsZW1hcCBmcm9tIHRoZSBpbmRleCBvZiB0aGUgdGlsZVxuICAgICAqIGluIHRoZSBiYWNraW5nIGFycmF5LlxuICAgICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIGJhY2tpbmcgYXJyYXlcbiAgICAgKiBAcmV0dXJuIGEgVmVjMiBjb250YWluaW5nIHRoZSBjb2x1bW4gYW5kIHJvdyBpbmRpY2VzIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgcHVibGljIGdldFRpbGVDb2xSb3coaW5kZXg6IG51bWJlcik6IFZlYzIge1xuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKGNvbCwgcm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHRpbGUuXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSByb3cgYW5kIGNvbHVtbiBvZiB0aGUgdGlsZSBpbiB0aGUgYmFja2luZyBhcnJheVxuICAgICAqIEBwYXJhbSB0aWxlIHRoZSBudW1iZXIgb2YgdGhlIHRpbGUgdG8gc2V0XG4gICAgICovXG4gICAgcHVibGljIHNldFRpbGUoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyLCB0aWxlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRUaWxlSW5kZXgoY29sLCByb3cpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7IFxuICAgICAgICAgICAgdGhpcy5kYXRhW2luZGV4XSA9IHRpbGU7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGlsZW1hcFxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBvZiB0aGUgdGlsZXNldHMgYXNzb2NhaXRlZCB3aXRoIHRoaXMgdGlsZW1hcC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGlsZXNldHMoKTogVGlsZXNldFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZXNldHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRpbGVtYXBcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYW5kIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZW1hcC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RGltZW5zaW9ucygpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubnVtQ29scywgdGhpcy5udW1Sb3dzKTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2RzIGZvciBnZXR0aW5nIHRoZSBzaXplIG9mIGEgdGlsZVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmF3IHNpemUgb2YgdGhlIHRpbGVzLCB3aXRob3V0IGFueSBzY2FsaW5nIG9yIHpvb21pbmcuXG4gICAgICogQHJldHVybnMgdGhlIHNpemUgb2YgdGhlIHRpbGVzIGluIHRoaXMgdGlsZW1hcFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGlsZXMgaW4gdGhpcyB0aWxlbWFwIGFzIHRoZXkgYXBwZWFyIGluIHRoZSBnYW1lIHdvcmxkIGFmdGVyIHNjYWxpbmdcbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciBjb250YWluaW5nIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTY2FsZWRUaWxlU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVNpemUoKS5zY2FsZWQodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xuICAgIH1cbiAgIFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW4gb2YgdGhlIHRpbGVtYXAgaXMgY29sbGlkYWJsZVxuICAgICAqIEBwYXJhbSBjb2wgdGhlIHNwZWNpZmllZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0gcm93IHRoZSBzcGVjaWZpZWQgcm93XG4gICAgICogQHJldHVybnMgQSBmbGFnIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdGlsZSBpcyBjb2xsaWRhYmxlLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc1RpbGVDb2xsaWRhYmxlKGNvbDogbnVtYmVyLCByb3c6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoY29sIDwgMCB8fCBjb2wgPj0gdGhpcy5udW1Db2xzIHx8IHJvdyA8IDAgfHwgcm93ID49IHRoaXMubnVtUm93cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpc2lvbk1hcFt0aGlzLmdldFRpbGUoY29sLCByb3cpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoaXMgdGlsZW1hcCB0byB0aGUgcGh5c2ljcyBzeXN0ZW1cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkUGh5c2ljcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmdyb3VwID0gLTE7XG4gICAgICAgIHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5yZWdpc3RlclRpbGVtYXAodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgeC95IGNvb3JkaW5hdGVzIG9mIGEgdGlsZSBvbiB0aGUgc2NyZWVuIGZyb20gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWxlIGluIHRoZSBcbiAgICAgKiBiYWNraW5nIGFycmF5IG9mIHRoZSB0aWxlbWFwLlxuICAgICAqIEBwYXJhbSByb3cgdGhlIHJvdyBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aGUgYmFja2luZyBhcnJheVxuICAgICAqIEBwYXJhbSBjb2wgdGhlIGNvbHVtbiBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aGUgYmFja2luZyBhcnJheVxuICAgICAqIEByZXR1cm5zIGEgVmVjMiBjb250YWluaW5nIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdGlsZVxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRXb3JsZFBvc2l0aW9uKGNvbDogbnVtYmVyLCByb3c6IG51bWJlcik6IFZlYzI7XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcm93L2NvbHVtbiBwb3NpdGlvbiBvZiBhIHRpbGUgaW4gdGhlIHRpbGVtYXAgZnJvbSB0aGUgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSB0aWxlLlxuICAgICAqIEBwYXJhbSB4IHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgb24gdGhlIHNjcmVlblxuICAgICAqIEBwYXJhbSB5IHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgb24gdGhlIHNjcmVlblxuICAgICAqIEByZXR1cm5zIGEgVmVjMiBjb250YWluaW5nIHRoZSBjb2x1bW4gYW5kIHJvdyBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRUaWxlbWFwUG9zaXRpb24oeDogbnVtYmVyLCB5OiBudW1iZXIpOiBWZWMyO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sbGlzaW9uIHNoYXBlIGZvciB0aGUgc3BlY2lmaWVkIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBjb2x1bW4vcm93IGluIHRoZSB0aWxlbWFwXG4gICAgICogQHBhcmFtIHJvdyB0aGUgcm93XG4gICAgICogQHBhcmFtIGNvbCB0aGUgY29sdW1uXG4gICAgICogQHJldHVybiBhIG5ldyBTaGFwZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb2xsaXNpb24gc2hhcGUgb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0VGlsZUNvbGxpZGVyKGNvbDogbnVtYmVyLCByb3c6IG51bWJlcik6IFNoYXBlO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGFuZCByb3cgcG9zaXRpb24gb2YgZmlyc3QgdGlsZSBpbiB0aGUgcmVnaW9uLiBUaGlzIG1ldGhvZCBnZXRzIGNhbGxlZFxuICAgICAqIHdoZW4gcmVuZGVyaW5nIGlzIGRvbmUgdG8gZGV0ZXJtaW5lIHdoaWNoIHRpbGVzIHNob3VsZCBiZSByZW5kZXJlZCBpbiB0aGUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHVwcGVyTGVmdCB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIHJlZ2lvblxuICAgICAqIEBwYXJhbSBib3R0b21SaWdodCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVnaW9uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldE1pbkNvbFJvdyhyZWdpb246IEFBQkIpOiBWZWMyO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sdW1uIGFuZCByb3cgcG9zaXRpb24gb2YgdGhlIGxhc3QgdGlsZSBpbiB0aGUgcmVnaW9uLiBUaGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBcbiAgICAgKiB3aGVuIHJlbmRlcmluZyBpcyBkb25lIHRvIGRldGVybWluZSB3aGljaCB0aWxlcyBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB1cHBlckxlZnQgdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSByZWdpb25cbiAgICAgKiBAcGFyYW0gYm90dG9tUmlnaHQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlZ2lvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRNYXhDb2xSb3cocmVnaW9uOiBBQUJCKTogVmVjMjtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHRpbGVzZXQgdXNpbmcgdGhlIGRhdGEgbG9hZGVkIGZyb20gZmlsZVxuICAgICAqIEBwYXJhbSB0aWxlbWFwRGF0YSBUaGUgdGlsZW1hcCBkYXRhIGZyb20gZmlsZVxuICAgICAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIgZGF0YSBmcm9tIGZpbGVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcGFyc2VUaWxlbWFwRGF0YSh0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhKTogdm9pZDtcbn0iLCJpbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGVcIjtcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEsIFRpbGVkTGF5ZXJEYXRhIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL1RpbGVtYXBcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJc29tZXRyaWNUaWxlbWFwIGV4dGVuZHMgVGlsZW1hcCB7XG4gICAgcHVibGljIGdldE1pbkNvbFJvdyhyZWdpb246IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKDAsIDApO1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0TWF4Q29sUm93KHJlZ2lvbjogQUFCQik6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5udW1Db2xzLCB0aGlzLm51bVJvd3MpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRXb3JsZFBvc2l0aW9uKGNvbDogbnVtYmVyLCByb3c6IG51bWJlcik6IFZlYzIgfCBudWxsIHtcbiAgICAgICAgaWYgKGNvbCA8IDAgfHwgY29sID4gdGhpcy5udW1Db2xzIHx8IHJvdyA8IDAgfHwgcm93ID4gdGhpcy5udW1Sb3dzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnB4ID0gdGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldEhhbGZTaXplKCkueDtcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKHRoaXMuc2NhbGUueCAqIHRoaXMudGlsZVNpemUueCAvIDIgKiAoY29sIC0gcm93KSArIHZweCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcih0aGlzLnNjYWxlLnkgKiB0aGlzLnRpbGVTaXplLnkgLyAyICogKGNvbCArIHJvdykpO1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XG4gICAgfVxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRUaWxlbWFwUG9zaXRpb24oeDogbnVtYmVyLCB5OiBudW1iZXIpOiBWZWMyIHwgbnVsbCB7XG4gICAgICAgIGxldCB2cHggPSB0aGlzLnNjZW5lLmdldFZpZXdwb3J0KCkuZ2V0SGFsZlNpemUoKS54O1xuICAgICAgICBsZXQgY29sID0gTWF0aC5mbG9vcigoeCAtIHZweCkgLyB0aGlzLnNjYWxlLnggLyB0aGlzLnRpbGVTaXplLnggKyB5IC8gdGhpcy5zY2FsZS55IC8gdGhpcy50aWxlU2l6ZS55KTtcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoeSAvIHRoaXMuc2NhbGUueSAvIHRoaXMudGlsZVNpemUueSAtICh4IC0gdnB4KSAvIHRoaXMuc2NhbGUueCAvIHRoaXMudGlsZVNpemUueCk7XG4gICAgICAgIGlmIChjb2wgPCAwIHx8IGNvbCA+IHRoaXMubnVtQ29scyB8fCByb3cgPCAwIHx8IHJvdyA+IHRoaXMubnVtUm93cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKGNvbCwgcm93KTtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRUaWxlQ29sbGlkZXIoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogU2hhcGUge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQge1xuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBpbiBsb2NhbCBzcGFjZVxuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlbWFwRGF0YS53aWR0aDtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZW1hcERhdGEuaGVpZ2h0O1xuXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRpbGVzXG4gICAgICAgIHRoaXMudGlsZVNpemUuc2V0KHRpbGVtYXBEYXRhLnRpbGV3aWR0aCwgdGlsZW1hcERhdGEudGlsZWhlaWdodCk7XG5cbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIHRpbGVtYXAgb24gdGhlIGNhbnZhc1xuICAgICAgICB0aGlzLnNpemUuc2V0KHRoaXMubnVtQ29scyAqIHRoaXMudGlsZVNpemUueCwgdGhpcy5udW1Sb3dzICogdGhpcy50aWxlU2l6ZS55KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGxheWVyLmRhdGE7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGxheWVyLnZpc2libGU7XG5cbiAgICAgICAgLy8gV2hldGhlciB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlIG9yIG5vdFxuICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBpdGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhbGwgdGlsZXMgYmVzaWRlcyBcImVtcHR5OiAwXCIgdG8gYmUgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBvdmVycmlkZSBkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgZm9yIChsZXQgdGlsZSA9IDA7IHRpbGUgPCB0aGlzLmRhdGEubGVuZ3RoOyB0aWxlKyspIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSB0aGlzLmdldFRpbGVDb2xSb3codGlsZSk7XG4gICAgICAgICAgICBEZWJ1Zy5kcmF3UG9pbnQodGhpcy5nZXRXb3JsZFBvc2l0aW9uKHBvcy54LCBwb3MueSksIENvbG9yLkJMVUUpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9UaWxlbWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEsIFRpbGVkTGF5ZXJEYXRhIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb3J0aG9nb25hbCB0aWxlbWFwIC0gaS5lLiBhIHRvcCBkb3duIG9yIHBsYXRmb3JtZXIgdGlsZW1hcFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcnRob2dvbmFsVGlsZW1hcCBleHRlbmRzIFRpbGVtYXAge1xuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldE1pbkNvbFJvdyhyZWdpb246IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZW1hcFBvc2l0aW9uKHJlZ2lvbi50b3BMZWZ0LngsIHJlZ2lvbi50b3BMZWZ0LnkpO1xuICAgIH1cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0TWF4Q29sUm93KHJlZ2lvbjogQUFCQik6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlbWFwUG9zaXRpb24ocmVnaW9uLmJvdHRvbVJpZ2h0LngsIHJlZ2lvbi5ib3R0b21SaWdodC55KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0VGlsZW1hcFBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGxldCBjb2wgPSBNYXRoLmZsb29yKHggLyB0aGlzLnRpbGVTaXplLnggLyB0aGlzLnNjYWxlLngpO1xuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcih5IC8gdGhpcy50aWxlU2l6ZS55IC8gdGhpcy5zY2FsZS55KTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKGNvbCwgcm93KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0V29ybGRQb3NpdGlvbihjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgbGV0IHggPSBjb2wgKiB0aGlzLnRpbGVTaXplLnggKiB0aGlzLnNjYWxlLng7XG4gICAgICAgIGxldCB5ID0gcm93ICogdGhpcy50aWxlU2l6ZS55ICogdGhpcy5zY2FsZS55O1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldFRpbGVDb2xsaWRlcihjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBBQUJCIHtcbiAgICAgICAgbGV0IHRpbGVTaXplID0gdGhpcy5nZXRTY2FsZWRUaWxlU2l6ZSgpO1xuXG4gICAgICAgIGxldCBjZW50ZXJYID0gY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLnggLyAyO1xuICAgICAgICBsZXQgY2VudGVyWSA9IHJvdyAqIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55IC8gMjtcblxuICAgICAgICBsZXQgY2VudGVyID0gbmV3IFZlYzIoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgIGxldCBoYWxmU2l6ZSA9IHRpbGVTaXplLnNjYWxlZCgwLjUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgQUFCQihjZW50ZXIsIGhhbGZTaXplKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VUaWxlbWFwRGF0YSh0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhKTogdm9pZCB7XG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSB0aWxlbWFwIGluIGxvY2FsIHNwYWNlXG4gICAgICAgIHRoaXMubnVtQ29scyA9IHRpbGVtYXBEYXRhLndpZHRoO1xuICAgICAgICB0aGlzLm51bVJvd3MgPSB0aWxlbWFwRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGlsZXNcbiAgICAgICAgdGhpcy50aWxlU2l6ZS5zZXQodGlsZW1hcERhdGEudGlsZXdpZHRoLCB0aWxlbWFwRGF0YS50aWxlaGVpZ2h0KTtcblxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBvbiB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQodGhpcy5udW1Db2xzICogdGhpcy50aWxlU2l6ZS54LCB0aGlzLm51bVJvd3MgKiB0aGlzLnRpbGVTaXplLnkpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbGF5ZXIuZGF0YTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gbGF5ZXIudmlzaWJsZTtcblxuICAgICAgICAvLyBXaGV0aGVyIHRoZSB0aWxlbWFwIGlzIGNvbGxpZGFibGUgb3Igbm90XG4gICAgICAgIHRoaXMuaXNDb2xsaWRhYmxlID0gZmFsc2U7XG4gICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0ubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGl0ZW0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFsbCB0aWxlcyBiZXNpZGVzIFwiZW1wdHk6IDBcIiB0byBiZSBjb2xsaWRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCB0aGlzLmNvbGxpc2lvbk1hcC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHt9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZGVidWdSZW5kZXIoKXtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjciA9IHRoaXMuZ2V0VGlsZUNvbFJvdyhpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29sbGlkYWJsZSAmJiB0aGlzLmlzVGlsZUNvbGxpZGFibGUoY3IueCwgY3IueSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgYm94ID0gdGhpcy5nZXRUaWxlQ29sbGlkZXIoY3IueCwgY3IueSk7XG4gICAgICAgICAgICAgICAgRGVidWcuZHJhd0JveCh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyhib3guY2VudGVyKSwgYm94LmhhbGZTaXplLnNjYWxlKHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCkpLCBmYWxzZSwgQ29sb3IuQkxVRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEFBQkIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlXCI7XG5pbXBvcnQgeyBUaWxlZFRpbGVtYXBEYXRhLCBUaWxlZExheWVyRGF0YSB9IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vVGlsZW1hcFwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YWdnZXJlZElzb21ldHJpY1RpbGVtYXAgZXh0ZW5kcyBUaWxlbWFwIHtcblxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRUaWxlbWFwUG9zaXRpb24oeDogbnVtYmVyLCB5OiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgbGV0IGNvbCA9IHggLyB0aGlzLnRpbGVTaXplLnggLyB0aGlzLnNjYWxlLng7XG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKHkgLyB0aGlzLnRpbGVTaXplLnkgLyB0aGlzLnNjYWxlLnkgKiAyKTtcbiAgICAgICAgaWYgKHJvdyAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIGNvbCA9ICh4IC0gdGhpcy50aWxlU2l6ZS54IC8gdGhpcy5zY2FsZS54IC8gMikgLyB0aGlzLnRpbGVTaXplLnggLyB0aGlzLnNjYWxlLng7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKE1hdGguZmxvb3IoY29sKSwgcm93KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0V29ybGRQb3NpdGlvbihjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgbGV0IHggPSBjb2wgKiB0aGlzLnRpbGVTaXplLnggKiB0aGlzLnNjYWxlLng7XG4gICAgICAgIGxldCB5ID0gcm93ICogdGhpcy50aWxlU2l6ZS55IC8gMiAqIHRoaXMuc2NhbGUueTtcbiAgICAgICAgaWYgKHJvdyAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHggKz0gdGhpcy50aWxlU2l6ZS54ICogdGhpcy5zY2FsZS54IC8gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoTWF0aC5mbG9vcih4KSwgTWF0aC5mbG9vcih5KSk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldFRpbGVDb2xsaWRlcihjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBBQUJCIHtcbiAgICAgICAgXG4gICAgICAgIGxldCB0aWxlU2l6ZSA9IHRoaXMuZ2V0U2NhbGVkVGlsZVNpemUoKTtcblxuICAgICAgICBsZXQgY2VudGVyWCA9IGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54IC8gMlxuICAgICAgICBsZXQgY2VudGVyWSA9IHJvdyAqIHRpbGVTaXplLnkgLyAyICsgdGlsZVNpemUueSArIHRpbGVTaXplLnkgLyAyO1xuICAgICAgICBpZiAocm93ICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgY2VudGVyWCArPSB0aWxlU2l6ZS54IC8gMjtcbiAgICAgICAgfSBcblxuICAgICAgICBsZXQgY2VudGVyID0gbmV3IFZlYzIoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgIGxldCBoYWxmU2l6ZSA9IHRpbGVTaXplLnNjYWxlZCgwLjUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgQUFCQihjZW50ZXIsIGhhbGZTaXplKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0TWluQ29sUm93KHJlZ2lvbjogQUFCQik6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIoMCwgMCk7XG4gICAgfSAgIFxuXG4gICAgcHVibGljIG92ZXJyaWRlIGdldE1heENvbFJvdyhyZWdpb246IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubnVtQ29scywgdGhpcy5udW1Sb3dzKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VUaWxlbWFwRGF0YSh0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhKTogdm9pZCB7XG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSB0aWxlbWFwIGluIGxvY2FsIHNwYWNlXG4gICAgICAgIHRoaXMubnVtQ29scyA9IHRpbGVtYXBEYXRhLndpZHRoO1xuICAgICAgICB0aGlzLm51bVJvd3MgPSB0aWxlbWFwRGF0YS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGlsZXNcbiAgICAgICAgdGhpcy50aWxlU2l6ZS5zZXQodGlsZW1hcERhdGEudGlsZXdpZHRoLCB0aWxlbWFwRGF0YS50aWxlaGVpZ2h0KTtcblxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBvbiB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQodGhpcy5udW1Db2xzICogdGhpcy50aWxlU2l6ZS54LCB0aGlzLm51bVJvd3MgKiB0aGlzLnRpbGVTaXplLnkpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbGF5ZXIuZGF0YTtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gbGF5ZXIudmlzaWJsZTtcblxuICAgICAgICAvLyBXaGV0aGVyIHRoZSB0aWxlbWFwIGlzIGNvbGxpZGFibGUgb3Igbm90XG4gICAgICAgIHRoaXMuaXNDb2xsaWRhYmxlID0gZmFsc2U7XG4gICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgIGlmKGl0ZW0ubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGl0ZW0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFsbCB0aWxlcyBiZXNpZGVzIFwiZW1wdHk6IDBcIiB0byBiZSBjb2xsaWRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCB0aGlzLmNvbGxpc2lvbk1hcC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcHVibGljIG92ZXJyaWRlIGRlYnVnUmVuZGVyKCk6IHZvaWQge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJjID0gdGhpcy5nZXRUaWxlQ29sUm93KGkpO1xuICAgICAgICAgICAgbGV0IGJveCA9IHRoaXMuZ2V0VGlsZUNvbGxpZGVyKHJjLngsIHJjLnkpO1xuICAgICAgICAgICAgRGVidWcuZHJhd0JveCh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyhib3guY2VudGVyKSwgYm94LmhhbGZTaXplLnNjYWxlKHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCkpLCBmYWxzZSwgQ29sb3IuQkxVRSk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4vQ2FudmFzTm9kZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgVUlFbGVtZW50IC0gdGhlIHBhcmVudCBjbGFzcyBvZiB0aGluZ3MgbGlrZSBidXR0b25zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFVJRWxlbWVudCBleHRlbmRzIENhbnZhc05vZGUge1xuXHQvLyBTdHlsZSBhdHRyaWJ1dGVzIC0gVE9ETyAtIGFic3RyYWN0IHRoaXMgaW50byBhIHN0eWxlIG9iamVjdC9pbnRlcmZhY2Vcblx0LyoqIFRoZSBiYWNrZ291bmQgY29sb3IgKi9cblx0YmFja2dyb3VuZENvbG9yOiBDb2xvcjtcblx0LyoqIFRoZSBib3JkZXIgY29sb3IgKi9cblx0Ym9yZGVyQ29sb3I6IENvbG9yO1xuXHQvKiogVGhlIGJvcmRlciByYWRpdXMgKi9cblx0Ym9yZGVyUmFkaXVzOiBudW1iZXI7XG5cdC8qKiBUaGUgYm9yZGVyIHdpZHRoICovXG5cdGJvcmRlcldpZHRoOiBudW1iZXI7XG5cdC8qKiBUaGUgcGFkZGluZyAqL1xuXHRwYWRkaW5nOiBWZWMyO1xuXG5cdC8vIEV2ZW50QXR0cmlidXRlc1xuXHQvKiogVGhlIHJlYWN0aW9uIG9mIHRoaXMgVUlFbGVtZW50IG9uIGEgY2xpY2sgKi9cblx0b25DbGljazogRnVuY3Rpb247XG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiBjbGljayAqL1xuXHRvbkNsaWNrRXZlbnRJZDogc3RyaW5nO1xuXHQvKiogVGhlIHJlYWN0aW9uIHRvIHRoZSByZWxlYXNlIG9mIGEgY2xpY2sgKi9cblx0b25SZWxlYXNlOiBGdW5jdGlvbjtcblx0LyoqIFRoZSBldmVudCBwcm9wYWdhdGVkIG9uIHRoZSByZWxlYXNlIG9mIGEgY2xpY2sgKi9cblx0b25SZWxlYXNlRXZlbnRJZDogc3RyaW5nO1xuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBlbnRlcnMgdGhpcyBVSUVsZW1lbnQgKi9cblx0b25FbnRlcjogRnVuY3Rpb247XG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCB3aGVuIGEgbW91c2UgZW50ZXJzIHRoaXMgVUlFbGVtZW50ICovXG5cdG9uRW50ZXJFdmVudElkOiBzdHJpbmc7XG5cdC8qKiBUaGUgcmVhY3Rpb24gd2hlbiBhIG1vdXNlIGxlYXZlcyB0aGlzIFVJRWxlbWVudCAqL1xuXHRvbkxlYXZlOiBGdW5jdGlvbjtcblx0LyoqIFRoZSBldmVudCBwcm9wb2dhdGVkIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cblx0b25MZWF2ZUV2ZW50SWQ6IHN0cmluZztcblxuXHQvKiogV2hldGhlciBvciBub3QgdGhpcyBVSUVsZW1lbnQgaXMgY3VycmVudGx5IGNsaWNrZWQgb24gKi9cblx0cHJvdGVjdGVkIGlzQ2xpY2tlZDogYm9vbGVhbjtcblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgVUlFbGVtZW50IGlzIGN1cnJlbnRseSBob3ZlcmVkIG92ZXIgKi9cblx0cHJvdGVjdGVkIGlzRW50ZXJlZDogYm9vbGVhbjtcblxuXHRjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG5cdFx0XG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG5cdFx0dGhpcy5ib3JkZXJDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcblx0XHR0aGlzLmJvcmRlclJhZGl1cyA9IDU7XG5cdFx0dGhpcy5ib3JkZXJXaWR0aCA9IDE7XG5cdFx0dGhpcy5wYWRkaW5nID0gVmVjMi5aRVJPO1xuXG5cdFx0dGhpcy5vbkNsaWNrID0gbnVsbDtcblx0XHR0aGlzLm9uQ2xpY2tFdmVudElkID0gbnVsbDtcblx0XHR0aGlzLm9uUmVsZWFzZSA9IG51bGw7XG5cdFx0dGhpcy5vblJlbGVhc2VFdmVudElkID0gbnVsbDtcblxuXHRcdHRoaXMub25FbnRlciA9IG51bGw7XG5cdFx0dGhpcy5vbkVudGVyRXZlbnRJZCA9IG51bGw7XG5cdFx0dGhpcy5vbkxlYXZlID0gbnVsbDtcblx0XHR0aGlzLm9uTGVhdmVFdmVudElkID0gbnVsbDtcblxuXHRcdHRoaXMuaXNDbGlja2VkID0gZmFsc2U7XG5cdFx0dGhpcy5pc0VudGVyZWQgPSBmYWxzZTtcblx0fVxuXG5cdC8vIEBkZXByZWNhdGVkXG5cdFxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRQYWRkaW5nKHBhZGRpbmc6IFZlYzIpOiB2b2lkIHtcblx0XHR0aGlzLnBhZGRpbmcuY29weShwYWRkaW5nKTtcblx0fVxuXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuXG5cdFx0Ly8gU2VlIG9mIHRoaXMgb2JqZWN0IHdhcyBqdXN0IGNsaWNrZWRcblx0XHRpZihJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoKSl7XG5cdFx0XHRsZXQgY2xpY2tQb3MgPSBJbnB1dC5nZXRNb3VzZVByZXNzUG9zaXRpb24oKTtcblx0XHRcdGlmKHRoaXMuY29udGFpbnMoY2xpY2tQb3MueCwgY2xpY2tQb3MueSkgJiYgdGhpcy52aXNpYmxlICYmICF0aGlzLmxheWVyLmlzSGlkZGVuKCkpe1xuXHRcdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IHRydWU7XG5cblx0XHRcdFx0aWYodGhpcy5vbkNsaWNrICE9PSBudWxsKXtcblx0XHRcdFx0XHR0aGlzLm9uQ2xpY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLm9uQ2xpY2tFdmVudElkICE9PSBudWxsKXtcblx0XHRcdFx0XHRsZXQgZGF0YSA9IHt9O1xuXHRcdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkNsaWNrRXZlbnRJZCwgZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2Ugd2Fzbid0IGp1c3QgcHJlc3NlZCwgdGhlbiB3ZSBkZWZpbml0ZWx5IHdlcmVuJ3QgY2xpY2tlZFxuXHRcdGlmKCFJbnB1dC5pc01vdXNlUHJlc3NlZCgpKXtcblx0XHRcdGlmKHRoaXMuaXNDbGlja2VkKXtcblx0XHRcdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgbW91c2UgaXMgaG92ZXJpbmcgb3ZlciB0aGlzIGVsZW1lbnRcblx0XHRsZXQgbW91c2VQb3MgPSBJbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCk7XG5cdFx0aWYobW91c2VQb3MgJiYgdGhpcy5jb250YWlucyhtb3VzZVBvcy54LCBtb3VzZVBvcy55KSl7XG5cdFx0XHR0aGlzLmlzRW50ZXJlZCA9IHRydWU7XG5cblx0XHRcdGlmKHRoaXMub25FbnRlciAhPT0gbnVsbCl7XG5cdFx0XHRcdHRoaXMub25FbnRlcigpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5vbkVudGVyRXZlbnRJZCAhPT0gbnVsbCl7XG5cdFx0XHRcdGxldCBkYXRhID0ge307XG5cdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkVudGVyRXZlbnRJZCwgZGF0YSk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYodGhpcy5pc0VudGVyZWQpIHtcblx0XHRcdHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XG5cblx0XHRcdGlmKHRoaXMub25MZWF2ZSAhPT0gbnVsbCl7XG5cdFx0XHRcdHRoaXMub25MZWF2ZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYodGhpcy5vbkxlYXZlRXZlbnRJZCAhPT0gbnVsbCl7XG5cdFx0XHRcdGxldCBkYXRhID0ge307XG5cdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkxlYXZlRXZlbnRJZCwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKHRoaXMuaXNDbGlja2VkKSB7XG5cdFx0XHQvLyBJZiBtb3VzZSBpcyBkcmFnZ2VkIG9mZiBvZiBlbGVtZW50IHdoaWxlIGRvd24sIGl0IGlzIG5vdCBjbGlja2VkIGFueW1vcmVcblx0XHRcdHRoaXMuaXNDbGlja2VkID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgYmFja2dyb3VuZCBjb2xvciAtIHVzZWZ1bCBmb3IgZWxlbWVudHMgdGhhdCB3YW50IHRvIGJlIGNvbG9yZWQgb24gZGlmZmVyZW50IGFmdGVyIGNlcnRhaW4gZXZlbnRzXG5cdCAqIEByZXR1cm5zIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcblx0ICovXG5cdGNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgYm9yZGVyIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcblx0ICogQHJldHVybnMgVGhlIGJvcmRlciBjb2xvciBvZiB0aGUgVUlFbGVtZW50XG5cdCAqL1xuXHRjYWxjdWxhdGVCb3JkZXJDb2xvcigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIHRoaXMuYm9yZGVyQ29sb3I7XG5cdH1cbn0iLCJpbXBvcnQgTGFiZWwgZnJvbSBcIi4vTGFiZWxcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKiogQSBjbGlja2FibGUgYnV0dG9uIFVJRWxlbWVudCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uIGV4dGVuZHMgTGFiZWwge1xuXG5cdGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCB0ZXh0OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHBvc2l0aW9uLCB0ZXh0KTtcblx0XHRcblx0XHR0aGlzLmJhY2tncm91bmRDb2xvciA9IG5ldyBDb2xvcigxNTAsIDc1LCAyMDMpO1xuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBuZXcgQ29sb3IoNDEsIDQ2LCAzMCk7XG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0Y2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCk6IENvbG9yIHtcblx0XHQvLyBDaGFuZ2UgdGhlIGJhY2tncm91bmQgY29sb3IgaWYgY2xpY2tlZCBvciBob3ZlcmVkXG5cdFx0aWYodGhpcy5pc0VudGVyZWQgJiYgIXRoaXMuaXNDbGlja2VkKXtcblx0XHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvci5saWdodGVuKCk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuaXNDbGlja2VkKXtcblx0XHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvci5kYXJrZW4oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vVUlFbGVtZW50XCI7XG5cbi8qKiBBIGJhc2ljIHRleHQtY29udGFpbmluZyBsYWJlbCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWwgZXh0ZW5kcyBVSUVsZW1lbnQge1xuXHQvKiogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXG5cdHRleHRDb2xvcjogQ29sb3I7XG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhlIHRleHQgb2YgdGhpcyBVSUVsZW1lbnQgKi9cblx0dGV4dDogc3RyaW5nO1xuXHQvKiogVGhlIG5hbWUgb2YgdGhlIGZvbnQgKi9cblx0Zm9udDogc3RyaW5nO1xuXHQvKiogVGhlIHNpemUgb2YgdGhlIGZvbnQgKi9cblx0Zm9udFNpemU6IG51bWJlcjtcblx0LyoqIFRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGUgdGV4dCB3aXRoaW4gdGhlIGxhYmVsICovXG5cdHByb3RlY3RlZCBoQWxpZ246IHN0cmluZztcblx0LyoqIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGV4dCB3aXRoaW4gdGhlIGxhYmVsICovXG5cdHByb3RlY3RlZCB2QWxpZ246IHN0cmluZztcblxuXHQvKiogQSBmbGFnIGZvciBpZiB0aGUgd2lkdGggb2YgdGhlIHRleHQgaGFzIGJlZW4gbWVhc3VyZWQgb24gdGhlIGNhbnZhcyBmb3IgYXV0byB3aWR0aCBhc3NpZ25tZW50ICovXG5cdHByb3RlY3RlZCBzaXplQXNzaWduZWQ6IGJvb2xlYW47XG5cblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZykge1xuXHRcdHN1cGVyKHBvc2l0aW9uKTtcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXHRcdHRoaXMudGV4dENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xuXHRcdHRoaXMuZm9udCA9IFwiQXJpYWxcIjtcblx0XHR0aGlzLmZvbnRTaXplID0gMzA7XG5cdFx0dGhpcy5oQWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdHRoaXMudkFsaWduID0gXCJjZW50ZXJcIjtcblx0XHR0aGlzLmJvcmRlcldpZHRoID0gMDtcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IGZhbHNlO1xuXHR9XG5cblx0Ly8gQGRlcHJlY2F0ZWRcblx0c2V0VGV4dCh0ZXh0OiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXHR9XG5cdHNldFNpemUobmV3U2l6ZTpWZWMyKTp2b2lke1xuXHRcdHRoaXMuc2l6ZSA9IG5ld1NpemU7XG5cdH1cblx0Ly8gQGRlcHJlY2F0ZWRcblx0c2V0VGV4dENvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdHRoaXMudGV4dENvbG9yID0gY29sb3I7XG5cdH1cblx0c2V0QmFja2dyb3VuZENvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG5cdH1cblx0c2V0Qm9yZGVyV2lkdGgobnVtOm51bWJlcik6dm9pZHtcblx0XHR0aGlzLmJvcmRlcldpZHRoPW51bTtcblx0fVxuXHRzZXRCb3JkZXJDb2xvcihjb2xvcjogQ29sb3IpOnZvaWQge1xuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBjb2xvcjtcblx0fVxuXHQvKipcblx0ICogR2V0cyBhIHN0cmluZyBjb250YWluZyB0aGUgZm9udCBkZXRhaWxzIGZvciByZW5kZXJpbmdcblx0ICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgZm9udCBkZXRhaWxzXG5cdCAqL1xuXHRnZXRGb250U3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuZm9udFNpemUgKyBcInB4IFwiICsgdGhpcy5mb250O1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgdGV4dCBjb2xvciAtIHVzZWZ1bCBmb3IgZWxlbWVudHMgdGhhdCB3YW50IHRvIGJlIGNvbG9yZWQgb24gZGlmZmVyZW50IGFmdGVyIGNlcnRhaW4gZXZlbnRzXG5cdCAqIEByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5nIHRoZSB0ZXh0IGNvbG9yXG5cdCAqL1xuXHRjYWxjdWxhdGVUZXh0Q29sb3IoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy50ZXh0Q29sb3IudG9TdHJpbmdSR0JBKCk7XG5cdH1cblxuXHQvKipcblx0ICogVXNlcyB0aGUgY2FudmFzIHRvIGNhbGN1bGF0ZSB0aGUgd2lkdGggb2YgdGhlIHRleHRcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcblx0ICogQHJldHVybnMgQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSByZW5kZXJlZCB0ZXh0IHdpZHRoXG5cdCAqL1xuXHRwcm90ZWN0ZWQgY2FsY3VsYXRlVGV4dFdpZHRoKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogbnVtYmVyIHtcblx0XHRjdHguZm9udCA9IHRoaXMuZm9udFNpemUgKyBcInB4IFwiICsgdGhpcy5mb250O1xuXHRcdHJldHVybiBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcblx0fVxuXG5cdHNldEhBbGlnbihhbGlnbjogc3RyaW5nKTogdm9pZCB7XG5cdFx0dGhpcy5oQWxpZ24gPSBhbGlnbjtcblx0fVxuXG5cdHNldFZBbGlnbihhbGlnbjogc3RyaW5nKTogdm9pZCB7XG5cdFx0dGhpcy52QWxpZ24gPSBhbGlnbjtcblx0fVxuXHRzZXRGb250U2l6ZShzaXplOiBudW1iZXIpOiB2b2lkIHtcblx0XHR0aGlzLmZvbnRTaXplID0gc2l6ZTtcblx0fVxuXHRzZXRGb250KGZvbnQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMuZm9udCA9IGZvbnQ7XG5cdH1cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSB0ZXh0IC0gdGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcgdGV4dCB3aXRoIGRpZmZlcmVudCBhbGlnbm1lbnRzXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqIEByZXR1cm5zIFRoZSBvZmZzZXQgb2YgdGhlIHRleHQgaW4gYSBWZWMyXG5cdCAqL1xuXHRjYWxjdWxhdGVUZXh0T2Zmc2V0KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogVmVjMiB7XG5cdFx0bGV0IHRleHRXaWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XG5cblx0XHRsZXQgb2Zmc2V0ID0gbmV3IFZlYzIoMCwgMCk7XG5cblx0XHRsZXQgaERpZmYgPSB0aGlzLnNpemUueCAtIHRleHRXaWR0aDtcblx0XHRpZiAodGhpcy5oQWxpZ24gPT09IEhBbGlnbi5DRU5URVIpIHtcblx0XHRcdG9mZnNldC54ID0gaERpZmYgLyAyO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5oQWxpZ24gPT09IEhBbGlnbi5SSUdIVCkge1xuXHRcdFx0b2Zmc2V0LnggPSBoRGlmZjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy52QWxpZ24gPT09IFZBbGlnbi5UT1ApIHtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuXHRcdFx0b2Zmc2V0LnkgPSAwO1xuXHRcdH0gZWxzZSBpZiAodGhpcy52QWxpZ24gPT09IFZBbGlnbi5CT1RUT00pIHtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuXHRcdFx0b2Zmc2V0LnkgPSB0aGlzLnNpemUueTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG5cdFx0XHRvZmZzZXQueSA9IHRoaXMuc2l6ZS55IC8gMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9XG5cblx0cHJvdGVjdGVkIHNpemVDaGFuZ2VkKCk6IHZvaWQge1xuXHRcdHN1cGVyLnNpemVDaGFuZ2VkKCk7XG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEF1dG9tYXRpY2FsbHkgc2l6ZXMgdGhlIGVsZW1lbnQgdG8gdGhlIHRleHQgd2l0aGluIGl0XG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRwcm90ZWN0ZWQgYXV0b1NpemUoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkIHtcblx0XHRsZXQgd2lkdGggPSB0aGlzLmNhbGN1bGF0ZVRleHRXaWR0aChjdHgpO1xuXHRcdGxldCBoZWlnaHQgPSB0aGlzLmZvbnRTaXplO1xuXHRcdHRoaXMuc2l6ZS5zZXQod2lkdGggKyB0aGlzLnBhZGRpbmcueCAqIDIsIGhlaWdodCArIHRoaXMucGFkZGluZy55ICogMik7XG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxseSBhc3NpZ25zIGEgc2l6ZSB0byB0aGUgVUlFbGVtZW50IGlmIG5vbmUgaXMgcHJvdmlkZWRcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdGhhbmRsZUluaXRpYWxTaXppbmcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkIHtcblx0XHRpZiAoIXRoaXMuc2l6ZUFzc2lnbmVkKSB7XG5cdFx0XHR0aGlzLmF1dG9TaXplKGN0eCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIE9uIHRoZSBuZXh0IHJlbmRlciwgc2l6ZSB0aGlzIGVsZW1lbnQgdG8gaXQncyBjdXJyZW50IHRleHQgdXNpbmcgaXRzIGN1cnJlbnQgZm9udCBzaXplICovXG5cdHNpemVUb1RleHQoKTogdm9pZCB7XG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSBmYWxzZTtcblx0fVxufVxuXG5leHBvcnQgZW51bSBWQWxpZ24ge1xuXHRUT1AgPSBcInRvcFwiLFxuXHRDRU5URVIgPSBcImNlbnRlclwiLFxuXHRCT1RUT00gPSBcImJvdHRvbVwiXG59XG5cbmV4cG9ydCBlbnVtIEhBbGlnbiB7XG5cdExFRlQgPSBcImxlZnRcIixcblx0Q0VOVEVSID0gXCJjZW50ZXJcIixcblx0UklHSFQgPSBcInJpZ2h0XCJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vSW5wdXQvSW5wdXRcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vVUlFbGVtZW50XCI7XG5cbi8qKiBBIHNsaWRlciBVSUVsZW1lbnQgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsaWRlciBleHRlbmRzIFVJRWxlbWVudCB7XG4gICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyIGZyb20gWzAsIDFdICovXG4gICAgcHJvdGVjdGVkIHZhbHVlOiBudW1iZXI7XG4gICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgc2xpZGVyIG5pYiAqL1xuICAgIHB1YmxpYyBuaWJDb2xvcjogQ29sb3I7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBuaWIgKi9cbiAgICBwdWJsaWMgbmliU2l6ZTogVmVjMjtcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgdHJhY2sgKi9cbiAgICBwdWJsaWMgc2xpZGVyQ29sb3I6IENvbG9yO1xuICAgIC8qKiBUaGUgcmVhY3Rpb24gb2YgdGhpcyBVSUVsZW1lbnQgdG8gYSB2YWx1ZSBjaGFuZ2UgKi9cbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZTogRnVuY3Rpb247XG4gICAgLyoqIFRoZSBldmVudCBwcm9wYWdhdGVkIGJ5IHRoaXMgVUlFbGVtZW50IHdoZW4gdmFsdWUgY2hhbmdlcyAqL1xuICAgIHB1YmxpYyBvblZhbHVlQ2hhbmdlRXZlbnRJZDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIGluaXRWYWx1ZTogbnVtYmVyKXtcbiAgICAgICAgc3VwZXIocG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSBpbml0VmFsdWU7XG4gICAgICAgIHRoaXMubmliQ29sb3IgPSBDb2xvci5SRUQ7XG4gICAgICAgIHRoaXMuc2xpZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xuICAgICAgICB0aGlzLm5pYlNpemUgPSBuZXcgVmVjMigxMCwgMjApO1xuXG4gICAgICAgIC8vIFNldCBhIGRlZmF1bHQgc2l6ZVxuICAgICAgICB0aGlzLnNpemUuc2V0KDIwMCwgMjApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgdGhlIHNsaWRlclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXG4gICAgICovXG4gICAgZ2V0VmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqIEEgbWV0aG9kIGNhbGxlZCBpbiByZXNwb25zZSB0byB0aGUgdmFsdWUgY2hhbmdpbmcgKi9cbiAgICBwcm90ZWN0ZWQgdmFsdWVDaGFuZ2VkKCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLm9uVmFsdWVDaGFuZ2Upe1xuICAgICAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5vblZhbHVlQ2hhbmdlRXZlbnRJZCl7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25WYWx1ZUNoYW5nZUV2ZW50SWQsIHt0YXJnZXQ6IHRoaXMsIHZhbHVlOiB0aGlzLnZhbHVlfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgaWYodGhpcy5pc0NsaWNrZWQpe1xuICAgICAgICAgICAgbGV0IHZhbCA9IE1hdGhVdGlscy5pbnZMZXJwKHRoaXMucG9zaXRpb24ueCAtIHRoaXMuc2l6ZS54LzIsIHRoaXMucG9zaXRpb24ueCArIHRoaXMuc2l6ZS54LzIsIElucHV0LmdldE1vdXNlUG9zaXRpb24oKS54KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoVXRpbHMuY2xhbXAwMSh2YWwpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9JbnB1dC9JbnB1dFwiO1xuXG4vKiogQSB0ZXh0IGlucHV0IFVJRWxlbWVudCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dElucHV0IGV4dGVuZHMgTGFiZWwge1xuICAgIC8qKiBBIGZsYWcgdGhlIHJlcHJlc2VudHMgd2hldGhlciB0aGUgdXNlciBjYW4gdHlwZSBpbiB0aGlzIFRleHRJbnB1dCAqL1xuICAgIGZvY3VzZWQ6IGJvb2xlYW47XG4gICAgLyoqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIGluIHRoaXMgVGV4dElucHV0ICovXG4gICAgY3Vyc29yQ291bnRlcjogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xuICAgICAgICBzdXBlcihwb3NpdGlvbiwgXCJcIik7XG5cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yQ291bnRlciA9IDA7XG5cbiAgICAgICAgLy8gR2l2ZSBhIGRlZmF1bHQgc2l6ZSB0byB0aGUgeCBvbmx5XG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoMjAwLCB0aGlzLmZvbnRTaXplKTtcbiAgICAgICAgdGhpcy5oQWxpZ24gPSBcImxlZnRcIjtcblxuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuQkxBQ0s7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuV0hJVEU7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcblx0XHRcdGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpO1xuXHRcdFx0aWYodGhpcy5jb250YWlucyhjbGlja1Bvcy54LCBjbGlja1Bvcy55KSl7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvckNvdW50ZXIgPSAzMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmZvY3VzZWQpe1xuICAgICAgICAgICAgbGV0IGtleXMgPSBJbnB1dC5nZXRLZXlzSnVzdFByZXNzZWQoKTtcbiAgICAgICAgICAgIGxldCBudW1zID0gXCIxMjM0NTY3ODkwXCI7XG4gICAgICAgICAgICBsZXQgc3BlY2lhbENoYXJzID0gXCJgfiFAIyQlXiYqKCktXz0rW3tdfVxcXFx8OzonXFxcIiw8Lj4vP1wiO1xuICAgICAgICAgICAgbGV0IGxldHRlcnMgPSBcInF3ZXJ0eXVpb3Bhc2RmZ2hqa2x6eGN2Ym5tXCI7XG4gICAgICAgICAgICBsZXQgbWFzayA9IG51bXMgKyBzcGVjaWFsQ2hhcnMgKyBsZXR0ZXJzO1xuICAgICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiBtYXNrLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgbGV0IHNoaWZ0UHJlc3NlZCA9IElucHV0LmlzS2V5UHJlc3NlZChcInNoaWZ0XCIpO1xuICAgICAgICAgICAgbGV0IGJhY2tzcGFjZVByZXNzZWQgPSBJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiYmFja3NwYWNlXCIpO1xuICAgICAgICAgICAgbGV0IHNwYWNlUHJlc3NlZCA9IElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJzcGFjZVwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoYmFja3NwYWNlUHJlc3NlZCl7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnN1YnN0cmluZygwLCB0aGlzLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoc3BhY2VQcmVzc2VkKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gXCIgXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYoc2hpZnRQcmVzc2VkKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGtleXNbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0ga2V5c1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiZXhwb3J0IGVudW0gVUlFbGVtZW50VHlwZSB7XG5cdEJVVFRPTiA9IFwiQlVUVE9OXCIsXG5cdExBQkVMID0gXCJMQUJFTFwiLFxuXHRTTElERVIgPSBcIlNMSURFUlwiLFxuXHRURVhUX0lOUFVUID0gXCJURVhUSU5QVVRcIlxufSIsImltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9QYXRoZmluZGluZy9OYXZpZ2FibGVcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi9OYXZtZXNoXCI7XG5cbi8qKlxuICogVGhlIG1hbmFnZXIgY2xhc3MgZm9yIG5hdmlnYXRpb24uXG4gKiBIYW5kbGVzIGFsbCBuYXZpZ2FibGUgZW50aXRpZXMsIHN1Y2ggYW5kIGFsbG93cyB0aGVtIHRvIGJlIGFjY2Vzc2VkIGJ5IG91dHNpZGUgc3lzdGVtcyBieSByZXF1ZXN0aW5nIGEgcGF0aFxuICogZnJvbSBvbmUgcG9zaXRpb24gdG8gYW5vdGhlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvbk1hbmFnZXIge1xuXHQvKiogVGhlIGxpc3Qgb2YgYWxsIG5hdmlnYWJsZSBlbnRpdGllcyAqL1xuXHRwcm90ZWN0ZWQgbmF2aWdhYmxlRW50aXRpZXM6IE1hcDxOYXZtZXNoPjtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMubmF2aWdhYmxlRW50aXRpZXMgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5hdmlnYWJsZSBlbnRpdHkgdG8gdGhlIE5hdmlnYXRpb25NYW5hZ2VyXG5cdCAqIEBwYXJhbSBuYXZOYW1lIFRoZSBuYW1lIG9mIHRoZSBuYXZpZ2FibGUgZW50aXRyeVxuXHQgKiBAcGFyYW0gbmF2IFRoZSBhY3R1YWwgTmF2aWdhYmxlIGluc3RhbmNlXG5cdCAqL1xuXHRhZGROYXZpZ2FibGVFbnRpdHkobmF2TmFtZTogc3RyaW5nLCBuYXY6IE5hdm1lc2gpOiB2b2lkIHtcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmFkZChuYXZOYW1lLCBuYXYpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgYSBwYXRoIGZyb21lIG9uZSBwb2ludCB0byBhbm90aGVyIHVzaW5nIGEgc3BlY2lmaWVkIE5hdmlnYWJsZSBvYmplY3Rcblx0ICogQHBhcmFtIG5hdk5hbWUgVGhlIG5hbWUgb2YgdGhlIHJlZ2lzdGVyZWQgTmF2aWdhYmxlIG9iamVjdFxuXHQgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiBuYXZpZ2F0aW9uXG5cdCAqIEBwYXJhbSB0b1Bvc2l0aW9uIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgTmF2aWdhdGlvblxuXHQgKiBAcGFyYW0gZGlyZWN0IElmIHRydWUsIGdvIGRpcmVjdCBmcm9tIGZyb21Qb3NpdGlvbiB0byB0b1Bvc2l0aW9uLCBkb24ndCB1c2UgTmF2TWVzaFxuXHQgKiBAcmV0dXJucyBBIE5hdmlnYXRpb25QYXRoIGNvbnRhaW5pbmcgdGhlIHJvdXRlIHRvIHRha2Ugb3ZlciB0aGUgTmF2aWdhYmxlIGVudGl0eSB0byBnZXQgYmV0d2VlbiB0aGUgcHJvdmlkZWQgcG9zaXRpb25zLlxuXHQgKi9cblx0Z2V0UGF0aChuYXZOYW1lOiBzdHJpbmcsIGZyb21Qb3NpdGlvbjogVmVjMiwgdG9Qb3NpdGlvbjogVmVjMik6IE5hdmlnYXRpb25QYXRoIHtcblx0XHRsZXQgbmF2ID0gdGhpcy5uYXZpZ2FibGVFbnRpdGllcy5nZXQobmF2TmFtZSk7XG5cdFx0cmV0dXJuIG5hdi5nZXROYXZpZ2F0aW9uUGF0aChmcm9tUG9zaXRpb24uY2xvbmUoKSwgdG9Qb3NpdGlvbi5jbG9uZSgpKTtcblx0fVxufSIsImltcG9ydCBTdGFjayBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL1N0YWNrXCI7XG5pbXBvcnQgUGF0aCBmcm9tIFwiLi4vRGF0YVR5cGVzL1BhdGhmaW5kaW5nL1BhdGhcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuXG4vKipcbiAqIEEgcGF0aCB0aGF0IEFJcyBjYW4gZm9sbG93LiBVc2VzIGZpbmlzaE1vdmUoKSBpbiBQaHlzaWNhbCB0byBkZXRlcm1pbmUgcHJvZ3Jlc3Mgb24gdGhlIHJvdXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25QYXRoIGltcGxlbWVudHMgUGF0aDxWZWMyPiB7XG5cdC8qKiBUaGUgbmF2aWdhdGlvbiBwYXRoLCBzdG9yZWQgYXMgYSBzdGFjayBvZiBuZXh0IHBvc2l0aW9ucyAqL1xuXHRwcm90ZWN0ZWQgcGF0aDogU3RhY2s8VmVjMj47XG5cdC8qKiBUaGUgY3VycmVudCBkaXJlY3Rpb24gb2YgbW92ZW1lbnQgKi9cblx0cHJvdGVjdGVkIGN1cnJlbnRNb3ZlRGlyZWN0aW9uOiBWZWMyO1xuXHQvKiogVGhlIGRpc3RhbmNlIGEgbm9kZSBtdXN0IGJlIHRvIGEgcG9pbnQgdG8gY29uc2lkZXIgaXQgYXMgaGF2aW5nIGFycml2ZWQgKi9cblx0cHJvdGVjdGVkIGRpc3RhbmNlVGhyZXNob2xkOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgTmF2aWdhdGlvblBhdGhcblx0ICogQHBhcmFtIHBhdGggVGhlIHBhdGggb2Ygbm9kZXMgdG8gdGFrZVxuXHQgKi9cblx0Y29uc3RydWN0b3IocGF0aDogU3RhY2s8VmVjMj4pe1xuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5jdXJyZW50TW92ZURpcmVjdGlvbiA9IFZlYzIuWkVSTztcblx0XHR0aGlzLmRpc3RhbmNlVGhyZXNob2xkID0gNDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGF0dXMgb2YgbmF2aWdhdGlvbiBhbG9uZyB0aGlzIE5hdmlnYXRpb25QYXRoXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5vZGUgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGF0aCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRpc0RvbmUoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMucGF0aC5pc0VtcHR5KCk7XG5cdH1cblxuICAgIG5leHQoKTogVmVjMiB8IG51bGwgeyByZXR1cm4gdGhpcy5wYXRoLmlzRW1wdHkoKSA/IG51bGwgOiB0aGlzLnBhdGgucGVlaygpOyB9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG1vdmVtZW50IGRpcmVjdGlvbiBpbiB0aGUgY3VycmVudCBwb3NpdGlvbiBhbG9uZyB0aGUgcGF0aFxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBtb3ZlIGFsb25nIHRoZSBwYXRoXG5cdCAqIEByZXR1cm5zIFRoZSBtb3ZlbWVudCBkaXJlY3Rpb24gYXMgYSBWZWMyXG5cdCAqL1xuXHRnZXRNb3ZlRGlyZWN0aW9uKG5vZGU6IEdhbWVOb2RlKTogVmVjMiB7XG5cdFx0Ly8gUmV0dXJuIGRpcmVjdGlvbiB0byBuZXh0IHBvaW50IGluIHRoZSBuYXZcblx0XHRyZXR1cm4gbm9kZS5wb3NpdGlvbi5kaXJUbyh0aGlzLnBhdGgucGVlaygpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoaXMgTmF2aWdhdGlvblBhdGggdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIEdhbWVOb2RlXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIG1vdmluZyBhbG9uZyB0aGUgcGF0aFxuXHQgKi9cblx0aGFuZGxlUGF0aFByb2dyZXNzKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG5cdFx0aWYoIXRoaXMucGF0aC5pc0VtcHR5KCkgJiYgbm9kZS5wb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5wYXRoLnBlZWsoKSkgPCB0aGlzLmRpc3RhbmNlVGhyZXNob2xkKnRoaXMuZGlzdGFuY2VUaHJlc2hvbGQpe1xuXHRcdFx0Ly8gV2UndmUgcmVhY2hlZCBvdXIgbm9kZSwgbW92ZSBvbiB0byB0aGUgbmV4dCBkZXN0aW5hdGlvblxuXHRcdFx0dGhpcy5wYXRoLnBvcCgpO1xuXHRcdH1cblx0fVxuXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpXG5cdH1cblxuXHRkaXN0YW5jZSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnBhdGguc2l6ZSgpO1xuXHR9XG59IiwiaW1wb3J0IFBvc2l0aW9uR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaFwiO1xuaW1wb3J0IE5hdmlnYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1BhdGhmaW5kaW5nL05hdmlnYWJsZVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcbmltcG9ydCBOYXZpZ2F0aW9uU3RyYXRlZ3kgZnJvbSBcIi4vU3RyYXRlZ2llcy9OYXZpZ2F0aW9uU3RyYXRlZ3lcIjtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIE5hdm1lc2guIE5hdm1lc2hlcyBhcmUgZ3JhcGhzIGluIHRoZSBnYW1lIHdvcmxkIGFsb25nIHdoaWNoIG5vZGVzIGNhbiBtb3ZlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZtZXNoIGltcGxlbWVudHMgTmF2aWdhYmxlPFZlYzIsIE5hdmlnYXRpb25QYXRoPiB7XG5cdC8qKiBUaGUgZ3JhcGggb2YgcG9pbnRzIGluIHRoZSBOYXZNZXNoICovXG5cdHByb3RlY3RlZCBfZ3JhcGg6IFBvc2l0aW9uR3JhcGg7XG4gICAgLyoqIFRoZSBzdHJhdGVneSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBOYXZpZ2F0aW9uUGF0aCAqL1xuICAgIHByb3RlY3RlZCBfc3RyYXRlZ2llczogTWFwPHN0cmluZywgTmF2aWdhdGlvblN0cmF0ZWd5PjtcbiAgICAvKiogVGhlIHN0cmF0ZWd5IGN1cnJlbnRseSBiZWluZyB1c2VkIHRvIGdlbmVyYXRlIHBhdGhzIG9uIHRoaXMgTmF2bWVzaCAqL1xuICAgIHByb3RlY3RlZCBfc3RyYXRlZ3k6IE5hdmlnYXRpb25TdHJhdGVneSB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBOYXZtZXNoIGZyb20gdGhlIHBvaW50cyBpbiB0aGUgc3BlZWNpZmllZCBncmFwaC4gTmF2aWdhdGlvbiBpcyBkb25lIHVzaW5nIHRoZSBcbiAgICAgKiBnaXZlbiBOYXZpZ2F0aW9uU3RyYXRlZ3kuIFxuXHQgKiBAcGFyYW0gZ3JhcGggdGhlIGdyYXBoIHRvIGNvbnN0cnVjdCBhIG5hdm1lc2ggZnJvbVxuICAgICAqIEBwYXJhbSBzdHJhdGVneSBhIGNvbnN0cnVjdG9yIGZvciBzdHJhdGVneSB0byB1c2UgdG8gYnVpbGQgcGF0aHMgZm9yIHRoaXMgbmF2bWVzaFxuXHQgKi9cblx0cHVibGljIGNvbnN0cnVjdG9yKGdyYXBoOiBQb3NpdGlvbkdyYXBoKXtcblx0XHR0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICAgICAgICB0aGlzLl9zdHJhdGVnaWVzID0gbmV3IE1hcDxzdHJpbmcsIE5hdmlnYXRpb25TdHJhdGVneT4oKTtcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSB1bmRlZmluZWQ7XG5cdH1cblxuICAgIHB1YmxpYyBnZXQgZ3JhcGgoKTogUG9zaXRpb25HcmFwaCB7IHJldHVybiB0aGlzLl9ncmFwaDsgfVxuXG4gICAgcHVibGljIHNldFN0cmF0ZWd5KHN0cmF0ZWd5OiBzdHJpbmcpIHsgdGhpcy5fc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVnaWVzLmdldChzdHJhdGVneSk7IH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0Z2V0TmF2aWdhdGlvblBhdGgoZnJvbVBvc2l0aW9uOiBWZWMyLCB0b1Bvc2l0aW9uOiBWZWMyKTogTmF2aWdhdGlvblBhdGgge1xuICAgICAgICBpZiAodGhpcy5fc3RyYXRlZ3kgPT09IHVuZGVmaW5lZCkgeyBcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yLk5vIHBhdGhmaW5kaW5nIHN0cmF0ZWd5IHNldCBmb3IgdGhpcyBuYXZtZXNoLlwiKTtcbiAgICAgICAgfVxuXHRcdHJldHVybiB0aGlzLl9zdHJhdGVneS5idWlsZFBhdGgodG9Qb3NpdGlvbiwgZnJvbVBvc2l0aW9uKTtcblx0fVxuXG4gICAgcmVnaXN0ZXJTdHJhdGVneShrZXk6IHN0cmluZywgc3RyYXRlZ3k6IE5hdmlnYXRpb25TdHJhdGVneSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdHJhdGVnaWVzLnNldChrZXksIHN0cmF0ZWd5KTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgUGF0aFN0cmF0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvUGF0aGZpbmRpbmcvUGF0aFN0cmF0ZWd5XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vTmF2aWdhdGlvblBhdGhcIjtcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuLi9OYXZtZXNoXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgbmF2aWdhdGlvbiBzdHJhdGVneSBmb3IgV29sZmllMkRzIG5hdmlnYXRpb24gc3lzdGVtLiBZb3UgY2FuIGV4dGVuZCB0aGlzIGNsYXNzIHRvIGNyZWF0ZVxuICogeW91ciBvd24gc3RyYXRlZ3kgZm9yIGNvbnN0cnVjdGluZyBhIE5hdmlnYXRpb25QYXRoIGZvciB0aGUgbmF2aWdhdGlvbiBzeXN0ZW0uXG4gKiBAYXV0aG9yIFBldGV5THVtcGtpbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgTmF2aWdhdGlvblN0cmF0ZWd5IGltcGxlbWVudHMgUGF0aFN0cmF0PFZlYzIsIE5hdmlnYXRpb25QYXRoPiB7XG5cbiAgICAvKiogVGhlIE5hdm1lc2ggd2UncmUgY3JlYXRpbmcgcGF0aHMgZm9yICovXG4gICAgcHJvdGVjdGVkIF9tZXNoOiBOYXZtZXNoO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKG1lc2g6IE5hdm1lc2gpIHtcbiAgICAgICAgdGhpcy5tZXNoID0gbWVzaFxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgbWVzaCgpOiBOYXZtZXNoeyByZXR1cm4gdGhpcy5fbWVzaDsgfVxuICAgIHByb3RlY3RlZCBzZXQgbWVzaChtZXNoOiBOYXZtZXNoKSB7IHRoaXMuX21lc2ggPSBtZXNoOyB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgbmV3IE5hdmlnYXRpb25QYXRoLiBIb3cgdGhlIHBhdGggaXMgY29uc3RydWN0ZWQgaXMgaW1wbGVtZW50YXRpb24gc3BlY2lmaWMuXG4gICAgICogQHBhcmFtIHRvIHRoZSBwb3NpdGlvbiB0byBuYXZpZ2F0ZSB0b1xuICAgICAqIEBwYXJhbSBmcm9tIHRoZSBwb3NpdGlvbiB0byBuYXZpZ2F0ZSBmcm9tXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGJ1aWxkUGF0aCh0bzogVmVjMiwgZnJvbTogVmVjMik6IE5hdmlnYXRpb25QYXRoO1xuICAgIFxufSIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4vUGh5c2ljc01hbmFnZXJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IEFyZWFDb2xsaXNpb24gZnJvbSBcIi4uL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb25cIjtcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xuXG4vKipcbiAqIEFMR09SSVRITTpcbiAqIFx0SW4gYW4gZWZmb3J0IHRvIGtlZXAgdGhpbmdzIHNpbXBsZSBhbmQgd29ya2luZyBlZmZlY3RpdmVseSwgZWFjaCBkeW5hbWljIG5vZGUgd2lsbCByZXNvbHZlIGl0c1xuICogXHRjb2xsaXNpb25zIGNvbnNpZGVyaW5nIHRoZSByZXN0IG9mIHRoZSB3b3JsZCBhcyBzdGF0aWMuXG4gKiBcbiAqIFx0Q29sbGlzaW9uIGRldGVjdGluZyB3aWxsIGhhcHBlbiBmaXJzdC4gVGhpcyBjYW4gYmUgY29uc2lkZXJlZCBhIGJyb2FkIHBoYXNlLCBidXQgaXQgaXMgbm90IGVzcGVjaWFsbHlcbiAqIFx0ZWZmaWNpZW50LCBhcyBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIGZvciB0aGlzIGdhbWUgZW5naW5lLiBFdmVyeSBkeW5hbWljIG5vZGUgaXMgY2hlY2tlZCBhZ2FpbnN0IGV2ZXJ5XG4gKiBcdG90aGVyIG5vZGUgZm9yIGNvbGxpc2lvbiBhcmVhLiBJZiBjb2xsaXNpb24gYXJlYSBpcyBub24temVybyAobWVhbmluZyB0aGUgY3VycmVudCBub2RlIHN3ZWVwcyBpbnRvIGFub3RoZXIpLFxuICogXHRpdCBpcyBhZGRlZCB0byBhIGxpc3Qgb2YgaGl0cy5cbiAqIFxuICogXHRJTklUSUFMSVpBVElPTjpcbiAqIFx0XHQtIFBoeXNpY3MgY29uc3RhbnRzIGFyZSByZXNldFxuICogXHRcdC0gU3dlcHQgc2hhcGVzIGFyZSByZWNhbGN1bGF0ZWQuIElmIGEgbm9kZSBpc24ndCBtb3ZpbmcsIGl0IGlzIHNraXBwZWQuXG4gKiBcbiAqIFx0Q09MTElTSU9OIERFVEVDVElPTjpcbiAqIFx0XHQtIEZvciBhIG5vZGUsIGNvbGxpc2lvbiBhcmVhIHdpbGwgYmUgY2FsY3VsYXRlZCB1c2luZyB0aGUgc3dlcHQgQUFCQiBvZiB0aGUgbm9kZSBhZ2FpbnN0IGV2ZXJ5IG90aGVyIEFBQkIgaW4gYSBzdGF0aWMgc3RhdGVcbiAqIFx0XHQtIFRoZXNlIGNvbGxpc2lvbnMgd2lsbCBiZSBzb3J0ZWQgYnkgYXJlYSBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gKiBcdFxuICogXHRDT0xMSVNJT04gUkVTT0xVVElPTjpcbiAqIFx0XHQtIEZvciBlYWNoIGhpdCwgdGltZSBvZiBjb2xsaXNpb24gaXMgY2FsY3VsYXRlZCB1c2luZyBhIHN3ZXB0IGxpbmUgdGhyb3VnaCB0aGUgQUFCQiBvZiB0aGUgc3RhdGljIG5vZGUgZXhwYW5kZWRcbiAqIFx0XHRcdHdpdGggbWlua293c2tpIHN1bXMgKGRpc2NyZXRlbHksIGJ1dCB0aGUgY29uY2VwdCBpcyB0aGVyZSlcbiAqIFx0XHQtIFRoZSBjb2xsaXNpb24gaXMgcmVzb2x2ZWQgYmFzZWQgb24gdGhlIG5lYXIgdGltZSBvZiB0aGUgY29sbGlzaW9uIChmcm9tIG1ldGhvZCBvZiBzZXBhcmF0ZWQgYXhlcylcbiAqIFx0XHRcdC0gWCBpcyByZXNvbHZlZCBieSBuZWFyIHgsIFkgYnkgbmVhciB5LlxuICogXHRcdFx0LSBUaGVyZSBpcyBzb21lIGZ1ZGdpbmcgdG8gYWxsb3cgZm9yIHNsaWRpbmcgYWxvbmcgd2FsbHMgb2Ygc2VwYXJhdGUgY29sbGlkZXJzLiBTb3J0aW5nIGJ5IGFyZWEgYWxzbyBoZWxwcyB3aXRoIHRoaXMuXG4gKiBcdFx0XHQtIENvcm5lciB0byBjb3JuZXIgY29sbGlzaW9ucyBhcmUgcmVzb2x2ZSB0byBmYXZvciB4LW1vdmVtZW50LiBUaGlzIGlzIGluIGNvbnNpZGVyYXRpb24gb2YgcGxhdGZvcm1lcnMsIHRvIGdpdmVcbiAqIFx0XHRcdFx0dGhlIHBsYXllciBzb21lIGhlbHAgd2l0aCBqdW1wc1xuICogXG4gKiBcdFByb3M6XG4gKiBcdFx0LSBFdmVyeXRoaW5nIGhhcHBlbnMgd2l0aCBhIGNvbnNpc3RlbnQgdGltZS4gVGhlcmUgaXMgYSBkaXN0aW5jdCBiZWZvcmUgYW5kIGFmdGVyIGZvciBlYWNoIHJlc29sdXRpb24uXG4gKiBcdFx0LSBObyBiYWNrLXRyYWNraW5nIG5lZWRzIHRvIGJlIGRvbmUuIE9uY2Ugd2UgcmVzb2x2ZSBhIG5vZGUsIGl0IGlzIGRlZmluaXRpdmVseSByZXNvbHZlZC5cbiAqIFx0XG4gKiBcdENvbnM6XG4gKiBcdFx0LSBOb2RlcyB0aGF0IGFyZSBwcm9jZXNzZWQgZWFybHkgaGF2ZSBtb3ZlbWVudCBwcmlvcml0eSBvdmVyIG90aGVyIG5vZGVzLiBUaGlzIGNhbiBsZWFkIHRvIHNvbWUgdW5kZXNpcmFibGUgaW50ZXJhY3Rpb25zLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BoeXNpY3NNYW5hZ2VyIGV4dGVuZHMgUGh5c2ljc01hbmFnZXIge1xuXG5cdC8qKiBUaGUgYXJyYXkgb2Ygc3RhdGljIG5vZGVzICovXG5cdHByb3RlY3RlZCBzdGF0aWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xuXG5cdC8qKiBUaGUgYXJyYXkgb2YgZHluYW1pYyBub2RlcyAqL1xuXHRwcm90ZWN0ZWQgZHluYW1pY05vZGVzOiBBcnJheTxQaHlzaWNhbD47XG5cblx0LyoqIFRoZSBhcnJheSBvZiB0aWxlbWFwcyAqL1xuXHRwcm90ZWN0ZWQgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xuXG5cdC8qKiBBbiBhcnJheSBvZiB0aGUgY29sbGlzaW9uIG1hc2tzIGZvciBlYWNoIGdyb3VwICovXG5cdHByb3RlY3RlZCBjb2xsaXNpb25NYXNrczogQXJyYXk8bnVtYmVyPjtcblxuXHRjb25zdHJ1Y3RvcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuc3RhdGljTm9kZXMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmR5bmFtaWNOb2RlcyA9IG5ldyBBcnJheSgpO1xuXHRcdHRoaXMudGlsZW1hcHMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmNvbGxpc2lvbk1hc2tzID0gbmV3IEFycmF5KDMyKTtcblxuXHRcdC8vIFBhcnNlIG9wdGlvbnNcblx0XHR0aGlzLnBhcnNlT3B0aW9ucyhvcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGluZyB0aGUgcGh5c2ljcyBtYW5hZ2VyXG5cdCAqIEBwYXJhbSBvcHRpb25zIEEgcmVjb3JkIG9mIG9wdGlvbnNcblx0ICovXG5cdHByb3RlY3RlZCBwYXJzZU9wdGlvbnMob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGlmKG9wdGlvbnMuZ3JvdXBOYW1lcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuY29sbGlzaW9ucyAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmdyb3VwTmFtZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRsZXQgZ3JvdXAgPSBvcHRpb25zLmdyb3VwTmFtZXNbaV07XG5cblx0XHRcdFx0Ly8gUmVnaXN0ZXIgdGhlIGdyb3VwIG5hbWUgYW5kIG51bWJlclxuXHRcdFx0XHR0aGlzLmdyb3VwTmFtZXNbaV0gPSBncm91cDtcblxuXHRcdFx0XHR0aGlzLmdyb3VwTWFwLnNldChncm91cCwgMSA8PCBpKTtcblxuXHRcdFx0XHRsZXQgY29sbGlzaW9uTWFzayA9IDA7XG5cblx0XHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IG9wdGlvbnMuY29sbGlzaW9uc1tpXS5sZW5ndGg7IGorKyl7XG5cdFx0XHRcdFx0aWYob3B0aW9ucy5jb2xsaXNpb25zW2ldW2pdKXtcblx0XHRcdFx0XHRcdGNvbGxpc2lvbk1hc2sgfD0gMSA8PCBqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uTWFza3NbaV0gPSBjb2xsaXNpb25NYXNrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRyZWdpc3Rlck9iamVjdChub2RlOiBQaHlzaWNhbCk6IHZvaWQge1xuXHRcdGlmKG5vZGUuaXNTdGF0aWMpe1xuXHRcdFx0Ly8gU3RhdGljIGFuZCBub3QgY29sbGlkYWJsZVxuXHRcdFx0dGhpcy5zdGF0aWNOb2Rlcy5wdXNoKG5vZGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEeW5hbWljIGFuZCBub3QgY29sbGlkYWJsZVxuXHRcdFx0dGhpcy5keW5hbWljTm9kZXMucHVzaChub2RlKTtcblx0XHR9XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0ZGVyZWdpc3Rlck9iamVjdChub2RlOiBQaHlzaWNhbCk6IHZvaWQge1xuXHRcdGlmKG5vZGUuaXNTdGF0aWMpe1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIHN0YXRpYyBsaXN0XG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuc3RhdGljTm9kZXMuaW5kZXhPZihub2RlKTtcblx0XHRcdHRoaXMuc3RhdGljTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGR5bmFtaWMgbGlzdFxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLmR5bmFtaWNOb2Rlcy5pbmRleE9mKG5vZGUpO1xuXHRcdFx0dGhpcy5keW5hbWljTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0cmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcblx0XHR0aGlzLnRpbGVtYXBzLnB1c2godGlsZW1hcCk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0ZGVyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy50aWxlbWFwcy5pbmRleE9mKHRpbGVtYXApO1xuXHRcdHRoaXMudGlsZW1hcHMuc3BsaWNlKGluZGV4LCAxKTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHRmb3IobGV0IG5vZGUgb2YgdGhpcy5keW5hbWljTm9kZXMpe1xuXHRcdFx0LyotLS0tLS0tLS0tIElOSVRJQUxJWkFUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xuXHRcdFx0Ly8gQ2xlYXIgZnJhbWUgZGVwZW5kZW50IGJvb2xlYW4gdmFsdWVzIGZvciBlYWNoIG5vZGVcblx0XHRcdG5vZGUub25Hcm91bmQgPSBmYWxzZTtcblx0XHRcdG5vZGUub25DZWlsaW5nID0gZmFsc2U7XG5cdFx0XHRub2RlLm9uV2FsbCA9IGZhbHNlO1xuXHRcdFx0bm9kZS5jb2xsaWRlZFdpdGhUaWxlbWFwID0gZmFsc2U7XG5cdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIElmIHRoaXMgbm9kZSBpcyBub3QgYWN0aXZlLCBkb24ndCBwcm9jZXNzIGl0XG5cdFx0XHRpZighbm9kZS5hY3RpdmUpe1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHRoZSBzd2VwdCBzaGFwZXMgb2YgZWFjaCBub2RlXG5cdFx0XHRpZihub2RlLm1vdmluZyl7XG5cdFx0XHRcdC8vIElmIG1vdmluZywgcmVmbGVjdCB0aGF0IGluIHRoZSBzd2VwdCBzaGFwZVxuXHRcdFx0XHRub2RlLnN3ZXB0UmVjdC5zd2VlcChub2RlLl92ZWxvY2l0eSwgbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXIsIG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgb3VyIG5vZGUgaXNuJ3QgbW92aW5nLCBkb24ndCBib3RoZXIgdG8gY2hlY2sgaXQgKG90aGVyIG5vZGVzIHdpbGwgZGV0ZWN0IGlmIHRoZXkgcnVuIGludG8gaXQpXG5cdFx0XHRcdG5vZGUuX3ZlbG9jaXR5Lnplcm8oKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8qLS0tLS0tLS0tLSBERVRFQ1RJT04gUEhBU0UgLS0tLS0tLS0tLSovXG5cdFx0XHQvLyBHYXRoZXIgYSBzZXQgb2Ygb3ZlcmxhcHNcblx0XHRcdGxldCBvdmVybGFwcyA9IG5ldyBBcnJheTxBcmVhQ29sbGlzaW9uPigpO1xuXG5cdFx0XHRsZXQgZ3JvdXBJbmRleCA9IG5vZGUuZ3JvdXAgPT09IC0xID8gLTEgOiBNYXRoLmxvZzIobm9kZS5ncm91cCk7XG5cblx0XHRcdC8vIEZpcnN0LCBjaGVjayB0aGlzIG5vZGUgYWdhaW5zdCBldmVyeSBzdGF0aWMgbm9kZSAob3JkZXIgZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSwgc2luY2Ugd2Ugc29ydCBhbnl3YXlzKVxuXHRcdFx0Zm9yKGxldCBvdGhlciBvZiB0aGlzLnN0YXRpY05vZGVzKXtcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIG5vZGVzXG5cdFx0XHRcdGlmKCFvdGhlci5hY3RpdmUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGxldCBjb2xsaWRlciA9IG90aGVyLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xuXHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcblx0XHRcdFx0aWYoYXJlYSA+IDApe1xuXHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxuXHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIG90aGVyLCBcIkdhbWVOb2RlXCIsIG51bGwpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGVuLCBjaGVjayBpdCBhZ2FpbnN0IGV2ZXJ5IGR5bmFtaWMgbm9kZVxuXHRcdFx0Zm9yKGxldCBvdGhlciBvZiB0aGlzLmR5bmFtaWNOb2Rlcyl7XG5cdFx0XHRcdC8vIElnbm9yZSBvdXJzZWx2ZXNcblx0XHRcdFx0aWYobm9kZSA9PT0gb3RoZXIpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xuXHRcdFx0XHRpZighb3RoZXIuYWN0aXZlKSBjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgY29sbGlkZXIgPSBvdGhlci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcblx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XG5cdFx0XHRcdGlmKGFyZWEgPiAwKXtcblx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cblx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCBvdGhlciwgXCJHYW1lTm9kZVwiLCBudWxsKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTGFzdGx5LCBnYXRoZXIgYSBzZXQgb2YgQUFCQnMgZnJvbSB0aGUgdGlsZW1hcC5cblx0XHRcdC8vIFRoaXMgc3RlcCBpbnZvbHZlcyB0aGUgbW9zdCBleHRyYSB3b3JrLCBzbyBpdCBpcyBhYnN0cmFjdGVkIGludG8gYSBtZXRob2Rcblx0XHRcdGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIHRpbGVtYXBzXG5cdFx0XHRcdGlmKCF0aWxlbWFwLmFjdGl2ZSkgY29udGludWU7XG5cblx0XHRcdFx0aWYodGlsZW1hcCBpbnN0YW5jZW9mIE9ydGhvZ29uYWxUaWxlbWFwKXtcblx0XHRcdFx0XHR0aGlzLmNvbGxpZGVXaXRoT3J0aG9nb25hbFRpbGVtYXAobm9kZSwgdGlsZW1hcCwgb3ZlcmxhcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNvcnQgdGhlIG92ZXJsYXBzIGJ5IGFyZWFcblx0XHRcdG92ZXJsYXBzID0gb3ZlcmxhcHMuc29ydCgoYSwgYikgPT4gYi5hcmVhIC0gYS5hcmVhKTtcblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBoaXRzIHRvIHVzZSBsYXRlclxuXHRcdFx0bGV0IGhpdHMgPSBbXTtcblxuXHRcdFx0LyotLS0tLS0tLS0tIFJFU09MVVRJT04gUEhBU0UgLS0tLS0tLS0tLSovXG5cdFx0XHQvLyBGb3IgZXZlcnkgb3ZlcmxhcCwgZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY29sbGlkZSB3aXRoIGl0IGFuZCB3aGVuXG5cdFx0XHRmb3IobGV0IG92ZXJsYXAgb2Ygb3ZlcmxhcHMpe1xuXHRcdFx0XHQvLyBJZ25vcmUgbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxuXHRcdFx0XHRpZiggZ3JvdXBJbmRleCAhPT0gLTEgJiYgb3ZlcmxhcC5vdGhlci5ncm91cCAhPT0gLTEgJiYgKCh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDApICkgY29udGludWU7XG5cblx0XHRcdFx0Ly8gRG8gYSBzd2VwdCBsaW5lIHRlc3Qgb24gdGhlIHN0YXRpYyBBQUJCIHdpdGggdGhpcyBBQUJCIHNpemUgYXMgcGFkZGluZyAodGhpcyBpcyBiYXNpY2FsbHkgdXNpbmcgYSBtaW5rb3dza2kgc3VtISlcblx0XHRcdFx0Ly8gU3RhcnQgdGhlIHN3ZWVwIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIG5vZGUgd2l0aCBhIGRlbHRhIG9mIF92ZWxvY2l0eVxuXHRcdFx0XHRjb25zdCBwb2ludCA9IG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyO1xuXHRcdFx0XHRjb25zdCBkZWx0YSA9IG5vZGUuX3ZlbG9jaXR5O1xuXHRcdFx0XHRjb25zdCBwYWRkaW5nID0gbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZTtcblx0XHRcdFx0Y29uc3Qgb3RoZXJBQUJCID0gb3ZlcmxhcC5jb2xsaWRlcjtcblxuXG5cdFx0XHRcdGNvbnN0IGhpdCA9IG90aGVyQUFCQi5pbnRlcnNlY3RTZWdtZW50KG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyLCBub2RlLl92ZWxvY2l0eSwgbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZSk7XG5cblx0XHRcdFx0b3ZlcmxhcC5oaXQgPSBoaXQ7XG5cblx0XHRcdFx0aWYoaGl0ICE9PSBudWxsKXtcblx0XHRcdFx0XHRoaXRzLnB1c2goaGl0KTtcblxuXHRcdFx0XHRcdC8vIFdlIGdvdCBhIGhpdCwgcmVzb2x2ZSB3aXRoIHRoZSB0aW1lIGluc2lkZSBvZiB0aGUgaGl0XG5cdFx0XHRcdFx0bGV0IHRuZWFyeCA9IGhpdC5uZWFyVGltZXMueDtcblx0XHRcdFx0XHRsZXQgdG5lYXJ5ID0gaGl0Lm5lYXJUaW1lcy55O1xuXG5cdFx0XHRcdFx0Ly8gQWxsb3cgZWRnZSBjbGlwcGluZyAoZWRnZSBvdmVybGFwcyBkb24ndCBjb3VudCwgb25seSBhcmVhIG92ZXJsYXBzKVxuXHRcdFx0XHRcdC8vIEltcG9ydGFudGx5IGRvbid0IGFsbG93IGJvdGggY2FzZXMgdG8gYmUgdHJ1ZS4gVGhlbiB3ZSBjbGlwIHRocm91Z2ggY29ybmVycy4gRmF2b3IgeCB0byBoZWxwIHBsYXllcnMgbGFuZCBqdW1wc1xuXHRcdFx0XHRcdGlmKHRuZWFyeCA8IDEuMCAmJiAocG9pbnQueSA9PT0gb3RoZXJBQUJCLnRvcCAtIHBhZGRpbmcueSB8fCBwb2ludC55ID09PSBvdGhlckFBQkIuYm90dG9tICsgcGFkZGluZy55KSAmJiBkZWx0YS54ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR0bmVhcnggPSAxLjA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKHRuZWFyeSA8IDEuMCAmJiAocG9pbnQueCA9PT0gb3RoZXJBQUJCLmxlZnQgLSBwYWRkaW5nLnggfHwgcG9pbnQueCA9PT0gb3RoZXJBQUJCLnJpZ2h0ICsgcGFkZGluZy54KSAmJiBkZWx0YS55ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR0bmVhcnkgPSAxLjA7XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRpZihoaXQubmVhclRpbWVzLnggPj0gMCAmJiBoaXQubmVhclRpbWVzLnggPCAxKXtcblx0XHRcdFx0XHRcdC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpe1xuXHRcdFx0XHRcdFx0XHRub2RlLl92ZWxvY2l0eS54ID0gbm9kZS5fdmVsb2NpdHkueCAqIHRuZWFyeDtcblx0XHRcdFx0XHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoaGl0Lm5lYXJUaW1lcy55ID49IDAgJiYgaGl0Lm5lYXJUaW1lcy55IDwgMSl7XG5cdFx0XHRcdFx0XHQvLyBBbnkgdGlsZW1hcCBvYmplY3RzIHRoYXQgbWFkZSBpdCBoZXJlIGFyZSBjb2xsaWRhYmxlXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT09IFwiVGlsZW1hcFwiIHx8IG92ZXJsYXAub3RoZXIuaXNDb2xsaWRhYmxlKXtcblx0XHRcdFx0XHRcdFx0bm9kZS5fdmVsb2NpdHkueSA9IG5vZGUuX3ZlbG9jaXR5LnkgKiB0bmVhcnk7XG5cdFx0XHRcdFx0XHRcdG5vZGUuaXNDb2xsaWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvKi0tLS0tLS0tLS0gSU5GT1JNQVRJT04vVFJJR0dFUiBQSEFTRSAtLS0tLS0tLS0tKi9cblx0XHRcdC8vIENoZWNrIGlmIHdlIGVuZGVkIHVwIG9uIHRoZSBncm91bmQsIGNlaWxpbmcgb3Igd2FsbFxuXHRcdFx0Ly8gQWxzbyBjaGVjayBmb3IgdHJpZ2dlcnNcblx0XHRcdGZvcihsZXQgb3ZlcmxhcCBvZiBvdmVybGFwcyl7XG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIHRyaWdnZXIuIElmIHdlIGNhcmUgYWJvdXQgdGhlIHRyaWdnZXIsIHJlYWN0XG5cdFx0XHRcdGlmKG92ZXJsYXAub3RoZXIuaXNUcmlnZ2VyICYmIChvdmVybGFwLm90aGVyLnRyaWdnZXJNYXNrICYgbm9kZS5ncm91cCkgJiYgbm9kZS5ncm91cCAhPSAtMSl7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBiaXQgdGhhdCB0aGlzIGdyb3VwIGlzIHJlcHJlc2VudGVkIGJ5XG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIobm9kZS5ncm91cCkpO1xuXG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCB0aGUgdHJpZ2dlckVudGVyIGV2ZW50IG5hbWVcblx0XHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KG92ZXJsYXAub3RoZXIudHJpZ2dlckVudGVyc1tpbmRleF0sIHtcblx0XHRcdFx0XHRcdG5vZGU6ICg8R2FtZU5vZGU+bm9kZSkuaWQsXG5cdFx0XHRcdFx0XHRvdGhlcjogKDxHYW1lTm9kZT5vdmVybGFwLm90aGVyKS5pZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWdub3JlIGNvbGxpc2lvbiBzaWRlcyBmb3Igbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxuXHRcdFx0XHRpZiggZ3JvdXBJbmRleCAhPT0gLTEgJiYgb3ZlcmxhcC5vdGhlci5ncm91cCAhPT0gLTEgJiYgKCh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDApKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBPbmx5IGNoZWNrIGZvciBkaXJlY3Rpb24gaWYgdGhlIG92ZXJsYXAgd2FzIGNvbGxpZGFibGVcblx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XG5cdFx0XHRcdFx0bGV0IGNvbGxpc2lvblNpZGUgPSBvdmVybGFwLmNvbGxpZGVyLnRvdWNoZXNBQUJCV2l0aG91dENvcm5lcnMobm9kZS5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZSAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSB0b3VjaCwgbm90IGluY2x1ZGluZyBjb3JuZXIgY2FzZXMsIGNoZWNrIHRoZSBjb2xsaXNpb24gbm9ybWFsXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLmhpdCAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0XHRcdC8vIElmIHdlIGhpdCBhIHRpbGVtYXAsIGtlZXAgdHJhY2sgb2YgaXRcblx0XHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09IFwiVGlsZW1hcFwiKXtcblx0XHRcdFx0XHRcdFx0XHRub2RlLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZS55ID09PSAtMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiB0b3Agb2Ygb3ZlcmxhcCwgc28gb25Hcm91bmRcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uR3JvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNvbGxpc2lvblNpZGUueSA9PT0gMSl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiBib3R0b20gb2Ygb3ZlcmxhcCwgc28gb25DZWlsaW5nXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5vbkNlaWxpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgd2Fzbid0IHRvdWNoaW5nIG9uIHksIHNvIGl0IGlzIHRvdWNoaW5nIG9uIHhcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uV2FsbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgY29sbGlzaW9uIHdpdGggdGhlIG5vZGUsIGFuZCBtb3ZlIGl0XG5cdFx0XHRub2RlLmZpbmlzaE1vdmUoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyBhIGNvbGxpc2lvbiBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgYW4gb3J0aG9nb25hbCB0aWxlbWFwXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRoZSBub2RlIG1heSBiZSBjb2xsaWRpbmcgd2l0aFxuXHQgKiBAcGFyYW0gb3ZlcmxhcHMgVGhlIGxpc3Qgb2Ygb3ZlcmxhcHNcblx0ICovXG5cdHByb3RlY3RlZCBjb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGU6IFBoeXNpY2FsLCB0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcCwgb3ZlcmxhcHM6IEFycmF5PEFyZWFDb2xsaXNpb24+KTogdm9pZCB7XG5cdFx0Ly8gR2V0IHRoZSBtaW4gYW5kIG1heCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3Zpbmcgbm9kZVxuXHRcdGxldCBtaW4gPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5sZWZ0LCBub2RlLnN3ZXB0UmVjdC50b3ApO1xuXHRcdGxldCBtYXggPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5yaWdodCwgbm9kZS5zd2VwdFJlY3QuYm90dG9tKTtcblxuXHRcdC8vIENvbnZlcnQgdGhlIG1pbi9tYXggeC95IHRvIHRoZSBtaW4gYW5kIG1heCByb3cvY29sIGluIHRoZSB0aWxlbWFwIGFycmF5XG5cdFx0bGV0IG1pbkluZGV4ID0gdGlsZW1hcC5nZXRNaW5Db2xSb3cobm9kZS5zd2VwdFJlY3QpO1xuXHRcdGxldCBtYXhJbmRleCA9IHRpbGVtYXAuZ2V0TWF4Q29sUm93KG5vZGUuc3dlcHRSZWN0KTtcblxuXHRcdC8vIExvb3Agb3ZlciBhbGwgcG9zc2libGUgdGlsZXMgKHdoaWNoIGlzbid0IG1hbnkgaW4gdGhlIHNjb3BlIG9mIHRoZSB2ZWxvY2l0eSBwZXIgZnJhbWUpXG5cdFx0Zm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xuXHRcdFx0Zm9yKGxldCByb3cgPSBtaW5JbmRleC55OyByb3cgPD0gbWF4SW5kZXgueTsgcm93Kyspe1xuXHRcdFx0XHRpZih0aWxlbWFwLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgY29sbGlkZXIgZm9yIHRoaXMgdGlsZVxuXHRcdFx0XHRcdGxldCBjb2xsaWRlciA9IHRpbGVtYXAuZ2V0VGlsZUNvbGxpZGVyKGNvbCwgcm93KTtcblx0XHRcdFx0XHQvLyBDYWxjdWxhdGUgY29sbGlzaW9uIGFyZWEgYmV0d2VlbiB0aGUgbm9kZSBhbmQgdGhlIHRpbGVcblx0XHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcblx0XHRcdFx0XHRpZihhcmVhID4gMCl7XG5cdFx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cblx0XHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIHRpbGVtYXAsIFwiVGlsZW1hcFwiLCBuZXcgVmVjMihjb2wsIHJvdykpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBwaHlzaWNzIG1hbmFnZXIuXG4gKiBUaGlzIGNsYXNzIGV4cG9zZXMgZnVuY3Rpb25zIGZvciBzdWJjbGFzc2VzIHRvIGltcGxlbWVudCB0aGF0IHNob3VsZCBhbGxvdyBmb3IgYSB3b3JraW5nIHBoeXNpY3Mgc3lzdGVtIHRvIGJlIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG5cdC8qKiBUaGUgZXZlbnQgcmVjZWl2ZXIgZm9yIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xuXHRwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXHQvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xuXHRwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuXHQvKiogTWFwcyBsYXllciBuYW1lcyB0byBudW1iZXJzICovXG5cdHByb3RlY3RlZCBncm91cE1hcDogTWFwPG51bWJlcj47XG5cblx0LyoqIE1hcHMgbGF5ZXIgbnVtYmVycyB0byBuYW1lcyAqL1xuXHRwcm90ZWN0ZWQgZ3JvdXBOYW1lczogQXJyYXk8c3RyaW5nPjtcblxuXHQvKiogVGhlIGRlZmF1bHQgZ3JvdXAgbmFtZSAqL1xuXHRwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfR1JPVVA6IHN0cmluZyA9IFwiRGVmYXVsdFwiO1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuXHRcdHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cblx0XHQvLyBUaGUgY3JlYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIG9mIGxheWVycyBpcyBkZWZlcnJlZCB0byB0aGUgc3ViY2xhc3Ncblx0XHR0aGlzLmdyb3VwTWFwID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuZ3JvdXBOYW1lcyA9IG5ldyBBcnJheSgpO1xuXHR9XG5cblx0ZGVzdHJveSgpOiB2b2lkIHtcblx0XHR0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBnYW1lbm9kZSB3aXRoIHRoaXMgcGh5c2ljcyBtYW5hZ2VyXG5cdCAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byByZWdpc3RlclxuXHQgKi9cblx0YWJzdHJhY3QgcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XG5cblxuXHQvKipcblx0ICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcblx0ICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcblx0ICovXG5cdGFic3RyYWN0IGRlcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIHRpbGVtYXAgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZWdpc3RlclxuXHQgKi9cblx0YWJzdHJhY3QgcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhpcyB0aWxlbWFwIGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcblx0ICogQHBhcmFtIHRpbGVtYXAgVGhlIG9iamVjdCB0byBkZXJlZ2lzdGVyXG5cdCAqL1xuXHRhYnN0cmFjdCBkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcblxuXHRhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwaHlzaWNzIGxheWVyIG9mIHRoZSBHYW1lTm9kZVxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGVcblx0ICogQHBhcmFtIGdyb3VwIFRoZSBncm91cCB0aGF0IHRoZSBHYW1lTm9kZSBzaG91bGQgYmUgb25cblx0ICovXG5cdHNldEdyb3VwKG5vZGU6IFBoeXNpY2FsLCBncm91cDogc3RyaW5nKTogdm9pZCB7XG5cdFx0bm9kZS5ncm91cCA9IHRoaXMuZ3JvdXBNYXAuZ2V0KGdyb3VwKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGxheWVyIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIG5hbWVcblx0ICogQHBhcmFtIGxheWVyIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuXHQgKiBAcmV0dXJucyBUaGUgbGF5ZXIgbnVtYmVyLCBvciAwIGlmIHRoZXJlIGlzIG5vdCBhIGxheWVyIHdpdGggdGhhdCBuYW1lIHJlZ2lzdGVyZWRcblx0ICovXG5cdGdldEdyb3VwTnVtYmVyKGdyb3VwOiBzdHJpbmcpOiBudW1iZXIge1xuXHRcdGlmKHRoaXMuZ3JvdXBNYXAuaGFzKGdyb3VwKSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5ncm91cE1hcC5nZXQoZ3JvdXApO1xuXHRcdH0gZWxzZXtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGFsbCBncm91cCBuYW1lcyBhc3NvY2lhdGVkIHdpdGggdGhlIG51bWJlciBwcm92aWRlZFxuXHQgKiBAcGFyYW0gZ3JvdXBzIEEgbWFzayBvZiBncm91cHNcblx0ICogQHJldHVybnMgQWxsIGdyb3VwcyBjb250YWluZWQgaW4gdGhlIG1hc2tcblx0ICovXG5cdGdldEdyb3VwTmFtZXMoZ3JvdXBzOiBudW1iZXIpOiBBcnJheTxzdHJpbmc+IHtcblx0XHRpZihncm91cHMgPT09IC0xKXtcblx0XHRcdHJldHVybiBbUGh5c2ljc01hbmFnZXIuREVGQVVMVF9HUk9VUF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBnID0gMTtcblx0XHRcdGxldCBuYW1lcyA9IFtdO1xuXG5cdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgMzI7IGkrKyl7XG5cdFx0XHRcdGlmKGcgJiBncm91cHMpe1xuXHRcdFx0XHRcdC8vIFRoaXMgZ3JvdXAgaXMgaW4gdGhlIGdyb3VwcyBudW1iZXJcblx0XHRcdFx0XHRuYW1lcy5wdXNoKHRoaXMuZ3JvdXBOYW1lc1tpXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTaGlmdCB0aGUgYml0IG92ZXJcblx0XHRcdFx0ZyA9IGcgPDwgMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcblxuaW1wb3J0IEFic3RyYWN0UmVwbGF5ZXIgZnJvbSBcIi4uL0RhdGFUeXBlcy9QbGF5YmFjay9BYnN0cmFjdC9BYnN0cmFjdFJlcGxheWVyXCI7XG5pbXBvcnQgQWJzdHJhY3RMb2dJdGVtIGZyb20gXCIuLi9EYXRhVHlwZXMvUGxheWJhY2svQWJzdHJhY3QvQWJzdHJhY3RMb2dJdGVtXCI7XG5pbXBvcnQgQWJzdHJhY3RSZWNvcmRpbmcgZnJvbSBcIi4uL0RhdGFUeXBlcy9QbGF5YmFjay9BYnN0cmFjdC9BYnN0cmFjdFJlY29yZGluZ1wiO1xuaW1wb3J0IEFic3RyYWN0UmVjb3JkZXIgZnJvbSBcIi4uL0RhdGFUeXBlcy9QbGF5YmFjay9BYnN0cmFjdC9BYnN0cmFjdFJlY29yZGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYXliYWNrTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJvdGVjdGVkIHJlY29yZGVyOiBBYnN0cmFjdFJlY29yZGVyPEFic3RyYWN0UmVjb3JkaW5nPEFic3RyYWN0TG9nSXRlbT4sIEFic3RyYWN0TG9nSXRlbT47XG4gICAgcHJvdGVjdGVkIHJlY29yZGluZzogYm9vbGVhbjtcblxuICAgIHByb3RlY3RlZCByZXBsYXllcjogQWJzdHJhY3RSZXBsYXllcjxBYnN0cmFjdFJlY29yZGluZzxBYnN0cmFjdExvZ0l0ZW0+LCBBYnN0cmFjdExvZ0l0ZW0+O1xuICAgIHByb3RlY3RlZCBwbGF5aW5nOiBib29sZWFuO1xuXG4gICAgcHJvdGVjdGVkIGxhc3RSZWNvcmRpbmc6IEFic3RyYWN0UmVjb3JkaW5nPEFic3RyYWN0TG9nSXRlbT47XG5cbiAgICBwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShbR2FtZUV2ZW50VHlwZS5TVEFSVF9SRUNPUkRJTkcsIEdhbWVFdmVudFR5cGUuU1RPUF9SRUNPUkRJTkcsIEdhbWVFdmVudFR5cGUuUExBWV9SRUNPUkRJTkddKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmVjb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nID0gdGhpcy5yZWNvcmRlci5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXBsYXllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxheWVyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nID0gdGhpcy5yZXBsYXllci5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdhbWVFdmVudFR5cGUuU1RBUlRfUkVDT1JESU5HOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGFydFJlY29yZGluZ0V2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR2FtZUV2ZW50VHlwZS5TVE9QX1JFQ09SRElORzoge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RvcFJlY29yZGluZ0V2ZW50KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdhbWVFdmVudFR5cGUuUExBWV9SRUNPUkRJTkc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBsYXlSZWNvcmRpbmdFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZVN0YXJ0UmVjb3JkaW5nRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBsZXQgcmVjb3JkaW5nID0gZXZlbnQuZGF0YS5nZXQoXCJyZWNvcmRpbmdcIik7XG4gICAgICAgIGlmICghdGhpcy5wbGF5aW5nICYmICF0aGlzLnJlY29yZGluZyAmJiByZWNvcmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVjb3JkaW5nID0gcmVjb3JkaW5nO1xuICAgICAgICAgICAgbGV0IFJlY29yZGVyOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBBYnN0cmFjdFJlY29yZGVyPEFic3RyYWN0UmVjb3JkaW5nPEFic3RyYWN0TG9nSXRlbT4sIEFic3RyYWN0TG9nSXRlbT4gPSB0aGlzLmxhc3RSZWNvcmRpbmcucmVjb3JkZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29yZGVyID09PSB1bmRlZmluZWQgfHwgdGhpcy5yZWNvcmRlci5jb25zdHJ1Y3RvciAhPT0gUmVjb3JkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZGVyID0gbmV3IFJlY29yZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlY29yZGVyLnN0YXJ0KHRoaXMubGFzdFJlY29yZGluZyk7XG4gICAgICAgICAgICB0aGlzLnJlY29yZGluZyA9IHRoaXMucmVjb3JkZXIuYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZVN0b3BSZWNvcmRpbmdFdmVudCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZWNvcmRlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nID0gdGhpcy5yZWNvcmRlci5hY3RpdmUoKTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZVBsYXlSZWNvcmRpbmdFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5yZWNvcmRpbmcgJiYgdGhpcy5sYXN0UmVjb3JkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBSZXBsYXllcjogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gQWJzdHJhY3RSZXBsYXllcjxBYnN0cmFjdFJlY29yZGluZzxBYnN0cmFjdExvZ0l0ZW0+LCBBYnN0cmFjdExvZ0l0ZW0+ID0gdGhpcy5sYXN0UmVjb3JkaW5nLnJlcGxheWVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBsYXllciA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucmVwbGF5ZXIuY29uc3RydWN0b3IgIT09IFJlcGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYXllciA9IG5ldyBSZXBsYXllcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYXllci5zdGFydCh0aGlzLmxhc3RSZWNvcmRpbmcsIGV2ZW50LmRhdGEuZ2V0KFwib25FbmRcIikpO1xuICAgICAgICAgICAgdGhpcy5wbGF5aW5nID0gdGhpcy5yZXBsYXllci5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcblxuLyoqICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSZWdpc3RyeTxUPiBleHRlbmRzIE1hcDxUPntcblxuICAgIC8qKiBQcmVsb2FkcyByZWdpc3RyeSBkYXRhICovXG4gICAgcHVibGljIGFic3RyYWN0IHByZWxvYWQoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpdGVtIGFuZCBwcmVsb2FkcyBhbnkgbmVjZXNzYXJ5IGZpbGVzXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJlZ2lzdGVyIHRoaXMgaXRlbSB3aXRoXG4gICAgICogQHBhcmFtIGFyZ3MgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIG5lZWRlZCBmb3IgcmVnaXN0cmF0aW9uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oa2V5OiBzdHJpbmcsIC4uLmFyZ3M6IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaXRlbSBhbmQgcHJlbG9hZHMgYW55IG5lY2Vzc2FyeSBmaWxlc1xuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZWdpc3RlciB0aGlzIGl0ZW0gd2l0aFxuICAgICAqIEBwYXJhbSBhcmdzIEFueSBhZGl0aW9uYWwgYXJndW1lbnRzIG5lZWRlZCBmb3IgcmVnaXN0cmF0aW9uXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IHJlZ2lzdGVySXRlbShrZXk6IHN0cmluZywgLi4uYXJnczogYW55KTogdm9pZDtcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVcIjtcbmltcG9ydCBMYWJlbFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9MYWJlbFNoYWRlclR5cGVcIjtcbmltcG9ydCBQb2ludFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9Qb2ludFNoYWRlclR5cGVcIjtcbmltcG9ydCBSZWN0U2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1JlY3RTaGFkZXJUeXBlXCI7XG5pbXBvcnQgU3ByaXRlU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1Nwcml0ZVNoYWRlclR5cGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyeVwiO1xuXG4vKipcbiAqIEEgcmVnaXN0cnkgdGhhdCBoYW5kbGVzIHNoYWRlcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeTxTaGFkZXJUeXBlPiB7XG5cblx0Ly8gU2hhZGVyIG5hbWVzXG5cdHB1YmxpYyBzdGF0aWMgUE9JTlRfU0hBREVSID0gXCJwb2ludFwiO1xuXHRwdWJsaWMgc3RhdGljIFJFQ1RfU0hBREVSID0gXCJyZWN0XCI7XG5cdHB1YmxpYyBzdGF0aWMgU1BSSVRFX1NIQURFUiA9IFwic3ByaXRlXCI7XG5cdHB1YmxpYyBzdGF0aWMgTEFCRUxfU0hBREVSID0gXCJsYWJlbFwiO1xuXG5cdHByaXZhdGUgcmVnaXN0cnlJdGVtczogQXJyYXk8U2hhZGVyUmVnaXN0cnlJdGVtPiA9IG5ldyBBcnJheSgpO1xuXG5cdC8qKlxuXHQgKiBQcmVsb2FkcyBhbGwgYnVpbHQtaW4gc2hhZGVyc1xuXHQgKi9cblx0cHVibGljIHByZWxvYWQoKXtcblx0XHQvLyBHZXQgdGhlIHJlc291cmNlTWFuYWdlciBhbmQgcXVldWUgYWxsIGJ1aWx0LWluIHNoYWRlcnMgZm9yIHByZWxvYWRpbmdcblx0XHRjb25zdCBybSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgcG9pbnQgc2hhZGVyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlBPSU5UX1NIQURFUiwgUG9pbnRTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9wb2ludC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3BvaW50LmZzaGFkZXJcIik7XG5cblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSByZWN0IHNoYWRlclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5SRUNUX1NIQURFUiwgUmVjdFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3JlY3QudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9yZWN0LmZzaGFkZXJcIik7XG5cblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBzcHJpdGUgc2hhZGVyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIsIFNwcml0ZVNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3Nwcml0ZS52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3Nwcml0ZS5mc2hhZGVyXCIpO1xuXHRcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBsYWJlbCBzaGFkZXJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuTEFCRUxfU0hBREVSLCBMYWJlbFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL2xhYmVsLnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvbGFiZWwuZnNoYWRlclwiKTtcblxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgYW55IHByZWxvYWRlZCBpdGVtc1xuXHRcdGZvcihsZXQgaXRlbSBvZiB0aGlzLnJlZ2lzdHJ5SXRlbXMpe1xuXHRcdFx0Y29uc3Qgc2hhZGVyID0gbmV3IGl0ZW0uY29uc3RyKGl0ZW0ua2V5KTtcblx0XHRcdHNoYWRlci5pbml0QnVmZmVyT2JqZWN0KCk7XG5cdFx0XHR0aGlzLmFkZChpdGVtLmtleSwgc2hhZGVyKTtcblxuXHRcdFx0Ly8gTG9hZCBpZiBkZXNpcmVkXG5cdFx0XHRpZihpdGVtLnByZWxvYWQgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdHJtLnNoYWRlcihpdGVtLmtleSwgaXRlbS5wcmVsb2FkLnZzaGFkZXJMb2NhdGlvbiwgaXRlbS5wcmVsb2FkLmZzaGFkZXJMb2NhdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIHNoYWRlciBpbiB0aGUgcmVnaXN0cnkgYW5kIGxvYWRzIGl0IGJlZm9yZSB0aGUgZ2FtZSBiZWdpbnNcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHlvdSB3aXNoIHRvIGFzc2lnbiB0byB0aGUgc2hhZGVyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBTaGFkZXJUeXBlXG5cdCAqIEBwYXJhbSB2c2hhZGVyTG9jYXRpb24gVGhlIGxvY2F0aW9uIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyXG5cdCAqIEBwYXJhbSBmc2hhZGVyTG9jYXRpb24gdGhlIGxvY2F0aW9uIG9mIHRoZSBmcmFnbWVudCBzaGFkZXJcblx0ICovXG5cdHB1YmxpYyByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nLCBjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlLCB2c2hhZGVyTG9jYXRpb246IHN0cmluZywgZnNoYWRlckxvY2F0aW9uOiBzdHJpbmcpOiB2b2lkIHtcblx0XHRsZXQgc2hhZGVyUHJlbG9hZCA9IG5ldyBTaGFkZXJQcmVsb2FkKCk7XG5cdFx0c2hhZGVyUHJlbG9hZC52c2hhZGVyTG9jYXRpb24gPSB2c2hhZGVyTG9jYXRpb247XG5cdFx0c2hhZGVyUHJlbG9hZC5mc2hhZGVyTG9jYXRpb24gPSBmc2hhZGVyTG9jYXRpb247XG5cblx0XHRsZXQgcmVnaXN0cnlJdGVtID0gbmV3IFNoYWRlclJlZ2lzdHJ5SXRlbSgpO1xuXHRcdHJlZ2lzdHJ5SXRlbS5rZXkgPSBrZXk7XG5cdFx0cmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcblx0XHRyZWdpc3RyeUl0ZW0ucHJlbG9hZCA9IHNoYWRlclByZWxvYWQ7XG5cblx0XHR0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIHNoYWRlciBpbiB0aGUgcmVnaXN0cnkuIE5PVEU6IElmIHlvdSB1c2UgdGhpcywgeW91IE1VU1QgbG9hZCB0aGUgc2hhZGVyIGJlZm9yZSB1c2UuXG5cdCAqIElmIHlvdSB3aXNoIHRvIHByZWxvYWQgdGhlIHNoYWRlciwgdXNlIHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oKVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgeW91IHdpc2ggdG8gYXNzaWduIHRvIHRoZSBzaGFkZXJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIFNoYWRlclR5cGVcblx0ICovXG5cdHB1YmxpYyByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGUpOiB2b2lkIHtcblx0XHRsZXQgcmVnaXN0cnlJdGVtID0gbmV3IFNoYWRlclJlZ2lzdHJ5SXRlbSgpO1xuXHRcdHJlZ2lzdHJ5SXRlbS5rZXkgPSBrZXk7XG5cdFx0cmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcblxuXHRcdHRoaXMucmVnaXN0cnlJdGVtcy5wdXNoKHJlZ2lzdHJ5SXRlbSk7XG5cdH1cbn1cblxuY2xhc3MgU2hhZGVyUmVnaXN0cnlJdGVtIHtcblx0a2V5OiBzdHJpbmc7XG5cdGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGU7XG5cdHByZWxvYWQ6IFNoYWRlclByZWxvYWQ7XG59XG5cbmNsYXNzIFNoYWRlclByZWxvYWQge1xuXHR2c2hhZGVyTG9jYXRpb246IHN0cmluZztcblx0ZnNoYWRlckxvY2F0aW9uOiBzdHJpbmc7XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJpZXMvUmVnaXN0cnlcIjtcbmltcG9ydCBTaGFkZXJSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyaWVzL1NoYWRlclJlZ2lzdHJ5XCI7XG5cbi8qKlxuICogVGhlIFJlZ2lzdHJ5IGlzIHRoZSBzeXN0ZW0ncyB3YXkgb2YgY29udmVydGluZyBjbGFzc2VzIGFuZCB0eXBlcyBpbnRvIHN0cmluZ1xuICogcmVwcmVzZW50YXRpb25zIGZvciB1c2UgZWxzZXdoZXJlIGluIHRoZSBhcHBsaWNhdGlvbi5cbiAqIEl0IGFsbG93cyBjbGFzc2VzIHRvIGJlIGFjY2Vzc2VkIHdpdGhvdXQgZXhwbGljaXRseSB1c2luZyBjb25zdHJ1Y3RvcnMgaW4gY29kZSxcbiAqIGFuZCBmb3IgcmVzb3VyY2VzIHRvIGJlIGxvYWRlZCBhdCBHYW1lIGNyZWF0aW9uIHRpbWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ2lzdHJ5TWFuYWdlciB7XG5cblx0cHVibGljIHN0YXRpYyBzaGFkZXJzID0gbmV3IFNoYWRlclJlZ2lzdHJ5KCk7XG5cblx0LyoqIEFkZGl0aW9uYWwgY3VzdG9tIHJlZ2lzdHJpZXMgdG8gYWRkIHRvIHRoZSByZWdpc3RyeSBtYW5hZ2VyICovXG5cdHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0cmllczogTWFwPFJlZ2lzdHJ5PGFueT4+ID0gbmV3IE1hcCgpO1xuXG5cdHN0YXRpYyBwcmVsb2FkKCl7XG5cdFx0dGhpcy5zaGFkZXJzLnByZWxvYWQoKTtcblxuXHRcdHRoaXMucmVnaXN0cmllcy5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gdGhpcy5yZWdpc3RyaWVzLmdldChrZXkpLnByZWxvYWQoKSk7XG5cdH1cblxuXHRzdGF0aWMgYWRkQ3VzdG9tUmVnaXN0cnkobmFtZTogc3RyaW5nLCByZWdpc3RyeTogUmVnaXN0cnk8YW55Pil7XG5cdFx0dGhpcy5yZWdpc3RyaWVzLmFkZChuYW1lLCByZWdpc3RyeSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0UmVnaXN0cnkoa2V5OiBzdHJpbmcpe1xuXHRcdHJldHVybiB0aGlzLnJlZ2lzdHJpZXMuZ2V0KGtleSk7XG5cdH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgeyBBbmltYXRpb25EYXRhLCBBbmltYXRpb25TdGF0ZSB9IGZyb20gXCIuL0FuaW1hdGlvblR5cGVzXCI7XG5cbi8qKlxuICogQW4gYW5pbWF0aW9uIG1hbmFnZXIgY2xhc3MgZm9yIGFuIGFuaW1hdGVkIENhbnZhc05vZGUuXG4gKiBUaGlzIGNsYXNzIGtlZXBzIHRyYWNrIG9mIHRoZSBwb3NzaWJsZSBhbmltYXRpb25zLCBhcyB3ZWxsIGFzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSxcbiAqIGFuZCBhYnN0cmFjdHMgYWxsIGludGVyYWN0aW9ucyB3aXRoIHBsYXlpbmcsIHBhdXNpbmcsIGFuZCBzdG9wcGluZyBhbmltYXRpb25zIGFzIHdlbGwgYXMgXG4gKiBjcmVhdGluZyBuZXcgYW5pbWF0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25NYW5hZ2VyIHtcbiAgICAvKiogVGhlIG93bmVyIG9mIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cbiAgICBwcm90ZWN0ZWQgb3duZXI6IENhbnZhc05vZGU7XG4gICAgXG4gICAgLyoqIFRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSBvZiB0aGlzIHNwcml0ZSAqL1xuICAgIHByb3RlY3RlZCBhbmltYXRpb25TdGF0ZTogQW5pbWF0aW9uU3RhdGU7XG5cbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIG9mIHRoaXMgc3ByaXRlICovXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRBbmltYXRpb246IHN0cmluZztcblxuICAgIC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGlzIGFuaW1hdGlvbiAqL1xuICAgIHByb3RlY3RlZCBjdXJyZW50RnJhbWU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHRocm91Z2ggdGhlIGN1cnJlbnQgZnJhbWUgKi9cbiAgICBwcm90ZWN0ZWQgZnJhbWVQcm9ncmVzczogbnVtYmVyO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGxvb3Bpbmcgb3Igbm90ICovXG4gICAgcHJvdGVjdGVkIGxvb3A6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIG1hcCBvZiBhbmltYXRpb25zICovXG4gICAgcHJvdGVjdGVkIGFuaW1hdGlvbnM6IE1hcDxBbmltYXRpb25EYXRhPjtcblxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGlmIGFueSkgdG8gc2VuZCB3aGVuIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdG9wcyBwbGF5aW5nLiAqL1xuICAgIHByb3RlY3RlZCBvbkVuZEV2ZW50OiBzdHJpbmc7XG5cbiAgICAvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKiBBIHF1ZXVlZCBhbmltYXRpb24gKi9cbiAgICBwcm90ZWN0ZWQgcGVuZGluZ0FuaW1hdGlvbjogc3RyaW5nO1xuXG4gICAgLyoqIFRoZSBsb29wIHN0YXR1cyBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdMb29wOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBvbkVuZCBldmVudCBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdPbkVuZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBbmltYXRpb25NYW5hZ2VyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgQW5pbWF0aW9uTWFuYWdlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG93bmVyOiBDYW52YXNOb2RlKXtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xuICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhbmltYXRpb24gdG8gdGhpcyBzcHJpdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5IG9mIHRoZSBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24gZGF0YVxuICAgICAqL1xuICAgIGFkZChrZXk6IHN0cmluZywgYW5pbWF0aW9uOiBBbmltYXRpb25EYXRhKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucy5hZGQoa2V5LCBhbmltYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IHNwZWNpZmllZCBieSB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIGN1cnJlbnQgZnJhbWVcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggaW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICovXG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgaWYodGhpcy5hbmltYXRpb25zLmhhcyh0aGlzLmN1cnJlbnRBbmltYXRpb24pKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZ2V0KHRoaXMuY3VycmVudEFuaW1hdGlvbikuZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCB3YXJuIHRoZSB1c2VyXG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYEFuaW1hdGlvbiBpbmRleCB3YXMgcmVxdWVzdGVkLCBidXQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uOiAke3RoaXMuY3VycmVudEFuaW1hdGlvbn0gd2FzIGludmFsaWRgKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIGlzIGN1cnJlbnRseSBwbGF5aW5nXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBhbmltYXRpb24gdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIGlzIHBsYXlpbmcsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzUGxheWluZyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbWF0aW9uID09PSBrZXkgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGluZGV4IGFuZCBhZHZhbmNlcyB0aGUgYW5pbWF0aW9uIGZyYW1lXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBhbmltYXRpb24gZnJhbWVcbiAgICAgKi9cbiAgICBnZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHBsYXlpbmcsIHdlIHdvbid0IGJlIGFkdmFuY2luZyB0aGUgYW5pbWF0aW9uXG4gICAgICAgIGlmKCEodGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORykpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9ucy5oYXModGhpcy5jdXJyZW50QW5pbWF0aW9uKSl7XG4gICAgICAgICAgICBsZXQgY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9ucy5nZXQodGhpcy5jdXJyZW50QW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5pbmRleDtcblxuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgKz0gMTtcbiAgICAgICAgICAgIGlmKHRoaXMuZnJhbWVQcm9ncmVzcyA+PSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uZHVyYXRpb24pe1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYmVlbiBvbiB0aGlzIGZyYW1lIGZvciBpdHMgd2hvbGUgZHVyYXRpb24sIGdvIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudEZyYW1lID49IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoaXMgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubG9vcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDdXJyZW50QW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gY3VycmVudCBhbmltYXRpb24sIGNhbid0IGFkdmFuY2UuIFdhcm4gdGhlIHVzZXJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5pbWF0aW9uIGluZGV4IGFuZCBhZHZhbmNlIHdhcyByZXF1ZXN0ZWQsIGJ1dCB0aGUgY3VycmVudCBhbmltYXRpb24gKCR7dGhpcy5jdXJyZW50QW5pbWF0aW9ufSkgaW4gbm9kZSB3aXRoIGlkOiAke3RoaXMub3duZXIuaWR9IHdhcyBpbnZhbGlkYCk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBFbmRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgZmlyZXMgYW55IG5lY2Vzc2FyeSBldmVudHMsIGFzIHdlbGwgYXMgc3RhcnRpbmcgYW55IG5ldyBhbmltYXRpb25zICovXG4gICAgcHJvdGVjdGVkIGVuZEN1cnJlbnRBbmltYXRpb24oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG5cbiAgICAgICAgaWYodGhpcy5vbkVuZEV2ZW50ICE9PSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkVuZEV2ZW50LCB7b3duZXI6IHRoaXMub3duZXIuaWQsIGFuaW1hdGlvbjogdGhpcy5jdXJyZW50QW5pbWF0aW9ufSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgYW5pbWF0aW9uLCBwbGF5IGl0XG4gICAgICAgIGlmKHRoaXMucGVuZGluZ0FuaW1hdGlvbiAhPT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLnBsYXkodGhpcy5wZW5kaW5nQW5pbWF0aW9uLCB0aGlzLnBlbmRpbmdMb29wLCB0aGlzLnBlbmRpbmdPbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gRG9lcyBub3QgcmVzdGFydCBpdCBpZiBpdCBpcyBhbHJlYWR5IHBsYXlpbmdcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIGFuaW1hdGlvbi4gRmFsc2UgYnkgZGVmYXVsdFxuICAgICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXG4gICAgICovXG4gICAgcGxheUlmTm90QWxyZWFkeShhbmltYXRpb246IHN0cmluZywgbG9vcD86IGJvb2xlYW4sIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMuY3VycmVudEFuaW1hdGlvbiAhPT0gYW5pbWF0aW9uKXtcbiAgICAgICAgICAgIHRoaXMucGxheShhbmltYXRpb24sIGxvb3AsIG9uRW5kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXlcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBhbmltYXRpb24uIEZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIG5hbWUgb2YgYW4gZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgYW5pbWF0aW9uIG5hdHVyYWxseSBzdG9wcyBwbGF5aW5nLiBUaGlzIG9ubHkgbWF0dGVycyBpZiBsb29wIGlzIGZhbHNlLlxuICAgICAqL1xuICAgIHBsYXkoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A/OiBib29sZWFuLCBvbkVuZD86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XG5cbiAgICAgICAgLy8gSWYgbG9vcCBhcmcgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdFxuICAgICAgICBpZihsb29wICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHdoYXQgdGhlIGpzb24gZmlsZSBzcGVjaWZpZWRcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IHRoaXMuYW5pbWF0aW9ucy5nZXQoYW5pbWF0aW9uKS5yZXBlYXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihvbkVuZCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRoaXMub25FbmRFdmVudCA9IG9uRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHBlbmRpbmcgYW5pbWF0aW9uXG4gICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVldWVzIGEgc2luZ2xlIGFuaW1hdGlvbiB0byBiZSBwbGF5ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLiBEb2VzIE5PVCBzdGFjay5cbiAgICAgKiBRdWV1ZWluZyBhZGRpdGlvbmFsIGFuaW1hdGlvbnMgcGFzdCAxIHdpbGwganVzdCByZXBsYWNlIHRoZSBxdWV1ZWQgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIHRvIHF1ZXVlXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIGxvb3AgdGhlIHF1ZXVlZCBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIGV2ZW50IHRvIGZpcmUgd2hlbiB0aGUgcXVldWVkIGFuaW1hdGlvbiBlbmRzXG4gICAgICovXG4gICAgcXVldWUoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4gPSBmYWxzZSwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICB0aGlzLnBlbmRpbmdMb29wID0gbG9vcDtcbiAgICAgICAgaWYob25FbmQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdPbkVuZCA9IG9uRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nT25FbmQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFBhdXNlcyB0aGUgY3VycmVudCBhbmltYXRpb24gKi9cbiAgICBwYXVzZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBBVVNFRDtcbiAgICB9XG5cbiAgICAvKiogUmVzdW1lcyB0aGUgY3VycmVudCBhbmltYXRpb24gaWYgcG9zc2libGUgKi9cbiAgICByZXN1bWUoKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBBVVNFRCl7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBTdG9wcyB0aGUgY3VycmVudCBhbmltYXRpb24uIFRoZSBhbmltYXRpb24gY2Fubm90IGJlIHJlc3VtZWQgYWZ0ZXIgdGhpcy4gKi9cbiAgICBzdG9wKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcbiAgICB9XG59IiwiaW1wb3J0IHsgVHdlZW5hYmxlUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IHsgRWFzZUZ1bmN0aW9uVHlwZSB9IGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5cbmV4cG9ydCBlbnVtIEFuaW1hdGlvblN0YXRlIHtcbiAgICBTVE9QUEVEID0gMCxcbiAgICBQQVVTRUQgPSAxLFxuICAgIFBMQVlJTkcgPSAyLFxufVxuXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uRGF0YSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGZyYW1lczogQXJyYXk8e2luZGV4OiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXJ9PjtcbiAgICByZXBlYXQ6IGJvb2xlYW4gPSBmYWxzZTtcbn1cblxuZXhwb3J0IGNsYXNzIFR3ZWVuRWZmZWN0IHtcbiAgICAvKiogVGhlIHByb3BlcnR5IHRvIHR3ZWVuICovXG4gICAgcHJvcGVydHk6IFR3ZWVuYWJsZVByb3BlcnRpZXM7XG5cbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIFR3ZWVuIHNob3VsZCByZXNldCB0aGUgcHJvcGVydHkgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIGFmdGVyIHBsYXlpbmcgKi9cbiAgICByZXNldE9uQ29tcGxldGU6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgdHdlZW4gKi9cbiAgICBzdGFydDogYW55O1xuXG4gICAgLyoqIFRoZSBlbmRpbmcgdmFsdWUgZm9yIHRoZSB0d2VlbiAqL1xuICAgIGVuZDogYW55O1xuXG4gICAgLyoqIFRoZSBlYXNlIGZ1bmN0aW9uIHRvIHVzZSAqL1xuICAgIGVhc2U6IEVhc2VGdW5jdGlvblR5cGU7XG5cbiAgICAvKiogRE8gTk9UIE1PRElGWSAtIFRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgLSBzZXQgYXV0b21hdGljYWxseSAqL1xuICAgIGluaXRpYWxWYWx1ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgVHdlZW5EYXRhIHtcbiAgICAvLyBNZW1iZXJzIGZvciBpbml0aWFsaXphdGlvbiBieSB0aGUgdXNlclxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSB0d2VlbiAqL1xuICAgIHN0YXJ0RGVsYXk6IG51bWJlcjtcbiAgICAvKiogVGhlIGR1cmF0aW9uIG9mIHRpbWUgb3ZlciB3aGljaCB0aGUgdmFsdWUgd2l0aCBjaGFuZ2UgZnJvbSBzdGFydCB0byBlbmQgKi9cbiAgICBkdXJhdGlvbjogbnVtYmVyO1xuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgZWZmZWN0cyBvbiB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0ICovXG4gICAgZWZmZWN0czogQXJyYXk8VHdlZW5FZmZlY3Q+O1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIHNob3VsZCByZXZlcnNlIGZyb20gZW5kIHRvIHN0YXJ0IGZvciBlYWNoIHByb3BlcnR5IHdoZW4gaXQgZmluaXNoZXMgKi9cbiAgICByZXZlcnNlT25Db21wbGV0ZTogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBzaG91bGQgbG9vcCB3aGVuIGl0IGNvbXBsZXRlcyAqL1xuICAgIGxvb3A6IGJvb2xlYW47XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIChpZiBhbnkpIHdoZW4gdGhlIHR3ZWVuIGZpbmlzaGVzIHBsYXlpbmcgKi9cbiAgICBvbkVuZDogc3RyaW5nXG5cbiAgICAvKiogRXh0cmEgZGF0YSB0byBiZSBzZW50IHdoZW4gdGhlIG9uRW5kIGV2ZW50IGlzIGZpcmVkLiBLZXlzIHdpdGggdGhlIG5hbWUgJ2tleScgb3IgJ25vZGUnIGFyZSByZXNlcnZlZCBhbmQgY2FuJ3QgYmUgdXNlZCBhcyBuYW1lcyBmb3IgeW91ciBleHRyYSBkYXRhICovXG4gICAgb25FbmREYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIFxuICAgIC8vIE1lbWJlcnMgZm9yIG1hbmFnZW1lbnQgYnkgdGhlIHR3ZWVuIG1hbmFnZXJcbiAgICAvKiogVGhlIHByb2dyZXNzIG9mIHRoaXMgdHdlZW4gdGhyb3VnaCBpdHMgZWZmZWN0cyAqL1xuICAgIHByb2dyZXNzOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRoYXQgaGFzIHBhc3NlZCBmcm9tIHdoZW4gdGhpcyB0d2VlbiBzdGFydGVkIHJ1bm5pbmcgKi9cbiAgICBlbGFwc2VkVGltZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBzdGF0ZSBvZiB0aGlzIHR3ZWVuICovXG4gICAgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gaXMgY3VycmVudGx5IHJldmVyc2luZyAqL1xuICAgIHJldmVyc2luZzogYm9vbGVhbjtcbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IFBhcnRpY2xlU3lzdGVtIGZyb20gXCIuL1BhcnRpY2xlU3lzdGVtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnRpY2xlU3lzdGVtTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFBhcnRpY2xlU3lzdGVtTWFuYWdlciA9IG51bGw7XG4gICAgXG4gICAgcHJvdGVjdGVkIHBhcnRpY2xlU3lzdGVtczogQXJyYXk8UGFydGljbGVTeXN0ZW0+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIge1xuICAgICAgICBpZihQYXJ0aWNsZVN5c3RlbU1hbmFnZXIuaW5zdGFuY2UgPT09IG51bGwpe1xuICAgICAgICAgICAgUGFydGljbGVTeXN0ZW1NYW5hZ2VyLmluc3RhbmNlID0gbmV3IFBhcnRpY2xlU3lzdGVtTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlU3lzdGVtTWFuYWdlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICByZWdpc3RlclBhcnRpY2xlU3lzdGVtKHN5c3RlbTogUGFydGljbGVTeXN0ZW0pe1xuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcy5wdXNoKHN5c3RlbSk7XG4gICAgfVxuXG4gICAgZGVyZWdpc3RlclBhcnRpY2xlU3lzdGVtKHN5c3RlbTogUGFydGljbGVTeXN0ZW0pe1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnBhcnRpY2xlU3lzdGVtcy5pbmRleE9mKHN5c3RlbSk7XG4gICAgICAgIHRoaXMucGFydGljbGVTeXN0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgY2xlYXJQYXJ0aWNsZVN5c3RlbXMoKXtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVN5c3RlbXMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgZm9yKGxldCBwYXJ0aWNsZVN5c3RlbSBvZiB0aGlzLnBhcnRpY2xlU3lzdGVtcyl7XG4gICAgICAgICAgICBwYXJ0aWNsZVN5c3RlbS51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgeyBBbmltYXRpb25TdGF0ZSwgVHdlZW5EYXRhIH0gZnJvbSBcIi4vQW5pbWF0aW9uVHlwZXNcIjtcbmltcG9ydCBFYXNlRnVuY3Rpb25zIGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBUd2Vlbk1hbmFnZXIgZnJvbSBcIi4vVHdlZW5NYW5hZ2VyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcblxuLyoqXG4gKiBBIG1hbmFnZXIgZm9yIHRoZSB0d2VlbnMgb2YgYSBHYW1lTm9kZS5cbiAqIFR3ZWVucyBhcmUgc2hvcnQgYW5pbWF0aW9ucyBwbGF5ZWQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHR3byBwcm9wZXJ0aWVzIHVzaW5nIGFuIGVhc2luZyBmdW5jdGlvbi5cbiAqIEZvciBhIGdvb2QgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMsIGNoZWNrIG91dCBAbGluayhodHRwczovL2Vhc2luZ3MubmV0LykoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pLlxuICogTXVsdGlwbGUgdHdlZW4gY2FuIGJlIHBsYXllZCBhdCB0aGUgc2FtZSB0aW1lLCBhcyBsb25nIGFzIHRoZXkgZG9uJ3QgY2hhbmdlIHRoZSBzYW1lIHByb3BlcnR5LlxuICogVGhpcyBhbGxvd3MgZm9yIHNvbWUgaW50ZXJlc3RpbmcgcG9saXNoZXMgb3IgYW5pbWF0aW9ucyB0aGF0IG1heSBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBkbyB3aXRoIHNwcml0ZSB3b3JrIGFsb25lXG4gKiAtIGVzcGVjaWFsbHkgcGl4ZWwgYXJ0IChzdWNoIGFzIHJvdGF0aW9ucyBvciBzY2FsaW5nKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHdlZW5Db250cm9sbGVyIHtcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoaXMgVHdlZW5Db250cm9sbGVyIGFjdHMgdXBvbiAqL1xuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XG4gICAgLyoqIFRoZSBsaXN0IG9mIGNyZWF0ZWQgdHdlZW5zICovXG4gICAgcHJvdGVjdGVkIHR3ZWVuczogTWFwPFR3ZWVuRGF0YT47XG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHdlZW5Db250cm9sbGVyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgVHdlZW5Db250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3duZXI6IEdhbWVOb2RlKXtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLnR3ZWVucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuICAgICAgICAvLyBHaXZlIG91cnNlbHZlcyB0byB0aGUgVHdlZW5NYW5hZ2VyXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgVHdlZW5Db250cm9sbGVyXG4gICAgICovXG4gICAgZGVzdHJveSgpe1xuICAgICAgICAvLyBPbmx5IHRoZSBnYW1lbm9kZSBhbmQgdGhlIHR3ZWVuIG1hbmFnZXIgc2hvdWxkIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhpc1xuICAgICAgICBkZWxldGUgdGhpcy5vd25lci50d2VlbnM7XG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLmRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgdHdlZW4gdG8gdGhpcyBnYW1lIG5vZGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlblxuICAgICAqIEBwYXJhbSB0d2VlbiBUaGUgZGF0YSBvZiB0aGUgdHdlZW5cbiAgICAgKi9cbiAgICBhZGQoa2V5OiBzdHJpbmcsIHR3ZWVuOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgVHdlZW5EYXRhKTogdm9pZCB7XG4gICAgICAgIGxldCB0eXBlZFR3ZWVuID0gPFR3ZWVuRGF0YT50d2VlbjtcblxuICAgICAgICAvLyBJbml0aWFsaXplIG1lbWJlcnMgdGhhdCB3ZSBuZWVkIChhbmQgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGUpXG4gICAgICAgIHR5cGVkVHdlZW4ucHJvZ3Jlc3MgPSAwO1xuICAgICAgICB0eXBlZFR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgdHlwZWRUd2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG5cbiAgICAgICAgdGhpcy50d2VlbnMuYWRkKGtleSwgdHlwZWRUd2Vlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxheSBhIHR3ZWVuIHdpdGggYSBjZXJ0YWluIG5hbWVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byBwbGF5XG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIHR3ZWVuIHNob3VsZCBsb29wXG4gICAgICovXG4gICAgcGxheShrZXk6IHN0cmluZywgbG9vcD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIC8vIFNldCBsb29wIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYobG9vcCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICB0d2Vlbi5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XG4gICAgICAgICAgICAgICAgaWYoZWZmZWN0LnJlc2V0T25Db21wbGV0ZSl7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC5pbml0aWFsVmFsdWUgPSB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdHdlZW4gcnVubmluZ1xuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRyaWVkIHRvIHBsYXkgdHdlZW4gXCIke2tleX1cIiBvbiBub2RlIHdpdGggaWQgJHt0aGlzLm93bmVyLmlkfSwgYnV0IG5vIHN1Y2ggdHdlZW4gZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgYSBwbGF5aW5nIHR3ZWVuLiBEb2VzIG5vdCBhZmZlY3QgdHdlZW5zIHRoYXQgYXJlIHN0b3BwZWQuXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGF1c2UuXG4gICAgICovXG4gICAgcGF1c2Uoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgdGhpcy50d2VlbnMuZ2V0KGtleSkuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QQVVTRUQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIGEgcGF1c2VkIHR3ZWVuLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHJlc3VtZVxuICAgICAqL1xuICAgIHJlc3VtZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpXG4gICAgICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cbiAgICAgKi9cbiAgICBzdG9wKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdG8gdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcbiAgICAgICAgICAgICAgICBpZihlZmZlY3QucmVzZXRPbkNvbXBsZXRlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldID0gZWZmZWN0LmluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmF0dXJhbCBzdG9wIG9mIGEgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHR3ZWVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGVuZChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0b3Aoa2V5KTtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB0d2VlblxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIC8vIElmIGl0IGhhcyBhbiBvbkVuZCwgc2VuZCBhbiBldmVudFxuICAgICAgICAgICAgaWYodHdlZW4ub25FbmQpe1xuICAgICAgICAgICAgICAgIGxldCBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge2tleToga2V5LCBub2RlOiB0aGlzLm93bmVyLmlkfVxuICAgICAgICAgICAgICAgIC8vIElmIGl0IGhhcyBvbkVuZCBldmVudCBkYXRhLCBhZGQgZWFjaCBlbnRyeSwgYXMgbG9uZyBhcyB0aGUga2V5IGlzIG5vdCBuYW1lZCAna2V5JyBvciAnbm9kZSdcbiAgICAgICAgICAgICAgICBpZiAodHdlZW4ub25FbmREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHR3ZWVuLm9uRW5kRGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJrZXlcIiAmJiBrZXkgIT09IFwibm9kZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtrZXldID0gdHdlZW4ub25FbmREYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodHdlZW4ub25FbmQsIGRhdGEpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFsbCBjdXJyZW50bHkgcGxheWluZyB0d2VlbnNcbiAgICAgKi9cbiAgICBzdG9wQWxsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB0aGlzLnN0b3Aoa2V5KSk7XG4gICAgfVxuICAgIFxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HKXtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIG9mIHRoZSB0d2VlblxuICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lICs9IGRlbHRhVCoxMDAwO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgcGFzdCB0aGUgc3RhcnREZWxheSwgZG8gdGhlIHR3ZWVuXG4gICAgICAgICAgICAgICAgaWYodHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF0d2Vlbi5yZXZlcnNpbmcgJiYgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIHR3ZWVuLmR1cmF0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG92ZXIgdGltZSwgc3RvcCB0aGUgdHdlZW4sIGxvb3AsIG9yIHJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2VPbkNvbXBsZXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVyIHRpbWUgYW5kIGNhbiByZXZlcnNlLCBkbyBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHdlZW4ubG9vcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcmV2ZXJzZSBhbmQgY2FuIGxvb3AsIGRvIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gdHdlZW4uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBsb29waW5nIGFuZCBjYW4ndCByZXZlcnNlLCBzbyBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgZW5kIG9mIHJldmVyc2luZ1xuICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNpbmcgJiYgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIDIqdHdlZW4uZHVyYXRpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ubG9vcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gMip0d2Vlbi5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MsIG1ha2Ugc3VyZSBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEuIEVycm9ycyBmcm9tIHRoaXMgc2hvdWxkIG5ldmVyIGJlIGxhcmdlXG4gICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2luZyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5wcm9ncmVzcyA9IE1hdGhVdGlscy5jbGFtcDAxKCgyKnR3ZWVuLmR1cmF0aW9uIC0gKHR3ZWVuLmVsYXBzZWRUaW1lLSB0d2Vlbi5zdGFydERlbGF5KSkvdHdlZW4uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSBNYXRoVXRpbHMuY2xhbXAwMSgodHdlZW4uZWxhcHNlZFRpbWUgLSB0d2Vlbi5zdGFydERlbGF5KS90d2Vlbi5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBlYXNlIGZ1bmN0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gb3VyIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWFzZSA9IEVhc2VGdW5jdGlvbnNbZWZmZWN0LmVhc2VdKHR3ZWVuLnByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB2YWx1ZSB0byBsZXJwIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gTWF0aFV0aWxzLmxlcnAoZWZmZWN0LnN0YXJ0LCBlZmZlY3QuZW5kLCBlYXNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBUd2VlbkNvbnRyb2xsZXIgZnJvbSBcIi4vVHdlZW5Db250cm9sbGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFR3ZWVuTWFuYWdlciA9IG51bGw7XG4gICAgXG4gICAgcHJvdGVjdGVkIHR3ZWVuQ29udHJvbGxlcnM6IEFycmF5PFR3ZWVuQ29udHJvbGxlcj47XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBUd2Vlbk1hbmFnZXIge1xuICAgICAgICBpZihUd2Vlbk1hbmFnZXIuaW5zdGFuY2UgPT09IG51bGwpe1xuICAgICAgICAgICAgVHdlZW5NYW5hZ2VyLmluc3RhbmNlID0gbmV3IFR3ZWVuTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR3ZWVuTWFuYWdlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICByZWdpc3RlclR3ZWVuQ29udHJvbGxlcihjb250cm9sbGVyOiBUd2VlbkNvbnRyb2xsZXIpe1xuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICBkZXJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKGNvbnRyb2xsZXI6IFR3ZWVuQ29udHJvbGxlcil7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMudHdlZW5Db250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBjbGVhclR3ZWVuQ29udHJvbGxlcnMoKXtcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzID0gbmV3IEFycmF5KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgdHdlZW5Db250cm9sbGVyIG9mIHRoaXMudHdlZW5Db250cm9sbGVycyl7XG4gICAgICAgICAgICB0d2VlbkNvbnRyb2xsZXIudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IEdyYXBoaWNSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvR3JhcGhpY1JlbmRlcmVyXCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCJcbmltcG9ydCBUaWxlbWFwUmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL1RpbGVtYXBSZW5kZXJlclwiO1xuaW1wb3J0IFVJRWxlbWVudFJlbmRlcmVyIGZyb20gXCIuL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlclwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IExpbmUgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBJc29tZXRyaWNUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9Jc29tZXRyaWNUaWxlbWFwXCI7XG5pbXBvcnQgU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcHMvU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcFwiO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBSZW5kZXJpbmdNYW5hZ2VyIGNsYXNzIHVzaW5nIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgcHJvdGVjdGVkIGdyYXBoaWNSZW5kZXJlcjogR3JhcGhpY1JlbmRlcmVyO1xuICAgIHByb3RlY3RlZCB0aWxlbWFwUmVuZGVyZXI6IFRpbGVtYXBSZW5kZXJlcjtcbiAgICBwcm90ZWN0ZWQgdWlFbGVtZW50UmVuZGVyZXI6IFVJRWxlbWVudFJlbmRlcmVyO1xuXG4gICAgcHJvdGVjdGVkIG9yaWdpbjogVmVjMjtcbiAgICBwcm90ZWN0ZWQgem9vbTogbnVtYmVyO1xuXG4gICAgcHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKXtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcbiAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMud29ybGRTaXplID0gbmV3IFZlYzIod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyID0gbmV3IEdyYXBoaWNSZW5kZXJlcih0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyID0gbmV3IFRpbGVtYXBSZW5kZXJlcih0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIgPSBuZXcgVUlFbGVtZW50UmVuZGVyZXIodGhpcy5jdHgpXG5cbiAgICAgICAgLy8gRm9yIGNyaXNwIHBpeGVsIGFydFxuICAgICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jdHg7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcmVuZGVyKHZpc2libGVTZXQ6IENhbnZhc05vZGVbXSwgdGlsZW1hcHM6IFRpbGVtYXBbXSwgdWlMYXllcnM6IE1hcDxVSUxheWVyPik6IHZvaWQge1xuICAgICAgICAvLyBTb3J0IGJ5IGRlcHRoLCB0aGVuIGJ5IHZpc2libGUgc2V0IGJ5IHktdmFsdWVcbiAgICAgICAgdmlzaWJsZVNldC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZihhLmdldExheWVyKCkuZ2V0RGVwdGgoKSA9PT0gYi5nZXRMYXllcigpLmdldERlcHRoKCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiAoYS5ib3VuZGFyeS5ib3R0b20pIC0gKGIuYm91bmRhcnkuYm90dG9tKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpIC0gYi5nZXRMYXllcigpLmdldERlcHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCB0aWxlbWFwSW5kZXggPSAwO1xuICAgICAgICBsZXQgdGlsZW1hcExlbmd0aCA9IHRpbGVtYXBzLmxlbmd0aDtcblxuICAgICAgICBsZXQgdmlzaWJsZVNldEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHZpc2libGVTZXRMZW5ndGggPSB2aXNpYmxlU2V0Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSh0aWxlbWFwSW5kZXggPCB0aWxlbWFwTGVuZ3RoIHx8IHZpc2libGVTZXRJbmRleCA8IHZpc2libGVTZXRMZW5ndGgpe1xuICAgICAgICAgICAgLy8gQ2hlY2sgY29uZGl0aW9ucyB3aGVyZSB3ZSd2ZSBhbHJlYWR5IHJlYWNoZWQgdGhlIGVkZ2Ugb2Ygb25lIGxpc3RcbiAgICAgICAgICAgIGlmKHRpbGVtYXBJbmRleCA+PSB0aWxlbWFwTGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbmRlciB0aGUgcmVtYWluaW5nIHZpc2libGUgc2V0XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZihub2RlLnZpc2libGUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih2aXNpYmxlU2V0SW5kZXggPj0gdmlzaWJsZVNldExlbmd0aCl7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZW5kZXIgdGlsZW1hcHNcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGVtYXAodGlsZW1hcHNbdGlsZW1hcEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVuZGVyIHdoaWNoZXZlciBpcyBmdXJ0aGVyIGRvd25cbiAgICAgICAgICAgIGlmKHRpbGVtYXBzW3RpbGVtYXBJbmRleF0uZ2V0TGF5ZXIoKS5nZXREZXB0aCgpIDw9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4XS5nZXRMYXllcigpLmdldERlcHRoKCkpe1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZW1hcCh0aWxlbWFwc1t0aWxlbWFwSW5kZXgrK10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmKG5vZGUudmlzaWJsZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5kZXIgdGhlIHVpTGF5ZXJzIG9uIHRvcCBvZiBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgbGV0IHNvcnRlZFVJTGF5ZXJzID0gbmV3IEFycmF5PFVJTGF5ZXI+KCk7XG5cbiAgICAgICAgdWlMYXllcnMuZm9yRWFjaChrZXkgPT4gc29ydGVkVUlMYXllcnMucHVzaCh1aUxheWVycy5nZXQoa2V5KSkpO1xuXG4gICAgICAgIHNvcnRlZFVJTGF5ZXJzID0gc29ydGVkVUlMYXllcnMuc29ydCgodWkxLCB1aTIpID0+IHVpMS5nZXREZXB0aCgpIC0gdWkyLmdldERlcHRoKCkpO1xuXG4gICAgICAgIHNvcnRlZFVJTGF5ZXJzLmZvckVhY2godWlMYXllciA9PiB7XG5cdFx0XHRpZighdWlMYXllci5pc0hpZGRlbigpKVxuXHRcdFx0XHR1aUxheWVyLmdldEl0ZW1zKCkuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYoKDxDYW52YXNOb2RlPm5vZGUpLnZpc2libGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKDxDYW52YXNOb2RlPm5vZGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuXHRcdH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzcGVjaWZpZWQgQ2FudmFzTm9kZVxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBDYW52YXNOb2RlIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW5kZXJOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0IGFjY29yZGluZyB0byB0aGlzIHNwcml0ZVxuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGUpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgem9vbSBsZXZlbCBvZiB0aGUgc2NlbmVcbiAgICAgICAgdGhpcy56b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1vdmUgdGhlIGNhbnZhcyB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgYW5kIHJvdGF0ZVxuICAgICAgICBsZXQgeFNjYWxlID0gMTtcbiAgICAgICAgbGV0IHlTY2FsZSA9IDE7XG4gICAgICAgIFxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcbiAgICAgICAgICAgIHhTY2FsZSA9IG5vZGUuaW52ZXJ0WCA/IC0xIDogMTtcbiAgICAgICAgICAgIHlTY2FsZSA9IG5vZGUuaW52ZXJ0WSA/IC0xIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSh4U2NhbGUsIDAsIDAsIHlTY2FsZSwgKG5vZGUucG9zaXRpb24ueCAtIHRoaXMub3JpZ2luLngpKnRoaXMuem9vbSwgKG5vZGUucG9zaXRpb24ueSAtIHRoaXMub3JpZ2luLnkpKnRoaXMuem9vbSk7XG4gICAgICAgIHRoaXMuY3R4LnJvdGF0ZSgtbm9kZS5yb3RhdGlvbik7XG4gICAgICAgIGxldCBnbG9iYWxBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgUmVjdCl7XG4gICAgICAgICAgICBEZWJ1Zy5sb2coXCJub2RlXCIgKyBub2RlLmlkLCBcIk5vZGVcIiArIG5vZGUuaWQgKyBcIiBBbHBoYTogXCIgKyBub2RlLmFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IG5vZGUuYWxwaGE7XG4gICAgICAgIFxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJBbmltYXRlZFNwcml0ZSg8QW5pbWF0ZWRTcHJpdGU+bm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU3ByaXRlKDxTcHJpdGU+bm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgR3JhcGhpYyl7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyYXBoaWMoPEdyYXBoaWM+bm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgVUlFbGVtZW50KXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVUlFbGVtZW50KDxVSUVsZW1lbnQ+bm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQge1xuICAgICAgICAvLyBHZXQgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2Uoc3ByaXRlLmltYWdlSWQpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIGltYWdlOlxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc3RhcnQgLT4geCwgeVxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc2l6ZSAgLT4gdywgaFxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSB3b3JsZFxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc3RhcnQgLT4geCwgeVxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc2l6ZSAgLT4gdywgaFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAgICAgICBzcHJpdGUuaW1hZ2VPZmZzZXQueCwgc3ByaXRlLmltYWdlT2Zmc2V0LnksXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54LCBzcHJpdGUuc2l6ZS55LFxuICAgICAgICAgICAgKC1zcHJpdGUuc2l6ZS54KnNwcml0ZS5zY2FsZS54LzIpKnRoaXMuem9vbSwgKC1zcHJpdGUuc2l6ZS55KnNwcml0ZS5zY2FsZS55LzIpKnRoaXMuem9vbSxcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLnggKiBzcHJpdGUuc2NhbGUueCp0aGlzLnpvb20sIHNwcml0ZS5zaXplLnkgKiBzcHJpdGUuc2NhbGUueSp0aGlzLnpvb20pO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHByb3RlY3RlZCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZCB7XG4gICAgICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRJbWFnZShzcHJpdGUuaW1hZ2VJZCk7XG5cbiAgICAgICAgbGV0IGFuaW1hdGlvbkluZGV4ID0gc3ByaXRlLmFuaW1hdGlvbi5nZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTtcblxuICAgICAgICBsZXQgYW5pbWF0aW9uT2Zmc2V0ID0gc3ByaXRlLmdldEFuaW1hdGlvbk9mZnNldChhbmltYXRpb25JbmRleCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgaW1hZ2U6XG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzdGFydCAtPiB4LCB5XG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzaXplICAtPiB3LCBoXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIHdvcmxkIChnaXZlbiB3ZSBtb3ZlZClcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHN0YXJ0IC0+IC13LzIsIC1oLzJcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHNpemUgIC0+IHcsIGhcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAgICAgc3ByaXRlLmltYWdlT2Zmc2V0LnggKyBhbmltYXRpb25PZmZzZXQueCwgc3ByaXRlLmltYWdlT2Zmc2V0LnkgKyBhbmltYXRpb25PZmZzZXQueSxcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLngsIHNwcml0ZS5zaXplLnksXG4gICAgICAgICAgICAoLXNwcml0ZS5zaXplLngqc3ByaXRlLnNjYWxlLngvMikqdGhpcy56b29tLCAoLXNwcml0ZS5zaXplLnkqc3ByaXRlLnNjYWxlLnkvMikqdGhpcy56b29tLFxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCAqIHNwcml0ZS5zY2FsZS54KnRoaXMuem9vbSwgc3ByaXRlLnNpemUueSAqIHNwcml0ZS5zY2FsZS55KnRoaXMuem9vbSk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQge1xuICAgICAgICBpZihncmFwaGljIGluc3RhbmNlb2YgUG9pbnQpe1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIucmVuZGVyUG9pbnQoPFBvaW50PmdyYXBoaWMsIHRoaXMuem9vbSk7XG4gICAgICAgIH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgTGluZSl7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJMaW5lKDxMaW5lPmdyYXBoaWMsIHRoaXMub3JpZ2luLCB0aGlzLnpvb20pO1xuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFJlY3Qpe1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIucmVuZGVyUmVjdCg8UmVjdD5ncmFwaGljLCB0aGlzLnpvb20pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5yZW5kZXJUaWxlbWFwKHRpbGVtYXApO1xuICAgICAgICBcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyTGFiZWwodWlFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIEJ1dHRvbil7XG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlckJ1dHRvbih1aUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgU2xpZGVyKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyU2xpZGVyKHVpRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBUZXh0SW5wdXQpe1xuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJUZXh0SW5wdXQodWlFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKGNsZWFyQ29sb3I6IENvbG9yKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvci50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbR3JhcGhpY11zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoaWNSZW5kZXJlciB7XG4gICAgLyoqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIG9mIHRoZSBnYW1lIGVuZ2luZSAqL1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICAvKiogVGhlIGN1cnJlbnQgc2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgKi9cbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgR3JhcGhpY1JlbmRlcmVyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXG4gICAgICovXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgcmVuZGVyUG9pbnQocG9pbnQ6IFBvaW50LCB6b29tOiBudW1iZXIpOiB2b2lkIHtcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBwb2ludC5jb2xvci50b1N0cmluZ1JHQkEoKTtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoKC1wb2ludC5zaXplLngvMikqem9vbSwgKC1wb2ludC5zaXplLnkvMikqem9vbSxcbiAgICAgICAgcG9pbnQuc2l6ZS54Knpvb20sIHBvaW50LnNpemUueSp6b29tKTtcbiAgICB9XG5cbiAgICByZW5kZXJMaW5lKGxpbmU6IExpbmUsIG9yaWdpbjogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGluZS5jb2xvci50b1N0cmluZ1JHQkEoKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gbGluZS50aGlja25lc3M7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbygobGluZS5lbmQueCAtIGxpbmUuc3RhcnQueCkqem9vbSwgKGxpbmUuZW5kLnkgLSBsaW5lLnN0YXJ0LnkpKnpvb20pO1xuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHJlY3RcbiAgICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIHJlbmRlclJlY3QocmVjdDogUmVjdCwgem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIERyYXcgdGhlIGludGVyaW9yIG9mIHRoZSByZWN0XG4gICAgICAgIGlmKHJlY3QuY29sb3IuYSAhPT0gMCl7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSByZWN0LmNvbG9yLnRvU3RyaW5nUkdCKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgoLXJlY3Quc2l6ZS54LzIpKnpvb20sICgtcmVjdC5zaXplLnkvMikqem9vbSwgcmVjdC5zaXplLngqem9vbSwgcmVjdC5zaXplLnkqem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IHRoZSBib3JkZXIgb2YgdGhlIHJlY3QgaWYgaXQgaXNuJ3QgdHJhbnNwYXJlbnRcbiAgICAgICAgaWYocmVjdC5ib3JkZXJDb2xvci5hICE9PSAwKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gcmVjdC5nZXRCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSByZWN0LmdldEJvcmRlcldpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KCgtcmVjdC5zaXplLngvMikqem9vbSwgKC1yZWN0LnNpemUueS8yKSp6b29tLCByZWN0LnNpemUueCp6b29tLCByZWN0LnNpemUueSp6b29tKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBJc29tZXRyaWNUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9Jc29tZXRyaWNUaWxlbWFwXCI7XG5pbXBvcnQgU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvU3RhZ2dlcmVkSXNvbWV0cmljVGlsZW1hcFwiO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHRvIHJlbmRlciBAcmVmZXJlbmNlW1RpbGVtYXBdc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwUmVuZGVyZXIge1xuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBUaWxlbWFwUmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gb3J0aG9nb25hbCB0aWxlbWFwXG4gICAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XG4gICAgICAgIGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdGlsZW1hcC5nZXRMYXllcigpLmdldEFscGhhKCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgb3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24odGlsZW1hcCk7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldEhhbGZTaXplKCk7XG4gICAgICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcbiAgICAgICAgbGV0IGJvdHRvbVJpZ2h0ID0gb3JpZ2luLmNsb25lKCkuYWRkKHNpemUuc2NhbGVkKDIqem9vbSkpO1xuXG4gICAgICAgIGlmKHRpbGVtYXAudmlzaWJsZSl7XG4gICAgICAgICAgICBsZXQgbWluQ29sUm93ID0gdGlsZW1hcC5nZXRNaW5Db2xSb3codGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldFZpZXcoKSk7XG4gICAgICAgICAgICBsZXQgbWF4Q29sUm93ID0gdGlsZW1hcC5nZXRNYXhDb2xSb3codGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldFZpZXcoKSk7XG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IG1pbkNvbFJvdy55OyByb3cgPD0gbWF4Q29sUm93Lnk7IHJvdysrKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGNvbCA9IG1pbkNvbFJvdy54OyBjb2wgPD0gbWF4Q29sUm93Lng7IGNvbCsrKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0aWxlIGF0IHRoaXMgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbGUgPSB0aWxlbWFwLmdldFRpbGUoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHJvdC9mbGlwIHBhcmFtZXRlcnMgaWYgdGhlcmUgYXJlIGFueVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4RSA8PCAyOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdEZsaXAgPSAoKG1hc2sgJiB0aWxlKSA+PiAyOCkgJiAweEY7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUgPSB0aWxlICYgfm1hc2s7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgdGlsZXNldCB0aGF0IG93bnMgdGhpcyB0aWxlIGluZGV4IGFuZCByZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXAuZ2V0VGlsZXNldHMoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aWxlc2V0Lmhhc1RpbGUodGlsZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZSh0aWxlbWFwLCB0aWxlc2V0LCB0aWxlLCBjb2wsIHJvdywgb3JpZ2luLCB0aWxlbWFwLnNjYWxlLCB6b29tLCByb3RGbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgdGlsZVxuICAgICAqIEBwYXJhbSB0aWxlc2V0IFRoZSB0aWxlc2V0IHRoaXMgdGlsZSBiZWxvbmdzIHRvIFxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXG4gICAgICogQHBhcmFtIHRpbGVtYXBSb3cgVGhlIHJvdyBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB0aWxlbWFwQ29sIFRoZSBjb2x1bW4gb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW5kZXJUaWxlKHRpbGVtYXA6IFRpbGVtYXAsIHRpbGVzZXQ6IFRpbGVzZXQsIHRpbGVJbmRleDogbnVtYmVyLCB0aWxlbWFwQ29sOiBudW1iZXIsIHRpbGVtYXBSb3c6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyLCByb3RGbGlwOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2UodGlsZXNldC5nZXRJbWFnZUtleSgpKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNpemUgb2YgdGhlIHRpbGUgdG8gcmVuZGVyXG4gICAgICAgIGxldCB0aWxlU2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGlsZVNpemUueDtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRpbGVTaXplLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcbiAgICAgICAgbGV0IGltYWdlUG9zaXRpb24gPSB0aWxlc2V0LmdldEltYWdlT2Zmc2V0Rm9yVGlsZSh0aWxlSW5kZXgpO1xuICAgICAgICBsZXQgbGVmdCA9IGltYWdlUG9zaXRpb24ueFxuICAgICAgICBsZXQgdG9wID0gaW1hZ2VQb3NpdGlvbi55O1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHdvcmxkIHRvIHJlbmRlciB0aGUgdGlsZVxuICAgICAgICBsZXQgd29ybGRQb3NpdGlvbiA9IHRpbGVtYXAuZ2V0V29ybGRQb3NpdGlvbih0aWxlbWFwQ29sLCB0aWxlbWFwUm93KTtcblxuICAgICAgICBsZXQgd29ybGRYID0gTWF0aC5mbG9vcigod29ybGRQb3NpdGlvbi54IC0gb3JpZ2luLngpKnpvb20pO1xuICAgICAgICBsZXQgd29ybGRZID0gTWF0aC5mbG9vcigod29ybGRQb3NpdGlvbi55IC0gb3JpZ2luLnkpKnpvb20pO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGUgd29ybGQgdG8gcmVuZGVyIHRoZSB0aWxlIGluXG4gICAgICAgIGxldCB3b3JsZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pO1xuICAgICAgICBsZXQgd29ybGRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pO1xuXG4gICAgICAgIGlmKHJvdEZsaXAgIT09IDApe1xuICAgICAgICAgICAgbGV0IHNjYWxlWCA9IDE7XG4gICAgICAgICAgICBsZXQgc2NhbGVZID0gMTtcbiAgICAgICAgICAgIGxldCBzaGVhclggPSAwO1xuICAgICAgICAgICAgbGV0IHNoZWFyWSA9IDA7XG5cbiAgICAgICAgICAgIC8vIEZsaXAgb24gdGhlIHgtYXhpc1xuICAgICAgICAgICAgaWYocm90RmxpcCAmIDgpe1xuICAgICAgICAgICAgICAgIHNjYWxlWCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGbGlwIG9uIHRoZSB5LWF4aXNcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiA0KXtcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmxpcCBvdmVyIHRoZSBsaW5lIHk9eFxuICAgICAgICAgICAgaWYocm90RmxpcCAmIDIpe1xuICAgICAgICAgICAgICAgIHNoZWFyWCA9IHNjYWxlWTtcbiAgICAgICAgICAgICAgICBzaGVhclkgPSBzY2FsZVg7XG4gICAgICAgICAgICAgICAgc2NhbGVYID0gMDtcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCBzaGVhclgsIHNoZWFyWSwgc2NhbGVZLCB3b3JsZFggKyB3b3JsZFdpZHRoLzIsIHdvcmxkWSArIHdvcmxkSGVpZ2h0LzIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgdGlsZVxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAgICAgICAgIGxlZnQsIHRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIC13b3JsZFdpZHRoLzIsIC13b3JsZEhlaWdodC8yLFxuICAgICAgICAgICAgICAgIHdvcmxkV2lkdGgsIHdvcmxkSGVpZ2h0KTtcblxuICAgICAgICAgICAgaWYocm90RmxpcCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gcm90YXRpb25zLCBkb24ndCBkbyB0aGUgY2FsY3VsYXRpb25zLCBqdXN0IHJlbmRlciB0aGUgdGlsZVxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSB0aWxlXG4gICAgICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXG4gICAgICAgICAgICAgICAgbGVmdCwgdG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgd29ybGRYLCB3b3JsZFksXG4gICAgICAgICAgICAgICAgd29ybGRXaWR0aCwgd29ybGRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgZ2V0T3J0aG9nb25hbFRpbGVEcmF3UG9zKG1hcDogT3J0aG9nb25hbFRpbGVtYXAsIHNldDogVGlsZXNldCwgY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGxldCBpbWdzaXplOiBWZWMyID0gc2V0LmdldFRpbGVTaXplKCkubXVsdChtYXAuc2NhbGUpO1xuICAgICAgICBsZXQgbWFwc2l6ZTogVmVjMiA9IG1hcC5nZXRTY2FsZWRUaWxlU2l6ZSgpO1xuICAgICAgICByZXR1cm4gbWFwLmdldFdvcmxkUG9zaXRpb24oY29sLCByb3cpLnN1YihpbWdzaXplLnN1YihtYXBzaXplKSk7XG4gICAgfVxuICAgIHByb3RlY3RlZCBnZXRJc29tZXRyaWNUaWxlRHJhd1BvcyhtYXA6IFRpbGVtYXAsIHNldDogVGlsZXNldCwgY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGxldCBzaXplOiBWZWMyID0gc2V0LmdldFRpbGVTaXplKCk7XG4gICAgICAgIGxldCBkcmF3UG9zOiBWZWMyID0gbWFwLmdldFNjYWxlZFRpbGVTaXplKCkuc3ViKG5ldyBWZWMyKHNpemUueCptYXAuc2NhbGUueCwgc2l6ZS55Km1hcC5zY2FsZS55KSk7XG4gICAgICAgIGRyYXdQb3MuaW5jKC1zaXplLngqbWFwLnNjYWxlLngvMiwgMCk7XG4gICAgICAgIGRyYXdQb3MuYWRkKG1hcC5nZXRXb3JsZFBvc2l0aW9uKGNvbCwgcm93KSk7XG4gICAgICAgIHJldHVybiBkcmF3UG9zO1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGhlbHAgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHJlbmRlciBAcmVmZXJlbmNlW1VJRWxlbWVudF1zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJRWxlbWVudFJlbmRlcmVyIHtcbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgVUlFbGVtZW50UmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBsYWJlbFxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyTGFiZWwobGFiZWw6IExhYmVsKTogdm9pZCB7XG4gICAgICAgIC8vIElmIHRoZSBzaXplIGlzIHVuYXNzaWduZWQgKGJ5IHRoZSB1c2VyIG9yIGF1dG9tYXRpY2FsbHkpIGFzc2lnbiBpdFxuICAgICAgICBsYWJlbC5oYW5kbGVJbml0aWFsU2l6aW5nKHRoaXMuY3R4KTtcblx0XHRcblx0XHQvLyBHcmFiIHRoZSBnbG9iYWwgYWxwaGEgc28gd2UgY2FuIGFkanVzdCBpdCBmb3IgdGhpcyByZW5kZXJcblx0XHRsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuXG4gICAgICAgIC8vIEdldCB0aGUgZm9udCBhbmQgdGV4dCBwb3NpdGlvbiBpbiBsYWJlbFxuXHRcdHRoaXMuY3R4LmZvbnQgPSBsYWJlbC5nZXRGb250U3RyaW5nKCk7XG5cdFx0bGV0IG9mZnNldCA9IGxhYmVsLmNhbGN1bGF0ZVRleHRPZmZzZXQodGhpcy5jdHgpO1xuXG5cdFx0Ly8gU3Ryb2tlIGFuZCBmaWxsIGEgcm91bmRlZCByZWN0IGFuZCBnaXZlIGl0IHRleHRcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLmJhY2tncm91bmRDb2xvci5hO1xuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpLnRvU3RyaW5nUkdCQSgpO1xuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCgtbGFiZWwuc2l6ZS54LzIsIC1sYWJlbC5zaXplLnkvMixcblx0XHRcdGxhYmVsLnNpemUueCwgbGFiZWwuc2l6ZS55LCBsYWJlbC5ib3JkZXJSYWRpdXMpO1xuXHRcdFxuXHRcdHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGFiZWwuY2FsY3VsYXRlQm9yZGVyQ29sb3IoKS50b1N0cmluZ1JHQkEoKTtcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLmJvcmRlckNvbG9yLmE7XG5cdFx0dGhpcy5jdHgubGluZVdpZHRoID0gbGFiZWwuYm9yZGVyV2lkdGg7XG5cdFx0dGhpcy5jdHguc3Ryb2tlUm91bmRlZFJlY3QoLWxhYmVsLnNpemUueC8yLCAtbGFiZWwuc2l6ZS55LzIsXG5cdFx0XHRsYWJlbC5zaXplLngsIGxhYmVsLnNpemUueSwgbGFiZWwuYm9yZGVyUmFkaXVzKTtcblxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZVRleHRDb2xvcigpO1xuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwudGV4dENvbG9yLmE7XG5cdFx0dGhpcy5jdHguZmlsbFRleHQobGFiZWwudGV4dCwgb2Zmc2V0LnggLSBsYWJlbC5zaXplLngvMiwgb2Zmc2V0LnkgLSBsYWJlbC5zaXplLnkvMik7XG5cdFxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgYnV0dG9uXG4gICAgICogQHBhcmFtIGJ1dHRvbiBUaGUgYnV0dG9uIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlckJ1dHRvbihidXR0b246IEJ1dHRvbik6IHZvaWQge1xuICAgICAgICB0aGlzLnJlbmRlckxhYmVsKGJ1dHRvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHNsaWRlclxuICAgICAqIEBwYXJhbSBzbGlkZXIgVGhlIHNsaWRlciB0byByZW5kZXJcbiAgICAgKi9cbiAgICByZW5kZXJTbGlkZXIoc2xpZGVyOiBTbGlkZXIpOiB2b2lkIHtcblx0XHQvLyBHcmFiIHRoZSBnbG9iYWwgYWxwaGEgc28gd2UgY2FuIGFkanVzdCBpdCBmb3IgdGhpcyByZW5kZXJcblx0XHRsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gc2xpZGVyLmdldExheWVyKCkuZ2V0QWxwaGEoKTtcblxuICAgICAgICAvLyBDYWxjdWFsYXRlIHRoZSBzbGlkZXIgc2l6ZVxuICAgICAgICBsZXQgc2xpZGVyU2l6ZSA9IG5ldyBWZWMyKHNsaWRlci5zaXplLngsIDIpO1xuXG4gICAgICAgIC8vIERyYXcgdGhlIHNsaWRlclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNsaWRlci5zbGlkZXJDb2xvci50b1N0cmluZygpO1xuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCgtc2xpZGVyU2l6ZS54LzIsIC1zbGlkZXJTaXplLnkvMixcbiAgICAgICAgICAgIHNsaWRlclNpemUueCwgc2xpZGVyU2l6ZS55LCBzbGlkZXIuYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5pYiBzaXplIGFuZCBwb3NpdGlvblxuICAgICAgICBsZXQgeCA9IE1hdGhVdGlscy5sZXJwKC1zbGlkZXIuc2l6ZS54LzIsIHNsaWRlci5zaXplLngvMiwgc2xpZGVyLmdldFZhbHVlKCkpO1xuXG4gICAgICAgIC8vIERyYXcgdGhlIG5pYlxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNsaWRlci5uaWJDb2xvci50b1N0cmluZygpO1xuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCh4LXNsaWRlci5uaWJTaXplLngvMiwgLXNsaWRlci5uaWJTaXplLnkvMixcbiAgICAgICAgICAgIHNsaWRlci5uaWJTaXplLngsIHNsaWRlci5uaWJTaXplLnksIHNsaWRlci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBhbHBoYVxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHByZXZpb3VzQWxwaGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHRleHRJbnB1dFxuICAgICAqIEBwYXJhbSB0ZXh0SW5wdXQgVGhlIHRleHRJbnB1dCB0byByZW5kZXJcbiAgICAgKi9cbiAgICByZW5kZXJUZXh0SW5wdXQodGV4dElucHV0OiBUZXh0SW5wdXQpOiB2b2lkIHtcbiAgICAgICAgLy8gU2hvdyBhIGN1cnNvciBzb21ldGltZXNcbiAgICAgICAgaWYodGV4dElucHV0LmZvY3VzZWQgJiYgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgJSA2MCA+IDMwKXtcbiAgICAgICAgICAgIHRleHRJbnB1dC50ZXh0ICs9IFwifFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXJMYWJlbCh0ZXh0SW5wdXQpO1xuXG4gICAgICAgIGlmKHRleHRJbnB1dC5mb2N1c2VkKXtcbiAgICAgICAgICAgIGlmKHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICUgNjAgPiAzMCl7XG4gICAgICAgICAgICAgICAgdGV4dElucHV0LnRleHQgPSB0ZXh0SW5wdXQudGV4dC5zdWJzdHJpbmcoMCwgdGV4dElucHV0LnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICs9IDE7XG4gICAgICAgICAgICBpZih0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciA+PSA2MCl7XG4gICAgICAgICAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBmcmFtZXdvcmsgdG8gcHV0IGFsbCByZW5kZXJpbmcgaW4gb25jZSBwbGFjZSBpbiB0aGUgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyaW5nTWFuYWdlciB7XG4gICAgLyoqIFRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG5cbiAgICAvKiogVGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZCAqL1xuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZFxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBTY2VuZVxuICAgICAqL1xuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY2FudmFzIGZvciB0aGUgZ2FtZVxuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgY2FudmFzXG4gICAgICogQHJldHVybnMgVGhlIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogYW55O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXMgYW5kIHZpc2libGUgcG9ydGlvbnMgb2YgdGlsZW1hcHMsIGFzIHdlbGwgYXMgYW55IFVJRWxlbWVudCBpbiBVSUxheWVyc1xuICAgICAqIEBwYXJhbSB2aXNpYmxlU2V0IFRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2Rlc1xuICAgICAqIEBwYXJhbSB0aWxlbWFwcyBUaGUgdGlsZW1hcHMgdXNlZCBpbiB0aGUgYXBwbGljYXRpb25cbiAgICAgKiBAcGFyYW0gdWlMYXllcnMgVGhlIHVzZXIgaW50ZXJmYWNlIGxheWVyc1xuICAgICAqL1xuICAgIGFic3RyYWN0IHJlbmRlcih2aXNpYmxlU2V0OiBBcnJheTxDYW52YXNOb2RlPiwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+LCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZDtcblxuICAgIC8qKiBDbGVhcnMgdGhlIGNhbnZhcyAqL1xuICAgIGFic3RyYWN0IGNsZWFyKGNvbG9yOiBDb2xvcik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc3ByaXRlXG4gICAgICogQHBhcmFtIHNwcml0ZSBUaGUgc3ByaXRlIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBhbmltYXRlZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0gc3ByaXRlIFRoZSBhbmltYXRlZCBzcHJpdGUgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGdyYXBoaWNcbiAgICAgKiBAcGFyYW0gZ3JhcGhpYyBUaGUgZ3JhcGhpYyB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSB0aWxlbWFwXG4gICAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBVSUVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdWlFbGVtZW50IFRoZSBVSUVsZW1lbnQgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclVJRWxlbWVudCh1aUVsZW1lbnQ6IFVJRWxlbWVudCk6IHZvaWQ7XG59IiwiaW1wb3J0IEdyYXBoIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudFwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgU2hhZGVyUmVnaXN0cnkgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnlcIjtcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyXCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBSZW5kZXJpbmdVdGlscyBmcm9tIFwiLi4vVXRpbHMvUmVuZGVyaW5nVXRpbHNcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuL1JlbmRlcmluZ01hbmFnZXJcIjtcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xSZW5kZXJlciBleHRlbmRzIFJlbmRlcmluZ01hbmFnZXIge1xuXG5cdHByb3RlY3RlZCBvcmlnaW46IFZlYzI7XG5cdHByb3RlY3RlZCB6b29tOiBudW1iZXI7XG5cdHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XG5cblx0cHJvdGVjdGVkIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG5cdHByb3RlY3RlZCB0ZXh0Q3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG5cblx0aW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB7XG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHR0aGlzLndvcmxkU2l6ZSA9IFZlYzIuWkVSTztcblx0XHR0aGlzLndvcmxkU2l6ZS54ID0gd2lkdGg7XG5cdFx0dGhpcy53b3JsZFNpemUueSA9IGhlaWdodDtcblxuXHRcdC8vIEdldCB0aGUgV2ViR0wgY29udGV4dFxuICAgICAgICB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcblxuXHRcdHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuXHRcdHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICAgICAgdGhpcy5nbC5ibGVuZEZ1bmModGhpcy5nbC5TUkNfQUxQSEEsIHRoaXMuZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcblxuXHRcdC8vIFRlbGwgdGhlIHJlc291cmNlIG1hbmFnZXIgd2UncmUgdXNpbmcgV2ViR0xcblx0XHRSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51c2VXZWJHTCh0cnVlLCB0aGlzLmdsKTtcblxuXHRcdC8vIFNob3cgdGhlIHRleHQgY2FudmFzIGFuZCBnZXQgaXRzIGNvbnRleHRcblx0XHRsZXQgdGV4dENhbnZhcyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRleHQtY2FudmFzXCIpO1xuXHRcdHRleHRDYW52YXMuaGlkZGVuID0gZmFsc2U7XG5cdFx0dGhpcy50ZXh0Q3R4ID0gdGV4dENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cblx0XHQvLyBTaXplIHRoZSB0ZXh0IGNhbnZhcyB0byBiZSB0aGUgc2FtZSBhcyB0aGUgZ2FtZSBjYW52YXNcblx0XHR0ZXh0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR0ZXh0Q2FudmFzLndpZHRoID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2w7XG5cdH1cblxuXHRyZW5kZXIodmlzaWJsZVNldDogQ2FudmFzTm9kZVtdLCB0aWxlbWFwczogVGlsZW1hcFtdLCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZCB7XG5cdFx0Zm9yKGxldCBub2RlIG9mIHZpc2libGVTZXQpe1xuXHRcdFx0dGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xuXHRcdH1cblxuXHRcdHVpTGF5ZXJzLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdGlmKCF1aUxheWVycy5nZXQoa2V5KS5pc0hpZGRlbigpKVxuXHRcdFx0XHR1aUxheWVycy5nZXQoa2V5KS5nZXRJdGVtcygpLmZvckVhY2gobm9kZSA9PiB0aGlzLnJlbmRlck5vZGUoPENhbnZhc05vZGU+bm9kZSkpXG5cdFx0fSk7XG5cdH1cblxuXHRjbGVhcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcblx0XHR0aGlzLmdsLmNsZWFyQ29sb3IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYSk7XG5cdFx0dGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCB0aGlzLmdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXG5cdFx0dGhpcy50ZXh0Q3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcblx0XHQvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24obm9kZSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB6b29tIGxldmVsIG9mIHRoZSBzY2VuZVxuICAgICAgICB0aGlzLnpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuXHRcdFxuXHRcdGlmKG5vZGUuaGFzQ3VzdG9tU2hhZGVyKXtcblx0XHRcdC8vIElmIHRoZSBub2RlIGhhcyBhIGN1c3RvbSBzaGFkZXIsIHJlbmRlciB1c2luZyB0aGF0XG5cdFx0XHR0aGlzLnJlbmRlckN1c3RvbShub2RlKTtcblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIEdyYXBoaWMpe1xuXHRcdFx0dGhpcy5yZW5kZXJHcmFwaGljKG5vZGUpO1xuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcblx0XHRcdGlmKG5vZGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XG5cdFx0XHRcdHRoaXMucmVuZGVyQW5pbWF0ZWRTcHJpdGUobm9kZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJlbmRlclNwcml0ZShub2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFVJRWxlbWVudCl7XG5cdFx0XHR0aGlzLnJlbmRlclVJRWxlbWVudChub2RlKTtcblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZCB7XG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSKTtcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhzcHJpdGUpLCBzcHJpdGUpO1xuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQge1xuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUik7XG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoc3ByaXRlKSwgc3ByaXRlKTtcblx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQge1xuXG5cdFx0aWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFBvaW50KXtcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuUE9JTlRfU0hBREVSKTtcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBSZWN0KSB7XG5cdFx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlJFQ1RfU0hBREVSKTtcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cdFx0fSBcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkIHtcblx0XHRpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBMYWJlbCl7XG5cdFx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LkxBQkVMX1NIQURFUik7XG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyh1aUVsZW1lbnQpLCB1aUVsZW1lbnQpO1xuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblxuXHRcdFx0dGhpcy50ZXh0Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAodWlFbGVtZW50LnBvc2l0aW9uLnggLSB0aGlzLm9yaWdpbi54KSp0aGlzLnpvb20sICh1aUVsZW1lbnQucG9zaXRpb24ueSAtIHRoaXMub3JpZ2luLnkpKnRoaXMuem9vbSk7XG5cdFx0XHR0aGlzLnRleHRDdHgucm90YXRlKC11aUVsZW1lbnQucm90YXRpb24pO1xuXHRcdFx0bGV0IGdsb2JhbEFscGhhID0gdGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhO1xuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gdWlFbGVtZW50LmFscGhhO1xuXG5cdFx0XHQvLyBSZW5kZXIgdGV4dFxuXHRcdFx0dGhpcy50ZXh0Q3R4LmZvbnQgPSB1aUVsZW1lbnQuZ2V0Rm9udFN0cmluZygpO1xuXHRcdFx0bGV0IG9mZnNldCA9IHVpRWxlbWVudC5jYWxjdWxhdGVUZXh0T2Zmc2V0KHRoaXMudGV4dEN0eCk7XG5cdFx0XHR0aGlzLnRleHRDdHguZmlsbFN0eWxlID0gdWlFbGVtZW50LmNhbGN1bGF0ZVRleHRDb2xvcigpO1xuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gdWlFbGVtZW50LnRleHRDb2xvci5hO1xuXHRcdFx0dGhpcy50ZXh0Q3R4LmZpbGxUZXh0KHVpRWxlbWVudC50ZXh0LCBvZmZzZXQueCAtIHVpRWxlbWVudC5zaXplLngvMiwgb2Zmc2V0LnkgLSB1aUVsZW1lbnQuc2l6ZS55LzIpO1xuXG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICAgICAgXHR0aGlzLnRleHRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJDdXN0b20obm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQobm9kZS5jdXN0b21TaGFkZXJLZXkpO1xuXHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKG5vZGUpLCBub2RlKTtcblx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXHR9XG5cblx0cHJvdGVjdGVkIGFkZE9wdGlvbnMob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Piwgbm9kZTogQ2FudmFzTm9kZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdC8vIEdpdmUgdGhlIHNoYWRlciBhY2Nlc3MgdG8gdGhlIHdvcmxkIHNpemVcblx0XHRvcHRpb25zLndvcmxkU2l6ZSA9IHRoaXMud29ybGRTaXplO1xuXG5cdFx0Ly8gQWRqdXN0IHRoZSBvcmlnaW4gcG9zaXRpb24gdG8gdGhlIHBhcmFsbGF4XG5cdFx0bGV0IGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xuXHRcdGxldCBwYXJhbGxheCA9IG5ldyBWZWMyKDEsIDEpO1xuXHRcdGlmKGxheWVyIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllcil7XG5cdFx0XHRwYXJhbGxheCA9ICg8UGFyYWxsYXhMYXllcj5sYXllcikucGFyYWxsYXg7XG5cdFx0fVxuXG5cdFx0b3B0aW9ucy5vcmlnaW4gPSB0aGlzLm9yaWdpbi5jbG9uZSgpLm11bHQocGFyYWxsYXgpO1xuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cblxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5cbi8qKlxuICogQSB3cmFwcGVyIGNsYXNzIGZvciBXZWJHTCBzaGFkZXJzLlxuICogVGhpcyBjbGFzcyBpcyBhIHNpbmdsZXRvbiwgYW5kIHRoZXJlIGlzIG9ubHkgb25lIGZvciBlYWNoIHNoYWRlciB0eXBlLlxuICogQWxsIG9iamVjdHMgdGhhdCB1c2UgdGhpcyBzaGFkZXIgdHlwZSB3aWxsIHJlZmVyIHRvIGFuZCBtb2RpZnkgdGhpcyBzYW1lIHR5cGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNoYWRlclR5cGUge1xuXHQvKiogVGhlIG5hbWUgb2YgdGhpcyBzaGFkZXIgKi9cblx0cHJvdGVjdGVkIG5hbWU6IHN0cmluZztcblxuXHQvKiogVGhlIGtleSB0byB0aGUgV2ViR0xQcm9ncmFtIGluIHRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cblx0cHJvdGVjdGVkIHByb2dyYW1LZXk6IHN0cmluZztcblxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIHJlc291cmNlIG1hbmFnZXIgKi9cblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XG5cdFx0dGhpcy5wcm9ncmFtS2V5ID0gcHJvZ3JhbUtleTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIGFueSBidWZmZXIgb2JqZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzaGFkZXIgdHlwZS5cblx0ICogQHBhcmFtIGdsIFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKi9cblx0YWJzdHJhY3QgaW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBMb2FkcyBhbnkgdW5pZm9ybXNcblx0ICogQHBhcmFtIGdsIFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuXHQgKiBAcGFyYW0gb3B0aW9ucyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmdcblx0ICovXG5cdGFic3RyYWN0IHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcblxuXHQvKipcblx0ICogRXh0cmFjdHMgdGhlIG9wdGlvbnMgZnJvbSB0aGUgQ2FudmFzTm9kZSBhbmQgZ2l2ZXMgdGhlbSB0byB0aGUgcmVuZGVyIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGdldCBvcHRpb25zIGZyb21cblx0ICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSByZW5kZXIgZnVuY3Rpb25cblx0ICovXG5cdGdldE9wdGlvbnMobm9kZTogQ2FudmFzTm9kZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge3JldHVybiB7fTt9XG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcblxuLyoqICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbFNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwibGFiZWxcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci50b1dlYkdMKCk7XG5cdFx0Y29uc3QgYm9yZGVyQ29sb3IgPSBvcHRpb25zLmJvcmRlckNvbG9yLnRvV2ViR0woKTtcblxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdC8vIEF0dHJpYnV0ZXNcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XG5cblx0XHQvLyBVbmlmb3Jtc1xuXHRcdGNvbnN0IHVfQmFja2dyb3VuZENvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9CYWNrZ3JvdW5kQ29sb3JcIik7XG5cdFx0Z2wudW5pZm9ybTRmdih1X0JhY2tncm91bmRDb2xvciwgYmFja2dyb3VuZENvbG9yKTtcblxuICAgICAgICBjb25zdCB1X0JvcmRlckNvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJDb2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQm9yZGVyQ29sb3IsIGJvcmRlckNvbG9yKTtcblxuICAgICAgICBjb25zdCB1X01heFNpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X01heFNpemVcIik7XG4gICAgICAgIGdsLnVuaWZvcm0yZih1X01heFNpemUsIC12ZXJ0ZXhEYXRhWzBdLCB2ZXJ0ZXhEYXRhWzFdKTtcblxuXHRcdC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XG5cbiAgICAgICAgY29uc3QgdV9Cb3JkZXJXaWR0aCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQm9yZGVyV2lkdGhcIik7XG5cdFx0Z2wudW5pZm9ybTFmKHVfQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgvbWF4RGltZW5zaW9uKTtcblxuICAgICAgICBjb25zdCB1X0JvcmRlclJhZGl1cyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQm9yZGVyUmFkaXVzXCIpO1xuXHRcdGdsLnVuaWZvcm0xZih1X0JvcmRlclJhZGl1cywgb3B0aW9ucy5ib3JkZXJSYWRpdXMvbWF4RGltZW5zaW9uKTtcblxuXHRcdC8vIFRoZSBzaXplIG9mIHRoZSByZW5kZXJpbmcgc3BhY2Ugd2lsbCBiZSBhIHNxdWFyZSB3aXRoIHRoaXMgbWF4aW11bSBkaW1lbnNpb25cblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XG5cblx0XHQvLyBDZW50ZXIgb3VyIHRyYW5zbGF0aW9ucyBhcm91bmQgKDAsIDApXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xuXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xuXHRcdHRoaXMuc2NhbGUuc2NhbGUoc2l6ZSk7XG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XG5cblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih1X1RyYW5zZm9ybSwgZmFsc2UsIHRyYW5zZm9ybWF0aW9uLnRvQXJyYXkoKSk7XG5cblx0XHQvLyBEcmF3IHRoZSBxdWFkXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cblx0ICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcblx0ICovXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcblx0XHRsZXQgeCwgeTtcblxuXHRcdGlmKGggPiB3KXtcblx0XHRcdHkgPSAwLjU7XG5cdFx0XHR4ID0gdy8oMipoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IDAuNTtcblx0XHRcdHkgPSBoLygyKncpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdC14LCAgeSxcblx0XHRcdC14LCAteSxcblx0XHRcdCB4LCAgeSxcblx0XHRcdCB4LCAteVxuXHRcdF0pO1xuXHR9XG5cblx0Z2V0T3B0aW9ucyhyZWN0OiBMYWJlbCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHJlY3QucG9zaXRpb24sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHJlY3QuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCksXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogcmVjdC5jYWxjdWxhdGVCb3JkZXJDb2xvcigpLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IHJlY3QuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlY3QuYm9yZGVyUmFkaXVzLFxuXHRcdFx0c2l6ZTogcmVjdC5zaXplLFxuXHRcdFx0cm90YXRpb246IHJlY3Qucm90YXRpb25cblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxufSIsImltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBSZW5kZXJpbmdVdGlscyBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvUmVuZGVyaW5nVXRpbHNcIjtcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50U2hhZGVyVHlwZSBleHRlbmRzIFNoYWRlclR5cGUge1xuXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicG9pbnRcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRsZXQgcG9zaXRpb24gPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29vcmRzKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMub3JpZ2luLCBvcHRpb25zLndvcmxkU2l6ZSk7XG5cdFx0bGV0IGNvbG9yID0gUmVuZGVyaW5nVXRpbHMudG9XZWJHTENvbG9yKG9wdGlvbnMuY29sb3IpO1xuXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcblxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSBwb3NpdGlvbjtcblxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHQvLyBBdHRyaWJ1dGVzXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xuXG5cdFx0Ly8gVW5pZm9ybXNcblx0XHRjb25zdCB1X0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Db2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQ29sb3IsIGNvbG9yKTtcblxuXHRcdGNvbnN0IHVfUG9pbnRTaXplID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Qb2ludFNpemVcIik7XG5cdFx0Z2wudW5pZm9ybTFmKHVfUG9pbnRTaXplLCBvcHRpb25zLnBvaW50U2l6ZSk7XG5cblx0XHRnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgMSk7XG5cdH1cblxuXHRnZXRPcHRpb25zKHBvaW50OiBQb2ludCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHBvaW50LnBvc2l0aW9uLFxuXHRcdFx0Y29sb3I6IHBvaW50LmNvbG9yLFxuXHRcdFx0cG9pbnRTaXplOiBwb2ludC5zaXplLFxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uL1NoYWRlclR5cGVcIjtcblxuLyoqIFJlcHJlc2VudHMgYW55IFdlYkdMIG9iamVjdHMgdGhhdCBoYXZlIGEgcXVhZCBtZXNoIChpLmUuIGEgcmVjdGFuZ3VsYXIgZ2FtZSBvYmplY3QgY29tcG9zZWQgb2Ygb25seSB0d28gdHJpYW5nbGVzKSAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUXVhZFNoYWRlclR5cGUgZXh0ZW5kcyBTaGFkZXJUeXBlIHtcblx0LyoqIFRoZSBrZXkgdG8gdGhlIGJ1ZmZlciBvYmplY3QgZm9yIHRoaXMgc2hhZGVyICovXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcblxuXHQvKiogVGhlIHNjYWxlIG1hdHJpYyAqL1xuXHRwcm90ZWN0ZWQgc2NhbGU6IE1hdDR4NDtcblxuXHQvKiogVGhlIHJvdGF0aW9uIG1hdHJpeCAqL1xuXHRwcm90ZWN0ZWQgcm90YXRpb246IE1hdDR4NDtcblxuXHQvKiogVGhlIHRyYW5zbGF0aW9uIG1hdHJpeCAqL1xuXHRwcm90ZWN0ZWQgdHJhbnNsYXRpb246IE1hdDR4NDtcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXG5cdFx0dGhpcy5zY2FsZSA9IE1hdDR4NC5JREVOVElUWTtcblx0XHR0aGlzLnJvdGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xuXHRcdHRoaXMudHJhbnNsYXRpb24gPSBNYXQ0eDQuSURFTlRJVFk7XG5cdH1cbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcblxuLyoqICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0U2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJyZWN0XCI7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblx0fVxuXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0Y29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yLnRvV2ViR0woKTtcblxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdC8vIEF0dHJpYnV0ZXNcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XG5cblx0XHQvLyBVbmlmb3Jtc1xuXHRcdGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xuXHRcdGdsLnVuaWZvcm00ZnYodV9Db2xvciwgY29sb3IpO1xuXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdC8vIFdlIHdhbnQgYSBzcXVhcmUgZm9yIG91ciByZW5kZXJpbmcgc3BhY2UsIHNvIGdldCB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2Ygb3VyIHF1YWRcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcblxuXHRcdC8vIFRoZSBzaXplIG9mIHRoZSByZW5kZXJpbmcgc3BhY2Ugd2lsbCBiZSBhIHNxdWFyZSB3aXRoIHRoaXMgbWF4aW11bSBkaW1lbnNpb25cblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XG5cblx0XHQvLyBDZW50ZXIgb3VyIHRyYW5zbGF0aW9ucyBhcm91bmQgKDAsIDApXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xuXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xuXHRcdHRoaXMuc2NhbGUuc2NhbGUoc2l6ZSk7XG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XG5cblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih1X1RyYW5zZm9ybSwgZmFsc2UsIHRyYW5zZm9ybWF0aW9uLnRvQXJyYXkoKSk7XG5cblx0XHQvLyBEcmF3IHRoZSBxdWFkXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdH1cblxuXG5cdC8qXG5cdFx0U28gYXMgaXQgdHVybnMgb3V0LCBXZWJHTCBoYXMgYW4gaXNzdWUgd2l0aCBub24tc3F1YXJlIHF1YWRzLlxuXHRcdEl0IGRvZXNuJ3QgbGlrZSB3aGVuIHlvdSBkb24ndCBoYXZlIGEgMS0xIHNjYWxlLCBhbmQgcm90YXRpb25zIGFyZSBlbnRpcmVseSBtZXNzZWQgdXAgaWYgdGhpcyBpcyBub3QgdGhlIGNhc2UuXG5cdFx0VG8gc29sdmUgdGhpcywgSSB1c2VkIHRoZSBzY2FsZSBvZiB0aGUgTEFSR0VTVCBkaW1lbnNpb24gb2YgdGhlIHF1YWQgdG8gbWFrZSBhIHNxdWFyZSwgdGhlbiBhZGp1c3RlZCB0aGUgdmVydGV4IGNvb3JkaW5hdGVzIGluc2lkZSBvZiB0aGF0LlxuXHRcdEEgZGlhZ3JhbSBvZiB0aGUgc29sdXRpb24gZm9sbG93cy5cblxuXHRcdFRoZXJlIGlzIGEgYm91bmRpbmcgc3F1YXJlIGZvciB0aGUgcXVhZCB3aXRoIGRpbWVuc2lvbnMgaHhoIChpbiB0aGlzIGNhc2UsIHNpbmNlIGhlaWdodCBpcyB0aGUgbGFyZ2VzdCBkaW1lbnNpb24pLlxuXHRcdFRoZSBvZmZzZXQgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbiBpcyB0aGVyZWZvcmUgMC41LCBhcyBpdCBpcyBub3JtYWxseS5cblx0XHRIb3dldmVyLCB0aGUgb2Zmc2V0IGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbiBpcyBub3Qgc28gc3RyYWlnaHRmb3J3YXJkLCBidXQgaXNuJ3QgY29uY2VwdHVhbGx5IGhhcmQuXG5cdFx0QWxsIHdlIHJlYWxseSBoYXZlIHRvIGRvIGlzIGEgcmFuZ2UgY2hhbmdlIGZyb20gWzAsIGhlaWdodC8yXSB0byBbMCwgMC41XSwgd2hlcmUgb3VyIHZhbHVlIGlzIHQgPSB3aWR0aC8yLCBhbmQgMCA8PSB0IDw9IGhlaWdodC8yLlxuXG5cdFx0U28gbm93IHdlIGhhdmUgb3VyIHJlY3QsIGluIGEgc3BhY2Ugc2NhbGVkIHdpdGggcmVzcGVjdCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb24uXG5cdFx0Um90YXRpb25zIHdvcmsgYXMgeW91IHdvdWxkIGV4cGVjdCwgZXZlbiBmb3IgbG9uZyByZWN0YW5nbGVzLlxuXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRfXyBfXyBfXyBfXyBfXyBfXyBfX1xuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxuXHRcdC0wLjV8XyBffDg4ODg4ODg4ODg4fF8gX3wwLjVcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0ICBcdFx0fF9fX3w4ODg4ODg4ODg4OHxfX198XG5cdFx0XHQgIFx0XHQtMC41XG5cblx0XHRUaGUgZ2V0VmVydGljZXMgZnVuY3Rpb24gYmVsb3cgZG9lcyBhcyBkZXNjcmliZWQsIGFuZCBjb252ZXJ0cyB0aGUgcmFuZ2Vcblx0Ki9cblx0LyoqXG5cdCAqIFRoZSByZW5kZXJpbmcgc3BhY2UgYWx3YXlzIGhhcyB0byBiZSBhIHNxdWFyZSwgc28gbWFrZSBzdXJlIGl0cyBzcXVhcmUgdy5yLnQgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIHZlcnRpY2VzIG9mIHRoZSBxdWFkXG5cdCAqL1xuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG5cdFx0bGV0IHgsIHk7XG5cblx0XHRpZihoID4gdyl7XG5cdFx0XHR5ID0gMC41O1xuXHRcdFx0eCA9IHcvKDIqaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAwLjU7XG5cdFx0XHR5ID0gaC8oMip3KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHQteCwgIHksXG5cdFx0XHQteCwgLXksXG5cdFx0XHQgeCwgIHksXG5cdFx0XHQgeCwgLXlcblx0XHRdKTtcblx0fVxuXG5cdGdldE9wdGlvbnMocmVjdDogUmVjdCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHJlY3QucG9zaXRpb24sXG5cdFx0XHRjb2xvcjogcmVjdC5jb2xvcixcblx0XHRcdHNpemU6IHJlY3Quc2l6ZSxcblx0XHRcdHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xuXG4vKiogQSBzaGFkZXIgZm9yIHNwcml0ZXMgYW5kIGFuaW1hdGVkIHNwcml0ZXMgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcml0ZVNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblx0fVxuXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInNwcml0ZVwiO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cdH1cblxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0VGV4dHVyZShvcHRpb25zLmltYWdlS2V5KTtcblxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnksIG9wdGlvbnMuc2NhbGUpO1xuXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdC8vIEF0dHJpYnV0ZXNcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogRlNJWkUsIDAgKiBGU0laRSk7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XG5cblx0XHRjb25zdCBhX1RleENvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1RleENvb3JkXCIpO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9UZXhDb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogRlNJWkUsIDIqRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfVGV4Q29vcmQpO1xuXG5cdFx0Ly8gVW5pZm9ybXNcblx0XHQvLyBHZXQgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxuXHRcdGxldCBtYXhEaW1lbnNpb24gPSBNYXRoLm1heChvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxuXHRcdGxldCBzaXplID0gbmV3IFZlYzIobWF4RGltZW5zaW9uLCBtYXhEaW1lbnNpb24pLnNjYWxlKDIvb3B0aW9ucy53b3JsZFNpemUueCwgMi9vcHRpb25zLndvcmxkU2l6ZS55KTtcblxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcblx0XHRjb25zdCB0cmFuc2xhdGVYID0gKG9wdGlvbnMucG9zaXRpb24ueCAtIG9wdGlvbnMub3JpZ2luLnggLSBvcHRpb25zLndvcmxkU2l6ZS54LzIpL21heERpbWVuc2lvbjtcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XG5cblx0XHQvLyBDcmVhdGUgb3VyIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcblx0XHR0aGlzLnJvdGF0aW9uLnJvdGF0ZShvcHRpb25zLnJvdGF0aW9uKTtcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcblxuXHRcdC8vIFBhc3MgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCB0byBvdXIgc2hhZGVyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcblxuXHRcdC8vIFNldCB1cCBvdXIgc2FtcGxlciB3aXRoIG91ciBhc3NpZ25lZCB0ZXh0dXJlIHVuaXRcblx0XHRjb25zdCB1X1NhbXBsZXIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1NhbXBsZXJcIik7XG5cdFx0Z2wudW5pZm9ybTFpKHVfU2FtcGxlciwgdGV4dHVyZSk7XG5cblx0XHQvLyBQYXNzIGluIHRleFNoaWZ0XG5cdFx0Y29uc3QgdV90ZXhTaGlmdCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4U2hpZnRcIik7XG5cdFx0Z2wudW5pZm9ybTJmdih1X3RleFNoaWZ0LCBvcHRpb25zLnRleFNoaWZ0KTtcblxuXHRcdC8vIFBhc3MgaW4gdGV4U2NhbGVcblx0XHRjb25zdCB1X3RleFNjYWxlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXhTY2FsZVwiKTtcblx0XHRnbC51bmlmb3JtMmZ2KHVfdGV4U2NhbGUsIG9wdGlvbnMudGV4U2NhbGUpO1xuXG5cdFx0Ly8gRHJhdyB0aGUgcXVhZFxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSByZW5kZXJpbmcgc3BhY2UgYWx3YXlzIGhhcyB0byBiZSBhIHNxdWFyZSwgc28gbWFrZSBzdXJlIGl0cyBzcXVhcmUgdy5yLnQgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIHZlcnRpY2VzIG9mIHRoZSBxdWFkXG5cdCAqL1xuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlciwgc2NhbGU6IEZsb2F0MzJBcnJheSk6IEZsb2F0MzJBcnJheSB7XG5cdFx0bGV0IHgsIHk7XG5cblx0XHRpZihoID4gdyl7XG5cdFx0XHR5ID0gMC41O1xuXHRcdFx0eCA9IHcvKDIqaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAwLjU7XG5cdFx0XHR5ID0gaC8oMip3KTtcblx0XHR9XG5cblx0XHQvLyBTY2FsZSB0aGUgcmVuZGVyaW5nIHNwYWNlIGlmIG5lZWRlZFxuXHRcdHggKj0gc2NhbGVbMF07XG5cdFx0eSAqPSBzY2FsZVsxXTtcblxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdC14LCAgeSwgMC4wLCAwLjAsXG5cdFx0XHQteCwgLXksIDAuMCwgMS4wLFxuXHRcdFx0IHgsICB5LCAxLjAsIDAuMCxcblx0XHRcdCB4LCAteSwgMS4wLCAxLjBcblx0XHRdKTtcblx0fVxuXG5cdGdldE9wdGlvbnMoc3ByaXRlOiBTcHJpdGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHRsZXQgdGV4U2hpZnQ7XG5cdFx0bGV0IHRleFNjYWxlO1xuXG5cdFx0aWYoc3ByaXRlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xuXHRcdFx0bGV0IGFuaW1hdGlvbkluZGV4ID0gc3ByaXRlLmFuaW1hdGlvbi5nZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTtcblx0XHRcdGxldCBvZmZzZXQgPSBzcHJpdGUuZ2V0QW5pbWF0aW9uT2Zmc2V0KGFuaW1hdGlvbkluZGV4KTtcblx0XHRcdHRleFNoaWZ0ID0gbmV3IEZsb2F0MzJBcnJheShbb2Zmc2V0LnggLyAoc3ByaXRlLmNvbHMgKiBzcHJpdGUuc2l6ZS54KSwgb2Zmc2V0LnkgLyAoc3ByaXRlLnJvd3MgKiBzcHJpdGUuc2l6ZS55KV0pO1xuXHRcdFx0dGV4U2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFsxLyhzcHJpdGUuY29scyksIDEvKHNwcml0ZS5yb3dzKV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXhTaGlmdCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKTtcblx0XHRcdHRleFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMV0pO1xuXHRcdH1cblxuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xuXHRcdFx0cG9zaXRpb246IHNwcml0ZS5wb3NpdGlvbixcblx0XHRcdHJvdGF0aW9uOiBzcHJpdGUucm90YXRpb24sXG5cdFx0XHRzaXplOiBzcHJpdGUuc2l6ZSxcblx0XHRcdHNjYWxlOiBzcHJpdGUuc2NhbGUudG9BcnJheSgpLFxuXHRcdFx0aW1hZ2VLZXk6IHNwcml0ZS5pbWFnZUlkLFxuXHRcdFx0dGV4U2hpZnQsXG5cdFx0XHR0ZXhTY2FsZVxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvUXVldWVcIjtcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xuaW1wb3J0IFN0cmluZ1V0aWxzIGZyb20gXCIuLi9VdGlscy9TdHJpbmdVdGlsc1wiO1xuaW1wb3J0IEF1ZGlvTWFuYWdlciBmcm9tIFwiLi4vU291bmQvQXVkaW9NYW5hZ2VyXCI7XG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xuaW1wb3J0IFdlYkdMUHJvZ3JhbVR5cGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9SZW5kZXJpbmcvV2ViR0xQcm9ncmFtVHlwZVwiO1xuXG4vKipcbiAqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIGZvciB0aGUgZ2FtZSBlbmdpbmUuXG4gKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBpbnRlcmZhY2VzIHdpdGggdGhlIGxvYWRhYmxlIGFzc2V0cyBvZiBhIGdhbWUgc3VjaCBhcyBpbWFnZXMsIGRhdGEgZmlsZXMsXG4gKiBhbmQgc291bmRzLCB3aGljaCBhcmUgYWxsIGZvdW5kIGluIHRoZSBkaXN0IGZvbGRlci5cbiAqIFRoaXMgY2xhc3MgY29udHJvbHMgbG9hZGluZyBhbmQgdXBkYXRlcyB0aGUgQHJlZmVyZW5jZVtTY2VuZV0gd2l0aCB0aGUgbG9hZGluZyBwcm9ncmVzcywgc28gdGhhdCB0aGUgc2NlbmUgZG9lcyBcbiAqIG5vdCBzdGFydCBiZWZvcmUgYWxsIG5lY2Vzc2FyeSBhc3NldHMgYXJlIGxvYWRlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzb3VyY2VNYW5hZ2VyIHtcbiAgICAvLyBJbnN0YW5jZSBmb3IgdGhlIHNpbmdsZXRvbiBjbGFzc1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgXG4gICAgLy8gQm9vbGVhbnMgdG8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgUmVzb3VyY2VNYW5hZ2VyIGlzIGN1cnJlbnRseSBsb2FkaW5nIHNvbWV0aGluZ1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCBhbnkgcmVzb3VyY2VzIGFyZSBsb2FkaW5nICovXG4gICAgcHJpdmF0ZSBsb2FkaW5nOiBib29sZWFuO1xuICAgIC8qKiBBIGJvb2xlYW4gdG8gaW5kaWNhdGUgdGhhdCB0aGUgYXNzZXRzIGp1c3QgZmluaXNoZWQgbG9hZGluZyAqL1xuICAgIHByaXZhdGUganVzdExvYWRlZDogYm9vbGVhbjtcblxuICAgIC8vIEZ1bmN0aW9ucyB0byBkbyBzb21ldGhpbmcgd2hlbiBsb2FkaW5nIHByb2dyZXNzZXMgb3IgaXMgY29tcGxldGVkIHN1Y2ggYXMgcmVuZGVyIGEgbG9hZGluZyBzY3JlZW5cbiAgICAvKiogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGxvYWRpbmcgcHJvZ3Jlc3NlcyAqL1xuICAgIHB1YmxpYyBvbkxvYWRQcm9ncmVzczogRnVuY3Rpb247XG4gICAgLyoqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBsb2FkaW5nIGNvbXBsZXRlcyAqL1xuICAgIHB1YmxpYyBvbkxvYWRDb21wbGV0ZTogRnVuY3Rpb247XG5cblxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBpbWFnZXMgbmVlZCB0byBiZSBsb2FkZWQqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfaW1hZ2VzTG9hZGVkOiBudW1iZXI7XG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGltYWdlcyBhcmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZXNUb0xvYWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIGltYWdlcyB3ZSBtdXN0IGxvYWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgLyoqIEEgbWFwIG9mIHRoZSBpbWFnZXMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUuIFRoZSByZWZlcmVuY2UgdG8gdGhlc2UgaW1hZ2VzIG9ubHkgZXhpc3QgaGVyZSBmb3IgZWFzeSBjbGVhbnVwLiAqL1xuICAgIHByaXZhdGUgaW1hZ2VzOiBNYXA8SFRNTEltYWdlRWxlbWVudD47XG5cbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZDogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHRpbGVtYXBzIHdlIG11c3QgbG9hZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcbiAgICAvKiogQSBtYXAgb2YgdGhlIHRpbGVtYXBzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xuICAgIHByaXZhdGUgc3ByaXRlc2hlZXRzOiBNYXA8U3ByaXRlc2hlZXQ+O1xuXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIG5lZWQgdG8gYmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwc0xvYWRlZDogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwc1RvTG9hZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgcXVldWUgb2YgdGlsZW1hcHMgd2UgbXVzdCBsb2FkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgLyoqIEEgbWFwIG9mIHRoZSB0aWxlbWFwcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cbiAgICBwcml2YXRlIHRpbGVtYXBzOiBNYXA8VGlsZWRUaWxlbWFwRGF0YT47XG5cbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgc291bmRzIG5lZWQgdG8gYmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb0xvYWRlZDogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VuZHMgYXJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Ub0xvYWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHNvdW5kcyB3ZSBtdXN0IGxvYWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgLyoqIEEgbWFwIG9mIHRoZSBzb3VuZHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXG4gICAgcHJpdmF0ZSBhdWRpb0J1ZmZlcnM6IE1hcDxBdWRpb0J1ZmZlcj47XG5cbiAgICAvKiogVGhlIHRvdGFsIG51bWJlciBvZiBcInR5cGVzXCIgb2YgdGhpbmdzIHRoYXQgbmVlZCB0byBiZSBsb2FkZWQgKGkuZS4gaW1hZ2VzIGFuZCB0aWxlbWFwcykgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3R5cGVzVG9Mb2FkOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkZWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Ub0xvYWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcbiAgICBwcml2YXRlIGpzb25PYmplY3RzOiBNYXA8UmVjb3JkPHN0cmluZywgYW55Pj47XG5cbiAgICAvKiAjIyMjIyMjIyMjIElORk9STUFUSU9OIFNQRUNJQUwgVE8gV0VCR0wgIyMjIyMjIyMjIyAqL1xuICAgIHByaXZhdGUgZ2xfV2ViR0xBY3RpdmU6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZDogbnVtYmVyO1xuICAgIHByaXZhdGUgbG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoX1NoYWRlcj47XG5cbiAgICBwcml2YXRlIGdsX1NoYWRlclByb2dyYW1zOiBNYXA8V2ViR0xQcm9ncmFtVHlwZT47XG5cbiAgICBwcml2YXRlIGdsX1RleHR1cmVzOiBNYXA8bnVtYmVyPjtcbiAgICBwcml2YXRlIGdsX05leHRUZXh0dXJlSUQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGdsX0J1ZmZlcnM6IE1hcDxXZWJHTEJ1ZmZlcj47IFxuXG4gICAgcHJpdmF0ZSBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuXG4gICAgLyogIyMjIyMjIyMjIyBVTkxPQURJTkcgQU5EIEVYQ0xVU0lPTiBMSVNUICMjIyMjIyMjIyMgKi9cbiAgICAvKiogQSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IHdpbGwgYmUgdW5sb2FkZWQgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzY2VuZSAqL1xuICAgIHByaXZhdGUgcmVzb3VyY2VzVG9VbmxvYWQ6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcblxuICAgIC8qKiBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGtlZXAgdW50aWwgZnVydGhlciBub3RpY2UgKi9cbiAgICBwcml2YXRlIHJlc291cmNlc1RvS2VlcDogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuanNvbk9iamVjdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuXG4gICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5nbF9UZXh0dXJlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5nbF9OZXh0VGV4dHVyZUlEID0gMDtcbiAgICAgICAgdGhpcy5nbF9CdWZmZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNUb0tlZXAgPSBuZXcgQXJyYXkoKTtcbiAgICB9O1xuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBTSU5HTEVUT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgZXhpc3RcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBSZXNvdXJjZU1hbmFnZXIge1xuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFJlc291cmNlTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBQVUJMSUMgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIG9yIGRlYWN0aXZhdGVzIHRoZSB1c2Ugb2YgV2ViR0xcbiAgICAgKiBAcGFyYW0gZmxhZyBUcnVlIGlmIFdlYkdMIHNob3VsZCBiZSB1c2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGluc3RhbmNlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LCBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgcHVibGljIHVzZVdlYkdMKGZsYWc6IGJvb2xlYW4sIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nbF9XZWJHTEFjdGl2ZSA9IGZsYWc7XG5cbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBpbWFnZSBmcm9tIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHRoZSBsb2FkZWQgaW1hZ2Ugd2l0aFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBpbWFnZSB0byBsb2FkXG4gICAgICovXG4gICAgcHVibGljIGltYWdlKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBwdWJsaWMga2VlcEltYWdlKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBpbWFnZVxuICAgICAqIEByZXR1cm5zIFRoZSBpbWFnZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRJbWFnZShrZXk6IHN0cmluZyk6IEhUTUxJbWFnZUVsZW1lbnQge1xuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmltYWdlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYoaW1hZ2UgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aHJvdyBgVGhlcmUgaXMgbm8gaW1hZ2UgYXNzb2NpYXRlZCB3aXRoIGtleSBcIiR7a2V5fVwiYFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHNwcml0ZXNoZWV0IGZyb20gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgdGhlIGxvYWRlZCBzcHJpdGVzaGVldCB3aXRoXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgc3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBrZWVwU3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBzcHJpdGVzaGVldFxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxuICAgICAqIEByZXR1cm5zIFRoZSBsb2FkZWQgU3ByaXRlc2hlZXRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0U3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcpOiBTcHJpdGVzaGVldCB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNoZWV0cy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBhdWRpbyBmaWxlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgYXVkaW8oa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgICBwdWJsaWMga2VlcEF1ZGlvKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvQnVmZmVyIGNyZWF0ZWQgZnJvbSB0aGUgbG9hZGVkIGF1ZGlvIGZsZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBdWRpbyhrZXk6IHN0cmluZyk6IEF1ZGlvQnVmZmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9CdWZmZXJzLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgYSB0aWxlbWFwIGZyb20gYSBqc29uIGZpbGUuIEF1dG9tYXRpY2FsbHkgbG9hZHMgcmVsYXRlZCBpbWFnZXNcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGxvYWRlZCB0aWxlbWFwXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgdG8gbG9hZFxuICAgICAqL1xuICAgIHB1YmxpYyB0aWxlbWFwKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgICBwdWJsaWMga2VlcFRpbGVtYXAoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuVElMRU1BUCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIGEgbG9hZGVkIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwXG4gICAgICogQHJldHVybnMgVGhlIHRpbGVtYXAgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUaWxlbWFwKGtleTogc3RyaW5nKTogVGlsZWRUaWxlbWFwRGF0YSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVtYXBzLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFuIG9iamVjdCBmcm9tIGEganNvbiBmaWxlLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIG9iamVjdFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBqc29uIGZpbGUgdG8gbG9hZFxuICAgICAqL1xuICAgIHB1YmxpYyBvYmplY3Qoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyl7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICAgcHVibGljIGtlZXBPYmplY3Qoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSlNPTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIGEgbG9hZGVkIG9iamVjdFxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIG9iamVjdFxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRPYmplY3Qoa2V5OiBzdHJpbmcpe1xuICAgICAgICByZXR1cm4gdGhpcy5qc29uT2JqZWN0cy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIExPQUQgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIHJlc291cmNlcyBjdXJyZW50bHkgaW4gdGhlIHF1ZXVlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWwgd2hlbiB0aGUgcmVzb3VyY2VzIGFyZSBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICovXG4gICAgbG9hZFJlc291cmNlc0Zyb21RdWV1ZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90eXBlc1RvTG9hZCA9IDU7XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBMb2FkIGV2ZXJ5dGhpbmcgaW4gdGhlIHF1ZXVlcy4gVGlsZW1hcHMgaGF2ZSB0byBjb21lIGJlZm9yZSBpbWFnZXMgYmVjYXVzZSB0aGV5IHdpbGwgYWRkIG5ldyBpbWFnZXMgdG8gdGhlIHF1ZXVlXG4gICAgICAgIHRoaXMubG9hZFRpbGVtYXBzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIFRpbGVtYXBzXCIpO1xuICAgICAgICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBTcHJpdGVzaGVldHNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2VzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgSW1hZ2VzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRBdWRpb0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBBdWRpb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdHNGcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIE9iamVjdHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xfTG9hZFNoYWRlcnNGcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgU2hhZGVyc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZyhjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZyhjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICAvLyBEb25lIGxvYWRpbmdcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBVTkxPQUQgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXG4gICAgXG4gICAgcHJpdmF0ZSBrZWVwUmVzb3VyY2Uoa2V5OiBzdHJpbmcsIHR5cGU6IFJlc291cmNlVHlwZSk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLmxvZyhcIktlZXAgcmVzb3VyY2UuLi5cIik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnJlc291cmNlc1RvVW5sb2FkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2VzVG9VbmxvYWRbaV07XG4gICAgICAgICAgICBpZihyZXNvdXJjZS5rZXkgPT09IGtleSAmJiByZXNvdXJjZS5yZXNvdXJjZVR5cGUgPT09IHR5cGUpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgcmVzb3VyY2UgXCIgKyBrZXkgKyBcIiBvZiB0eXBlIFwiICsgdHlwZSArIFwiLiBLZWVwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzb3VyY2VUb01vdmUgPSB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvS2VlcC5wdXNoKC4uLnJlc291cmNlVG9Nb3ZlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyByZWZlcmVuY2VzIHRvIGFsbCByZXNvdXJjZXMgaW4gdGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgKi9cbiAgICB1bmxvYWRBbGxSZXNvdXJjZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IobGV0IHJlc291cmNlIG9mIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQpe1xuICAgICAgICAgICAgLy8gVW5sb2FkIHRoZSByZXNvdXJjZVxuICAgICAgICAgICAgdGhpcy51bmxvYWRSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVubG9hZFJlc291cmNlKHJlc291cmNlOiBSZXNvdXJjZVJlZmVyZW5jZSk6IHZvaWQge1xuICAgICAgICAvLyBEZWxldGUgdGhlIHJlc291cmNlIGl0c2VsZlxuICAgICAgICBzd2l0Y2gocmVzb3VyY2UucmVzb3VyY2VUeXBlKXtcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLklNQUdFOlxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsX1RleHR1cmVzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLlRJTEVNQVA6XG4gICAgICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUOlxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc2hlZXRzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuQVVESU86XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5KU09OOlxuICAgICAgICAgICAgICAgIHRoaXMuanNvbk9iamVjdHMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKmNhc2UgUmVzb3VyY2VUeXBlLlNIQURFUjpcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmdldChyZXNvdXJjZS5rZXkpLmRlbGV0ZSh0aGlzLmdsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrOyovXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWxldGUgYW55IGRlcGVuZGVuY2llc1xuICAgICAgICBmb3IobGV0IGRlcGVuZGVuY3kgb2YgcmVzb3VyY2UuZGVwZW5kZW5jaWVzKXtcbiAgICAgICAgICAgIHRoaXMudW5sb2FkUmVzb3VyY2UoZGVwZW5kZW5jeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFdPUksgRlVOQ1RJT05TICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCB0aWxlbWFwcyBjdXJyZW50bHkgaW4gdGhlIHRpbGVtYXAgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBsb2FkaW5nIGlzIGNvbXBsZXRlXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkVGlsZW1hcHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9PT0gMCl7XG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCB0aWxlbWFwID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZFRpbGVtYXAodGlsZW1hcC5rZXksIHRpbGVtYXAucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgdGlsZW1hcCBcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gcGF0aFRvVGlsZW1hcEpTT04gVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgSlNPTiBmaWxlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkVGlsZW1hcChrZXk6IHN0cmluZywgcGF0aFRvVGlsZW1hcEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGhUb1RpbGVtYXBKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgbGV0IHRpbGVtYXBPYmplY3QgPSA8VGlsZWRUaWxlbWFwRGF0YT5KU09OLnBhcnNlKGZpbGVUZXh0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2UgY2FuIHBhcnNlIHRoZSBvYmplY3QgbGF0ZXIgLSBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5hZGQoa2V5LCB0aWxlbWFwT2JqZWN0KTtcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5USUxFTUFQKTtcblxuICAgICAgICAgICAgLy8gR3JhYiB0aGUgdGlsZXNldCBpbWFnZXMgd2UgbmVlZCB0byBsb2FkIGFuZCBhZGQgdGhlbSB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXG4gICAgICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZW1hcE9iamVjdC50aWxlc2V0cyl7XG4gICAgICAgICAgICAgICAgaWYodGlsZXNldC5pbWFnZSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aWxlc2V0LmltYWdlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvVGlsZW1hcEpTT04pICsga2V5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodGlsZXNldC50aWxlcyl7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZSBvZiB0aWxlc2V0LnRpbGVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aWxlLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1RpbGVtYXBKU09OKSArIGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVzb3VyY2UgcmVmZXJlbmNlIHRvIHRoZSBsaXN0IG9mIHJlc291cmNlIHRvIHVubG9hZFxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcblxuICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhIHRpbGVtYXAuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgYmVpbmcgbG9hZGVkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nVGlsZW1hcChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHRpbGVtYXBzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIHNwcml0ZXNoZWV0cyBjdXJyZW50bHkgaW4gdGhlIHNwcml0ZXNoZWV0IGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHNwcml0ZXNoZWV0cyBhcmUgZG9uZSBsb2FkaW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkID09PSAwKXtcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXQoc3ByaXRlc2hlZXQua2V5LCBzcHJpdGVzaGVldC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciBzcHJpdGVzaGVldCBcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gcGF0aFRvU3ByaXRlc2hlZXRKU09OIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCBKU09OIGZpbGVcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBzcHJpdGVzaGVldFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZFNwcml0ZXNoZWV0KGtleTogc3RyaW5nLCBwYXRoVG9TcHJpdGVzaGVldEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGhUb1Nwcml0ZXNoZWV0SlNPTiwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IDxTcHJpdGVzaGVldD5KU09OLnBhcnNlKGZpbGVUZXh0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2UgY2FuIHBhcnNlIHRoZSBvYmplY3QgbGF0ZXIgLSBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gbG9hZGluZ1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMuYWRkKGtleSwgc3ByaXRlc2hlZXQpO1xuXG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQpO1xuXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSBpbWFnZSB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCBpdCB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXG4gICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvU3ByaXRlc2hlZXRKU09OKSArIHNwcml0ZXNoZWV0LnNwcml0ZVNoZWV0SW1hZ2U7XG4gICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleTogc3ByaXRlc2hlZXQubmFtZSwgcGF0aDogcGF0aCwgaXNEZXBlbmRlbmN5OiB0cnVlfSk7XG5cbiAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKHNwcml0ZXNoZWV0Lm5hbWUsIFJlc291cmNlVHlwZS5JTUFHRSkpO1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcblxuICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1Nwcml0ZXNoZWV0KGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYSBzcHJpdGVzaGVldC4gQ2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXQgYmVpbmcgbG9hZGVkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXQgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ1Nwcml0ZXNoZWV0KGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc3ByaXRlc2hlZXRzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIGltYWdlcyBjdXJyZW50bHkgaW4gdGhlIGltYWdlIGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgaW1hZ2VzIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRJbWFnZXNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IGltYWdlID0gdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZShpbWFnZS5rZXksIGltYWdlLnBhdGgsIGltYWdlLmlzRGVwZW5kZW5jeSwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgaW1hZ2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlXG4gICAgICovXG4gICAgcHVibGljIGxvYWRJbWFnZShrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBpc0RlcGVuZGVuY3k6IGJvb2xlYW4sIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBZGQgdG8gbG9hZGVkIGltYWdlc1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMuYWRkKGtleSwgaW1hZ2UpO1xuXG4gICAgICAgICAgICAvLyBJZiBub3QgYSBkZXBlbmRlbmN5LCBwdXNoIGl0IHRvIHRoZSB1bmxvYWQgbGlzdC4gT3RoZXJ3aXNlIGl0J3MgbWFuYWdlZCBieSBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgaWYoIWlzRGVwZW5kZW5jeSl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBXZWJHTCBpcyBhY3RpdmUsIGNyZWF0ZSBhIHRleHR1cmVcbiAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlV2ViR0xUZXh0dXJlKGtleSwgaW1hZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5pc2ggaW1hZ2UgbG9hZFxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2Uuc3JjID0gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBpbWFnZS4gSWYgdGhpcyBpcyB0aGUgbGFzdCBpbWFnZSwgaXQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdJbWFnZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgKXtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBpbWFnZXNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgYXVkaW8gY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGlsZW1hcHMgYXJlIGRvbmUgbG9hZGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZEF1ZGlvRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IGF1ZGlvID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRBdWRpbyhhdWRpby5rZXksIGF1ZGlvLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgc2luZ3VsYXIgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZEF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICBsZXQgYXVkaW9DdHggPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRBdWRpb0NvbnRleHQoKTtcblxuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsaXN0IG9mIGF1ZGlvIGJ1ZmZlcnNcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVycy5hZGQoa2V5LCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuQVVESU8pKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nIHNvdW5kXG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PntcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkVycm9yIGxvYWRpbmcgc291bmRcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIGF1ZGlvIGZpbGUuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdG9uIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gc2FtcGxlIGJlaW5nIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdBdWRpbyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIGF1ZGlvXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIG9iamVjdHMgY3VycmVudGx5IGluIHRoZSBvYmplY3QgbG9hZGluZyBxdWV1ZVxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBvYmplY3RzIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRPYmplY3RzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcblxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdChvYmoua2V5LCBvYmoucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgb2JqZWN0XG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBvYmplY3QgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxuICAgICAqL1xuICAgIHB1YmxpYyBsb2FkT2JqZWN0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UoZmlsZVRleHQpO1xuICAgICAgICAgICAgdGhpcy5qc29uT2JqZWN0cy5hZGQoa2V5LCBvYmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pKTtcblxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYW4gb2JqZWN0LiBJZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdCwgaXQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgb2JqZWN0c1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMgV0VCR0wgU1BFQ0lGSUMgRlVOQ1RJT05TICMjIyMjIyMjIyMgKi9cblxuICAgIHB1YmxpYyBnZXRUZXh0dXJlKGtleTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFNoYWRlclByb2dyYW0oa2V5OiBzdHJpbmcpOiBXZWJHTFByb2dyYW0ge1xuICAgICAgICByZXR1cm4gdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5nZXQoa2V5KS5wcm9ncmFtO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRCdWZmZXIoa2V5OiBzdHJpbmcpOiBXZWJHTEJ1ZmZlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsX0J1ZmZlcnMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVXZWJHTFRleHR1cmUoaW1hZ2VLZXk6IHN0cmluZywgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0ZXh0dXJlIElEXG4gICAgICAgIGNvbnN0IHRleHR1cmVJRCA9IHRoaXMuZ2V0VGV4dHVyZUlEKHRoaXMuZ2xfTmV4dFRleHR1cmVJRCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIHRleHR1cmVcbiAgICAgICAgLy8gRW5hYmxlIHRleHR1cmUwXG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlSUQpO1xuXG4gICAgICAgIC8vIEJpbmQgb3VyIHRleHR1cmUgdG8gdGV4dHVyZSAwXG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgcGFyYW1ldGVyc1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgdGV4dHVyZSBpbWFnZVxuICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSB0ZXh0dXJlIHRvIG91ciBtYXAgd2l0aCB0aGUgc2FtZSBrZXkgYXMgdGhlIGltYWdlXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMuYWRkKGltYWdlS2V5LCB0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCB0aGUga2V5XG4gICAgICAgIHRoaXMuZ2xfTmV4dFRleHR1cmVJRCArPSAxO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGV4dHVyZUlEKGlkOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBTdGFydCB3aXRoIDkgY2FzZXMgLSB0aGlzIGNhbiBiZSBleHBhbmRlZCBpZiBuZWVkZWQsIGJ1dCBmb3IgdGhlIGJlc3QgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIFRleHR1cmVzIHNob3VsZCBiZSBzdGl0Y2hlZCBpbnRvIGFuIGF0bGFzXG4gICAgICAgIHN3aXRjaChpZCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUwO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy5nbC5URVhUVVJFMTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTI7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUzO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFNDtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTU7XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU2O1xuICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFNztcbiAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTg7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFOTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVCdWZmZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICAgICAgdGhpcy5nbF9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyBsb2FkaW5nIG9mIGEgbmV3IHNoYWRlciBwcm9ncmFtXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzaGFkZXIgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB2U2hhZGVyRmlsZXBhdGggXG4gICAgICogQHBhcmFtIGZTaGFkZXJGaWxlcGF0aCBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2hhZGVyKGtleTogc3RyaW5nLCB2U2hhZGVyRmlsZXBhdGg6IHN0cmluZywgZlNoYWRlckZpbGVwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbGV0IHNwbGl0UGF0aCA9IHZTaGFkZXJGaWxlcGF0aC5zcGxpdChcIi5cIik7XG4gICAgICAgIGxldCBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmKGVuZCAhPT0gXCJ2c2hhZGVyXCIpe1xuICAgICAgICAgICAgdGhyb3cgYCR7dlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIudnNoYWRlcmA7XG4gICAgICAgIH1cblxuICAgICAgICBzcGxpdFBhdGggPSBmU2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xuICAgICAgICBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmKGVuZCAhPT0gXCJmc2hhZGVyXCIpe1xuICAgICAgICAgICAgdGhyb3cgYCR7ZlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIuZnNoYWRlcmA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGF0aHMgPSBuZXcgS2V5UGF0aF9TaGFkZXIoKTtcbiAgICAgICAgcGF0aHMua2V5ID0ga2V5O1xuICAgICAgICBwYXRocy52cGF0aCA9IHZTaGFkZXJGaWxlcGF0aDtcbiAgICAgICAgcGF0aHMuZnBhdGggPSBmU2hhZGVyRmlsZXBhdGg7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZW5xdWV1ZShwYXRocyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxuICAgICAqL1xuICAgICBwdWJsaWMga2VlcFNoYWRlcihrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnbF9Mb2FkU2hhZGVyc0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIHdlYkdMIGlzbidhY3RpdmUgb3IgdGhlcmUgYXJlIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKCF0aGlzLmdsX1dlYkdMQWN0aXZlIHx8IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBzaGFkZXIgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmdsX0xvYWRTaGFkZXIoc2hhZGVyLmtleSwgc2hhZGVyLnZwYXRoLCBzaGFkZXIuZnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdsX0xvYWRTaGFkZXIoa2V5OiBzdHJpbmcsIHZwYXRoOiBzdHJpbmcsIGZwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZSh2cGF0aCwgKHZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2U2hhZGVyID0gdkZpbGVUZXh0O1xuXG4gICAgICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShmcGF0aCwgKGZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZlNoYWRlciA9IGZGaWxlVGV4dFxuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgcHJvZ3JhbSBhbmQgc2hhZGVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzaGFkZXJQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSA9IHRoaXMuY3JlYXRlU2hhZGVyUHJvZ3JhbSh2U2hhZGVyLCBmU2hhZGVyKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2dyYW1XcmFwcGVyID0gbmV3IFdlYkdMUHJvZ3JhbVR5cGUoKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci5wcm9ncmFtID0gc2hhZGVyUHJvZ3JhbTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbVdyYXBwZXIuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBvdXIgbWFwXG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5hZGQoa2V5LCBwcm9ncmFtV3JhcHBlcik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNIQURFUikpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2tJZkxhc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2xfRmluaXNoTG9hZGluZ1NoYWRlcihjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCArPSAxO1xuXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHNoYWRlcnNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlclNvdXJjZTogc3RyaW5nLCBmU2hhZGVyU291cmNlOiBzdHJpbmcpe1xuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmxvYWRWZXJ0ZXhTaGFkZXIodlNoYWRlclNvdXJjZSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5sb2FkRnJhZ21lbnRTaGFkZXIoZlNoYWRlclNvdXJjZSk7XG4gICAgXG4gICAgICAgIGlmKHZlcnRleFNoYWRlciA9PT0gbnVsbCB8fCBmcmFnbWVudFNoYWRlciA9PT0gbnVsbCl7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYSBwcm9ibGVtIGludGlhbGl6aW5nIC0gZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIHNoYWRlciBwcm9ncmFtXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgaWYoIXByb2dyYW0pIHtcbiAgICAgICAgICAgIC8vIEVycm9yIGNyZWF0aW5nXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW1cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBBdHRhY2ggb3VyIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBcbiAgICAgICAgLy8gTGlua1xuICAgICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBpZighdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKXtcbiAgICAgICAgICAgIC8vIEVycm9yIGxpbmtpbmdcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBsaW5rIHByb2dyYW06IFwiICsgZXJyb3IpO1xuICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBXZSBzdWNjZXNzZnVsbHkgY3JlYXRlIGEgcHJvZ3JhbVxuICAgICAgICByZXR1cm4gW3Byb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGxvYWRWZXJ0ZXhTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZlcnRleCBzaGFkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIsIHNoYWRlclNvdXJjZSk7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgbG9hZEZyYWdtZW50U2hhZGVyKHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUiwgc2hhZGVyU291cmNlKTtcdFxuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGxvYWRTaGFkZXIodHlwZTogbnVtYmVyLCBzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xuICAgICAgICBjb25zdCBzaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICBcbiAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgY3JlYXRlIHRoZSBzaGFkZXIsIGVycm9yXG4gICAgICAgIGlmKHNoYWRlciA9PT0gbnVsbCl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gY3JlYXRlIHNoYWRlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEFkZCB0aGUgc291cmNlIHRvIHRoZSBzaGFkZXIgYW5kIGNvbXBpbGVcbiAgICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIHdlcmUgbm8gZXJyb3JzIGR1cmluZyB0aGlzIHByb2Nlc3NcbiAgICAgICAgaWYoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpe1xuICAgICAgICAgICAgLy8gTm90IGNvbXBpbGVkIC0gZXJyb3JcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6IFwiICsgZXJyb3IpO1xuICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBTdWNlc3MsIHNvIHJldHVybiB0aGUgc2hhZGVyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyBHRU5FUkFMIExPQURJTkcgRlVOQ1RJT05TICMjIyMjIyMjIyMgKi9cblxuICAgIHByaXZhdGUgbG9hZFRleHRGaWxlKHRleHRGaWxlUGF0aDogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgbGV0IHhvYmo6IFhNTEh0dHBSZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhvYmoub3ZlcnJpZGVNaW1lVHlwZShcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIHhvYmoub3BlbignR0VUJywgdGV4dEZpbGVQYXRoLCB0cnVlKTtcbiAgICAgICAgeG9iai5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKHhvYmoucmVhZHlTdGF0ZSA9PSA0KSAmJiAoeG9iai5zdGF0dXMgPT0gMjAwKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhvYmoucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeG9iai5zZW5kKG51bGwpO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMgTE9BRElORyBCQVIgSU5GTyAjIyMjIyMjIyMjICovXG5cbiAgICBwcml2YXRlIGdldExvYWRQZXJjZW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZC90aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkL3RoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkL3RoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQvdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZClcbiAgICAgICAgICAgIC8gdGhpcy5sb2Fkb25seV90eXBlc1RvTG9hZDtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy5sb2FkaW5nKXtcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkUHJvZ3Jlc3Mpe1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkUHJvZ3Jlc3ModGhpcy5nZXRMb2FkUGVyY2VudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuanVzdExvYWRlZCl7XG4gICAgICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkQ29tcGxldGUpe1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHJlZmVyZW5jZSB0byBhIHJlc291cmNlLlxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgZXhlbXB0aW9uIGxpc3QgdG8gYXNzdXJlIGFzc2V0cyBhbmQgdGhlaXIgZGVwZW5kZW5jaWVzIGRvbid0IGdldFxuICogZGVzdHJveWVkIGlmIHRoZXkgYXJlIHN0aWxsIG5lZWRlZC5cbiAqL1xuY2xhc3MgUmVzb3VyY2VSZWZlcmVuY2Uge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHJlc291cmNlVHlwZTogUmVzb3VyY2VUeXBlO1xuICAgIGRlcGVuZGVuY2llczogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xuXG4gICAgY29uc3RydWN0b3Ioa2V5OiBzdHJpbmcsIHJlc291cmNlVHlwZTogUmVzb3VyY2VUeXBlKXtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMucmVzb3VyY2VUeXBlID0gcmVzb3VyY2VUeXBlO1xuICAgICAgICB0aGlzLiBkZXBlbmRlbmNpZXMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICBhZGREZXBlbmRlbmN5KHJlc291cmNlOiBSZXNvdXJjZVJlZmVyZW5jZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHJlc291cmNlKTtcbiAgICB9XG59XG5cblxuZW51bSBSZXNvdXJjZVR5cGUge1xuICAgIElNQUdFID0gXCJJTUFHRVwiLFxuICAgIFRJTEVNQVAgPSBcIlRJTEVNQVBcIixcbiAgICBTUFJJVEVTSEVFVCA9IFwiU1BSSVRFU0hFRVRcIixcbiAgICBBVURJTyA9IFwiQVVESU9cIixcbiAgICBKU09OID0gXCJKU09OXCIsXG4gICAgU0hBREVSID0gXCJTSEFERVJcIlxufVxuXG4vKipcbiAqIEEgcGFpciByZXByZXNlbnRpbmcgYSBrZXkgYW5kIHRoZSBwYXRoIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkXG4gKi9cbmNsYXNzIEtleVBhdGhQYWlyIHtcbiAgICBrZXk6IHN0cmluZztcbiAgICBwYXRoOiBzdHJpbmc7XG4gICAgaXNEZXBlbmRlbmN5PzogYm9vbGVhbiA9IGZhbHNlO1xufVxuXG5jbGFzcyBLZXlQYXRoX1NoYWRlciB7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgdnBhdGg6IHN0cmluZztcbiAgICBmcGF0aDogc3RyaW5nO1xufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudFwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgUGFydGljbGUgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BhcnRpY2xlXCI7XG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xuaW1wb3J0IENpcmNsZUdyYXBoIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9DaXJjbGVcIjtcbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogQSBmYWN0b3J5IHRoYXQgYWJzdHJhY3RzIGFkZGluZyBAcmVmZXJlbmNlW0NhbnZhc05vZGVdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXG4gKiBBY2Nlc3MgbWV0aG9kcyBpbiB0aGlzIGZhY3RvcnkgdGhyb3VnaCBTY2VuZS5hZGQuW21ldGhvZE5hbWVdKCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc05vZGVGYWN0b3J5IHtcblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG5cdGluaXQoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhbiBpbnN0YW5jZSBvZiBhIFVJRWxlbWVudCB0byB0aGUgY3VycmVudCBzY2VuZSAtIGkuZS4gYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBVSUVsZW1lbnRcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciB0byBhZGQgdGhlIFVJRWxlbWVudCB0b1xuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gZmVlZCB0byB0aGUgY29uc3RydWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XG5cdCAqL1xuXHRhZGRVSUVsZW1lbnQgPSAodHlwZTogc3RyaW5nIHwgVUlFbGVtZW50VHlwZSwgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVUlFbGVtZW50ID0+IHtcblx0XHQvLyBHZXQgdGhlIGxheWVyXG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xuXG5cdFx0bGV0IGluc3RhbmNlOiBVSUVsZW1lbnQ7XG5cblx0XHRzd2l0Y2godHlwZSl7XG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuQlVUVE9OOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRCdXR0b24ob3B0aW9ucyk7XG5cdFx0XHRicmVhaztcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5MQUJFTDpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkTGFiZWwob3B0aW9ucyk7XG5cdFx0XHRicmVhaztcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5TTElERVI6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFNsaWRlcihvcHRpb25zKTtcblx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLlRFWFRfSU5QVVQ6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFRleHRJbnB1dChvcHRpb25zKTtcblx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgYFVJRWxlbWVudFR5cGUgJyR7dHlwZX0nIGRvZXMgbm90IGV4aXN0LCBvciBpcyByZWdpc3RlcmVkIGluY29ycmVjdGx5LmBcblx0XHR9XG5cblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuXHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xuXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSlcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcblx0ICovXG5cdGFkZFNwcml0ZSA9IChrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBTcHJpdGUgPT4ge1xuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcblxuXHRcdGxldCBpbnN0YW5jZSA9IG5ldyBTcHJpdGUoa2V5KTtcblxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBzY2VuZVxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XG5cblx0XHRpZighKHRoaXMuc2NlbmUuaXNQYXJhbGxheExheWVyKGxheWVyTmFtZSkgfHwgdGhpcy5zY2VuZS5pc1VJTGF5ZXIobGF5ZXJOYW1lKSkpe1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpO1xuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gQW5pbWF0ZWRTcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGVkU3ByaXRlXG5cdCAqL1xuXHRhZGRBbmltYXRlZFNwcml0ZSA9IDxUIGV4dGVuZHMgQW5pbWF0ZWRTcHJpdGU+KGNvbnN0cjogbmV3IChzOiBTcHJpdGVzaGVldCkgPT4gVCwga2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogVCA9PiB7XG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xuXHRcdGxldCBzcHJpdGVzaGVldCA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNwcml0ZXNoZWV0KGtleSk7XG5cdFx0bGV0IGluc3RhbmNlID0gbmV3IGNvbnN0cihzcHJpdGVzaGVldCk7XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgZm8gc2NlbmVcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuXHRcdFxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XG5cdFx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBncmFwaGljIHRvIGFkZFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIGdyYXBoaWNcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgR3JhcGhpY1xuXHQgKi9cblx0YWRkR3JhcGhpYyA9ICh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyA9PiB7XG5cdFx0Ly8gR2V0IHRoZSBsYXllclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcblxuXHRcdGxldCBpbnN0YW5jZTogR3JhcGhpYztcblxuXHRcdHN3aXRjaCh0eXBlKXtcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuUE9JTlQ6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFBvaW50KG9wdGlvbnMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuTElORTpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkTGluZShvcHRpb25zKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLlJFQ1Q6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFJlY3Qob3B0aW9ucyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5QQVJUSUNMRTpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkUGFydGljbGUob3B0aW9ucyk7XG5cdFx0XHRcdGJyZWFrO1x0XHRcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuQ0lSQ0xFOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRDaXJjbGUob3B0aW9ucyk7XHRcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBgR3JhcGhpY1R5cGUgJyR7dHlwZX0nIGRvZXMgbm90IGV4aXN0LCBvciBpcyByZWdpc3RlcmVkIGluY29ycmVjdGx5LmBcblx0XHR9XG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIHNjZW5lXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcblxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XG5cdFx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0gQlVJTERFUlMgLS0tLS0tLS0tLSAqL1xuXG5cdGJ1aWxkQnV0dG9uKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogQnV0dG9uIHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiQnV0dG9uXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJ0ZXh0XCIsIFwic3RyaW5nXCIpO1xuXHRcdHJldHVybiBuZXcgQnV0dG9uKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMudGV4dCk7XG5cdH1cblxuXHRidWlsZExhYmVsKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogTGFiZWwge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGFiZWxcIiwgb3B0aW9ucywgXCJ0ZXh0XCIsIFwic3RyaW5nXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBMYWJlbChvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpXG5cdH1cblxuXHRidWlsZFNsaWRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogU2xpZGVyIHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiU2xpZGVyXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXG5cdFx0bGV0IGluaXRWYWx1ZSA9IDA7XG5cdFx0aWYob3B0aW9ucy52YWx1ZSAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdGluaXRWYWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBTbGlkZXIob3B0aW9ucy5wb3NpdGlvbiwgaW5pdFZhbHVlKTtcblx0fVxuXG5cdGJ1aWxkVGV4dElucHV0KG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBUZXh0SW5wdXQge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJUZXh0SW5wdXRcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cblx0XHRyZXR1cm4gbmV3IFRleHRJbnB1dChvcHRpb25zLnBvc2l0aW9uKTtcblx0fVxuXG5cdGJ1aWxkUG9pbnQob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQb2ludCB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBvaW50XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBQb2ludChvcHRpb25zLnBvc2l0aW9uKTtcblx0fVxuXG5cdGJ1aWxkUGFydGljbGUob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQb2ludCB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBhcnRpY2xlXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJQYXJ0aWNsZVwiLCBvcHRpb25zLCBcInNpemVcIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJQYXJ0aWNsZVwiLCBvcHRpb25zLCBcIm1hc3NcIiwgXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG5cblx0XHQvL0NoYW5nZWQgZm9yIHRlc3Rpbmdcblx0XHRyZXR1cm4gbmV3IFBhcnRpY2xlKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMuc2l6ZSwgb3B0aW9ucy5tYXNzKTtcblx0fVxuXG5cdGJ1aWxkTGluZShvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFBvaW50IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGluZVwiLCBvcHRpb25zLCBcInN0YXJ0XCIsIFZlYzIsIFwiVmVjMlwiKTtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGluZVwiLCBvcHRpb25zLCBcImVuZFwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0cmV0dXJuIG5ldyBMaW5lKG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcblx0fVxuXG5cdGJ1aWxkUmVjdChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY3Qge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XG5cblx0XHRyZXR1cm4gbmV3IFJlY3Qob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy5zaXplKTtcblx0fVxuXHRidWlsZENpcmNsZShvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY3Qge1xuXHRcdC8vIHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdC8vIHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0XG5cdFx0cmV0dXJuIG5ldyBDaXJjbGVHcmFwaChvcHRpb25zLmNlbnRlciwgb3B0aW9ucy5yKTtcblx0fVxuXHQvKiAtLS0tLS0tLS0tIEVSUk9SIEhBTkRMSU5HIC0tLS0tLS0tLS0gKi9cblxuXHRjaGVja0lmUHJvcEV4aXN0czxUPihvYmplY3ROYW1lOiBzdHJpbmcsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3A6IHN0cmluZywgdHlwZTogKG5ldyAoLi4uYXJnczogYW55KSA9PiBUKSB8IHN0cmluZywgdHlwZU5hbWU/OiBzdHJpbmcpe1xuXHRcdGlmKCFvcHRpb25zIHx8IG9wdGlvbnNbcHJvcF0gPT09IHVuZGVmaW5lZCl7XG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBvcHRpb25zIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5XG5cdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgbm9uZSB3YXMgcHJvdmlkZWQuYDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgcHJvcGVydHkgaGFzIHRoZSBjb3JyZWN0IHR5cGVcblx0XHRcdGlmKCh0eXBlb2YgdHlwZSkgPT09IFwic3RyaW5nXCIpe1xuXHRcdFx0XHRpZighKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSB0eXBlKSl7XG5cdFx0XHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlfS5gO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcblx0XHRcdFx0Ly8gSWYgdHlwZSBpcyBhIGNvbnN0cnVjdG9yLCBjaGVjayBhZ2FpbnN0IHRoYXRcblx0XHRcdFx0aWYoIShvcHRpb25zW3Byb3BdIGluc3RhbmNlb2YgdHlwZSkpe1xuXHRcdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlTmFtZX0uYDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XG5pbXBvcnQgQ2FudmFzTm9kZUZhY3RvcnkgZnJvbSBcIi4vQ2FudmFzTm9kZUZhY3RvcnlcIjtcbmltcG9ydCBUaWxlbWFwRmFjdG9yeSBmcm9tIFwiLi9UaWxlbWFwRmFjdG9yeVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcbmltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XG5cbi8qKlxuICogVGhlIG1hbmFnZXIgb2YgYWxsIGZhY3RvcmllcyB1c2VkIGZvciBhZGRpbmcgQHJlZmVyZW5jZVtHYW1lTm9kZV1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjdG9yeU1hbmFnZXIge1xuXG4gICAgLy8gQ29uc3RydWN0b3JzIGFyZSBjYWxsZWQgaGVyZSB0byBhbGxvdyBhc3NpZ25tZW50IG9mIHRoZWlyIGZ1bmN0aW9ucyB0byBmdW5jdGlvbnMgaW4gdGhpcyBjbGFzc1xuICAgIHByaXZhdGUgY2FudmFzTm9kZUZhY3Rvcnk6IENhbnZhc05vZGVGYWN0b3J5ID0gbmV3IENhbnZhc05vZGVGYWN0b3J5KCk7XG4gICAgcHJpdmF0ZSB0aWxlbWFwRmFjdG9yeTogVGlsZW1hcEZhY3RvcnkgPSBuZXcgVGlsZW1hcEZhY3RvcnkoKTtcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+KXtcbiAgICAgICAgdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5pbml0KHNjZW5lKTtcbiAgICAgICAgdGhpcy50aWxlbWFwRmFjdG9yeS5pbml0KHNjZW5lLCB0aWxlbWFwcyk7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGFsbCBvZiB0aGUgZmFjdG9yaWVzIHRocm91Z2ggdGhlIGZhY3RvcnkgbWFuYWdlclxuICAgIC8qKlxuXHQgKiBBZGRzIGFuIGluc3RhbmNlIG9mIGEgVUlFbGVtZW50IHRvIHRoZSBjdXJyZW50IHNjZW5lIC0gaS5lLiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIFVJRWxlbWVudFxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBVSUVsZW1lbnQgdG8gYWRkXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmZWVkIHRvIHRoZSBjb25zdHJ1Y3RvclxuXHQgKiBAcmV0dXJucyBBIG5ldyBVSUVsZW1lbnRcblx0ICovXG4gICAgdWlFbGVtZW50KHR5cGU6IHN0cmluZyB8IFVJRWxlbWVudFR5cGUsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFVJRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZFVJRWxlbWVudCh0eXBlLCBsYXllck5hbWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcblx0ICovXG5cdHNwcml0ZShrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBTcHJpdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBBZGRzIGFuIEFuaW1hdGVkU3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxuXHQgKiBAcmV0dXJucyBBIG5ldyBBbmltYXRlZFNwcml0ZVxuXHQgKi9cblx0YW5pbWF0ZWRTcHJpdGU8VCBleHRlbmRzIEFuaW1hdGVkU3ByaXRlPihjb25zdHI6IG5ldyAoczogU3ByaXRlc2hlZXQpID0+IFQsIGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IFQge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRBbmltYXRlZFNwcml0ZShjb25zdHIsIGtleSwgbGF5ZXJOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQWRkcyBhIG5ldyBncmFwaGljIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgU2NlbmVcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZ3JhcGhpYyB0byBhZGRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBncmFwaGljIGNvbnN0cnVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IEdyYXBoaWNcblx0ICovXG5cdGdyYXBoaWModHlwZTogR3JhcGhpY1R5cGUgfCBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IEdyYXBoaWMge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRHcmFwaGljKHR5cGUsIGxheWVyTmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgdGlsZW1hcCB0byBsb2FkXG4gICAgICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRlc2lyZWQgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBMYXllcnMsIGVhY2ggb2Ygd2hpY2ggY29udGFpbnMgYSBsYXllciBvZiB0aGUgdGlsZW1hcCBhcyBpdHMgb3duIFRpbGVtYXAgaW5zdGFuY2UuXG4gICAgICovXG5cdHRpbGVtYXAoa2V5OiBzdHJpbmcsIHNjYWxlPzogVmVjMik6IEFycmF5PExheWVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVtYXBGYWN0b3J5LmFkZChrZXksIHNjYWxlKTtcbiAgICB9XG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgeyBUaWxlZENvbGxlY3Rpb25UaWxlIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi4vLi4vUGF0aGZpbmRpbmcvTmF2bWVzaFwiO1xuaW1wb3J0IElzb21ldHJpY1RpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL0lzb21ldHJpY1RpbGVtYXBcIjtcbmltcG9ydCBTdGFnZ2VyZWRJc29tZXRyaWNUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9TdGFnZ2VyZWRJc29tZXRyaWNUaWxlbWFwXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5leHBvcnQgZW51bSBUaWxlbWFwT3JpZW50YXRpb24ge1xuICAgIE9SVEhPR09OQUwgPSBcIm9ydGhvZ29uYWxcIixcbiAgICBJU09NRVRSSUMgPSBcImlzb21ldHJpY1wiLFxuICAgIFNUQUdHRVJFRF9JU09NRVRSSUMgPSBcInN0YWdnZXJlZFwiXG59XG5cblxuLyoqXG4gKiBBIGZhY3RvcnkgdGhhdCBhYnN0cmFjdHMgYWRkaW5nIEByZWZlcmVuY2VbVGlsZW1hcF1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cbiAqIEFjY2VzcyBtZXRob2RzIGluIHRoaXMgZmFjdG9yeSB0aHJvdWdoIFNjZW5lLmFkZC5bbWV0aG9kTmFtZV0oKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZW1hcEZhY3Rvcnkge1xuICAgIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuICAgIHByaXZhdGUgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xuICAgIHByaXZhdGUgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgXG4gICAgaW5pdChzY2VuZTogU2NlbmUsIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPik6IHZvaWQge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSB0aWxlbWFwcztcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gVGhpcyBpcyBzcGVjaWZpY2FsbHkgY2F0ZXJlZCB0byBUaWxlZCB0aWxlbWFwcyByaWdodCBub3cuIEluIHRoZSBmdXR1cmUsXG4gICAgLy8gaXQgd291bGQgYmUgZ29vZCB0byBoYXZlIGEgXCJwYXJzZVRpbGVtYXBcIiBmdW5jdGlvbiB0aGF0IHdvdWxkIGNvbnZlcnQgdGhlIHRpbGVtYXBcbiAgICAvLyBkYXRhIGludG8gYSBzdGFuZGFyZCBmb3JtYXQuIFRoaXMgY291bGQgYWxsb3cgZm9yIHN1cHBvcnQgZnJvbSBvdGhlciBwcm9ncmFtc1xuICAgIC8vIG9yIHRoZSBkZXZlbG9wbWVudCBvZiBhbiBpbnRlcm5hbCBsZXZlbCBidWlsZGVyIHRvb2xcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGlsZW1hcCB0byB0aGUgc2NlbmVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGVzaXJlZCB0aWxlbWFwXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgdGlsZW1hcCBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cbiAgICAgKi9cblx0YWRkID0gKGtleTogc3RyaW5nLCBzY2FsZTogVmVjMiA9IG5ldyBWZWMyKDEsIDEpKTogQXJyYXk8TGF5ZXI+ID0+IHtcbiAgICAgICAgLy8gR2V0IFRpbGVtYXAgRGF0YVxuICAgICAgICBsZXQgdGlsZW1hcERhdGEgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRUaWxlbWFwKGtleSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyB0aWxlbWFwIHRvIGVpdGhlciBiZSBvcnRob2dyYXBoaWMgb3IgaXNvbWV0cmljXG4gICAgICAgIGxldCBjb25zdHI6IG5ldyguLi5hcmdzOiBhbnkpID0+IFRpbGVtYXA7XG5cbiAgICAgICAgc3dpdGNoKHRpbGVtYXBEYXRhLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFRpbGVtYXBPcmllbnRhdGlvbi5PUlRIT0dPTkFMOiB7XG4gICAgICAgICAgICAgICAgY29uc3RyID0gT3J0aG9nb25hbFRpbGVtYXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFRpbGVtYXBPcmllbnRhdGlvbi5JU09NRVRSSUM6IHtcbiAgICAgICAgICAgICAgICBjb25zdHIgPSBJc29tZXRyaWNUaWxlbWFwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBUaWxlbWFwT3JpZW50YXRpb24uU1RBR0dFUkVEX0lTT01FVFJJQzoge1xuICAgICAgICAgICAgICAgIGNvbnN0ciA9IFN0YWdnZXJlZElzb21ldHJpY1RpbGVtYXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFRpbGVtYXAgT3JpZW50YXRpb24gXCIke3RpbGVtYXBEYXRhLm9yaWVudGF0aW9ufVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSByZXR1cm4gdmFsdWUgYXJyYXlcbiAgICAgICAgbGV0IHNjZW5lTGF5ZXJzID0gbmV3IEFycmF5PExheWVyPigpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbGwgb2YgdGhlIHRpbGVzZXRzIGZvciB0aGlzIHRpbGVtYXBcbiAgICAgICAgbGV0IHRpbGVzZXRzID0gbmV3IEFycmF5PFRpbGVzZXQ+KCk7XG5cbiAgICAgICAgbGV0IGNvbGxlY3Rpb25UaWxlcyA9IG5ldyBBcnJheTxUaWxlZENvbGxlY3Rpb25UaWxlPigpO1xuXG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwRGF0YS50aWxlc2V0cyl7XG4gICAgICAgICAgICBpZih0aWxlc2V0LmltYWdlKXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3RhbmRhcmQgdGlsZXNldCBhbmQgbm90IGEgY29sbGVjdGlvbiwgY3JlYXRlIGEgdGlsZXNldCBmb3IgaXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIFdlIGFyZSBpZ25vcmluZyBjb2xsZWN0aW9uIHRpbGVzZXRzIGZvciBub3cuIFRoaXMgaXMgbGlrZWx5IG5vdCBhIGdyZWF0IGlkZWEgaW4gcHJhY3RpY2UsXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlb3JldGljYWxseSBzb21lb25lIGNvdWxkIHdhbnQgdG8gdXNlIG9uZSBmb3IgYSBzdGFuZGFyZCB0aWxlbWFwLiBXZSBhcmUgYXNzdW1pbmcgZm9yIG5vd1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2Ugb25seSB3YW50IHRvIHVzZSB0aGVtIGZvciBvYmplY3QgbGF5ZXJzXG4gICAgICAgICAgICAgICAgdGlsZXNldHMucHVzaChuZXcgVGlsZXNldCh0aWxlc2V0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbGVzZXQudGlsZXMuZm9yRWFjaCh0aWxlID0+IHRpbGUuaWQgKz0gdGlsZXNldC5maXJzdGdpZCk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblRpbGVzLnB1c2goLi4udGlsZXNldC50aWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgdGlsZW1hcCBhbmQgY3JlYXRlIHRpbGVkbGF5ZXJzIG9yIG9iamVjdCBsYXllcnNcbiAgICAgICAgZm9yKGxldCBsYXllciBvZiB0aWxlbWFwRGF0YS5sYXllcnMpe1xuXG4gICAgICAgICAgICBsZXQgc2NlbmVMYXllcjtcbiAgICAgICAgICAgIGxldCBpc1BhcmFsbGF4TGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgaWYocHJvcC5uYW1lID09PSBcIlBhcmFsbGF4XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXJhbGxheExheWVyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJEZXB0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGlzUGFyYWxsYXhMYXllcil7XG4gICAgICAgICAgICAgICAgc2NlbmVMYXllciA9IHRoaXMuc2NlbmUuYWRkUGFyYWxsYXhMYXllcihsYXllci5uYW1lLCBuZXcgVmVjMigxLCAxKSwgZGVwdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRMYXllcihsYXllci5uYW1lLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxheWVyLnR5cGUgPT09IFwidGlsZWxheWVyXCIpe1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0aWxlbWFwIG9iamVjdCBmb3IgdGhlIGxheWVyXG4gICAgICAgICAgICAgICAgbGV0IHRpbGVtYXAgPSBuZXcgY29uc3RyKHRpbGVtYXBEYXRhLCBsYXllciwgdGlsZXNldHMsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICB0aWxlbWFwLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgICAgdGlsZW1hcC5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGlsZW1hcCB0byBzY2VuZVxuICAgICAgICAgICAgICAgIHRoaXMudGlsZW1hcHMucHVzaCh0aWxlbWFwKTtcbiAgICBcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyLmFkZE5vZGUodGlsZW1hcCk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdGlsZW1hcCB3aXRoIHBoeXNpY3MgaWYgaXQncyBjb2xsaWRhYmxlXG4gICAgICAgICAgICAgICAgaWYodGlsZW1hcC5pc0NvbGxpZGFibGUpe1xuICAgICAgICAgICAgICAgICAgICB0aWxlbWFwLmFkZFBoeXNpY3MoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiR3JvdXBcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuc2V0R3JvdXAoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGxldCBpc05hdm1lc2hQb2ludHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbmF2bWVzaE5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IGVkZ2VzO1xuICAgICAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHByb3Agb2YgbGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiTmF2bWVzaFBvaW50c1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05hdm1lc2hQb2ludHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJuYW1lXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdm1lc2hOYW1lID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiZWRnZXNcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBwcm9wLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoaXNOYXZtZXNoUG9pbnRzKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBuZXcgUG9zaXRpb25HcmFwaCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZy5hZGRQb3NpdGlvbmVkTm9kZShuZXcgVmVjMihvYmoueCwgb2JqLnkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgZWRnZSBvZiBlZGdlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnLmFkZEVkZ2UoZWRnZS5mcm9tLCBlZGdlLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5hZGROYXZpZ2FibGVFbnRpdHkobmF2bWVzaE5hbWUsIG5ldyBOYXZtZXNoKGcpKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMYXllciBpcyBhbiBvYmplY3QgbGF5ZXIsIHNvIGFkZCBlYWNoIG9iamVjdCBhcyBhIHNwcml0ZSB0byBhIG5ldyBsYXllclxuICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvYmogaXMgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzUGh5c2ljcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNDb2xsaWRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1RyaWdnZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9uRW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25FeGl0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyaWdnZXJHcm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYob2JqLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIG9iai5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiSGFzUGh5c2ljc1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUGh5c2ljcyA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbGxpZGFibGUgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiR3JvdXBcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIklzVHJpZ2dlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNUcmlnZ2VyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJHcm91cFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckdyb3VwID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkVudGVyXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVudGVyID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkV4aXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXhpdCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwcml0ZTogU3ByaXRlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9iaiBpcyBhIHRpbGUgZnJvbSBhIHRpbGVzZXRcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVzZXRzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRpbGVzZXQuaGFzVGlsZShvYmouZ2lkKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdCBpcyBhIHRpbGUgZnJvbSB0aGlzIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdGlsZXNldC5nZXRJbWFnZU9mZnNldEZvclRpbGUob2JqLmdpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoKG9iai54ICsgc2l6ZS54LzIpKnNjYWxlLngsIChvYmoueSAtIHNpemUueS8yKSpzY2FsZS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0SW1hZ2VPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2l6ZS5jb3B5KHNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaW4gYSB0aWxlc2V0LCBtdXN0IGNvcnJlc3BvbmQgdG8gYSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzcHJpdGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlIG9mIGNvbGxlY3Rpb25UaWxlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqLmdpZCA9PT0gdGlsZS5pZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGUuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHRoaXMuc2NlbmUuYWRkLnNwcml0ZShpbWFnZUtleSwgbGF5ZXIubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoKG9iai54ICsgdGlsZS5pbWFnZXdpZHRoLzIpKnNjYWxlLngsIChvYmoueSAtIHRpbGUuaW1hZ2VoZWlnaHQvMikqc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgc3ByaXRlLiBBc3NvY2lhdGUgaXQgd2l0aCBvdXIgcGh5c2ljcyBvYmplY3QgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1BoeXNpY3Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgc3ByaXRlIGEgc3RhdGljIHBoeXNpY3Mgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuYWRkUGh5c2ljcyhzcHJpdGUuYm91bmRhcnkuY2xvbmUoKSwgVmVjMi5aRVJPLCBpc0NvbGxpZGFibGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzVHJpZ2dlciAmJiB0cmlnZ2VyR3JvdXAgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRUcmlnZ2VyKHRyaWdnZXJHcm91cCwgb25FbnRlciwgb25FeGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIHNjZW5lTGF5ZXJzLnB1c2goc2NlbmVMYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NlbmVMYXllcnM7XG5cdH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4vU2NlbmVcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuXG5cbi8qKlxuICogQSBsYXllciBpbiB0aGUgc2NlbmUuIExheWVycyBhcmUgdXNlZCBmb3Igc29ydGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgYnkgZGVwdGguXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyIHtcbiAgICAvKiogVGhlIHNjZW5lIHRoaXMgbGF5ZXIgYmVsb25ncyB0byAqL1xuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cbiAgICAvKiogVGhlIG5hbWUgb2YgdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKiogV2hldGhlciB0aGlzIGxheWVyIGlzIHBhdXNlZCBvciBub3QgKi9cbiAgICBwcm90ZWN0ZWQgcGF1c2VkOiBib29sZWFuO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBsYXllciBpcyBoaWRkZW4gZnJvbSBiZWluZyByZW5kZXJlZCBvciBub3QgKi9cbiAgICBwcm90ZWN0ZWQgaGlkZGVuOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBnbG9iYWwgYWxwaGEgbGV2ZWwgb2YgdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xuXG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSBHYW1lTm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBsYXllciAqL1xuICAgIHByb3RlY3RlZCBpdGVtczogQXJyYXk8R2FtZU5vZGU+O1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgbGF5ZXIgc2hvdWxkIGJlIHlzb3J0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgeVNvcnQ6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIGRlcHRoIG9mIHRoaXMgbGF5ZXIgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzICovXG4gICAgcHJvdGVjdGVkIGRlcHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxheWVyLiBUbyBkbyB0aGlzIGluIGEgZ2FtZSwgdXNlIHRoZSBhZGRMYXllcigpIG1ldGhvZCBpbiBAcmVmcmVuY2VbU2NlbmVdXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0byBhZGQgdGhlIGxheWVyIHRvXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcpe1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMueVNvcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIHRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqL1xuICAgIGdldE5hbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMvVW5wYXVzZXMgdGhlIGxheWVyLiBBZmZlY3RzIGFsbCBlbGVtZW50cyBpbiB0aGlzIGxheWVyXG4gICAgICogQHBhcmFtIHBhdXNlVmFsdWUgVHJ1ZSBpZiB0aGUgbGF5ZXIgc2hvdWxkIGJlIHBhdXNlZCwgZmFsc2UgaWYgbm90XG4gICAgICovXG4gICAgc2V0UGF1c2VkKHBhdXNlVmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBwYXVzZVZhbHVlO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyBwYXVzZWRcbiAgICAgKi9cbiAgICBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF1c2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyXG4gICAgICogQHBhcmFtIGFscGhhIFRoZSBuZXcgb3BhY2l0eSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAgICovXG4gICAgc2V0QWxwaGEoYWxwaGE6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmFscGhhID0gTWF0aFV0aWxzLmNsYW1wKGFscGhhLCAwLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBvcGFjaXR5XG4gICAgICovXG4gICAgZ2V0QWxwaGEoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGF5ZXIncyBoaWRkZW4gdmFsdWUuIElmIGhpZGRlbiwgYSBsYXllciB3aWxsIG5vdCBiZSByZW5kZXJlZCwgYnV0IHdpbGwgc3RpbGwgdXBkYXRlXG4gICAgICogQHBhcmFtIGhpZGRlbiBUaGUgaGlkZGVuIHZhbHVlIG9mIHRoZSBsYXllclxuICAgICAqL1xuICAgIHNldEhpZGRlbihoaWRkZW46IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBoaWRkZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGlkZWVuIHZhbHVlIG9mIHRoZSBseWFlclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNjZW5lIGlzIGhpZGRlbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNIaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZGRlbjtcbiAgICB9XG5cbiAgICAvKiogUGF1c2VzIHRoaXMgc2NlbmUgYW5kIGhpZGVzIGl0ICovXG4gICAgZGlzYWJsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqIFVucGF1c2VzIHRoaXMgbGF5ZXIgYW5kIG1ha2VzIGl0IHZpc2libGUgKi9cbiAgICBlbmFibGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgc2NlbmUgd2lsbCB5U29ydCBhdXRvbWF0aWNhbGx5LlxuICAgICAqIHlTb3J0aW5nIG1lYW5zIHRoYXQgQ2FudmFzTm9kZXMgb24gdGhpcyBsYXllciB3aWxsIGhhdmUgdGhlaXIgZGVwdGggc29ydGVkIGRlcGVuZGluZyBvbiB0aGVpciB5LXZhbHVlLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCBpZiBhbiBvYmplY3QgaXMgXCJoaWdoZXJcIiBpbiB0aGUgc2NlbmUsIGl0IHdpbGwgc29ydCBiZWhpbmQgb2JqZWN0cyB0aGF0IGFyZSBcImxvd2VyXCIuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIDMvNCB2aWV3IGdhbWVzLCBvciBzaW1pbGFyIHNpdHVhdGlvbnMsIHdoZXJlIHlvdSBzb21ldGltZXMgd2FudCB0byBiZSBpbiBmcm9udCBvZiBvYmplY3RzLFxuICAgICAqIGFuZCBvdGhlciB0aW1lcyB3YW50IHRvIGJlIGJlaGluZCB0aGUgc2FtZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB5U29ydCBUcnVlIGlmIHlTb3J0aW5nIHNob3VsZCBiZSBhY3RpdmUsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIHNldFlTb3J0KHlTb3J0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMueVNvcnQgPSB5U29ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB5U29ydCBzdGF0dXMgb2YgdGhlIHNjZW5lXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB5U29ydGluZyBpcyBvY2N1cnJpbmcsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGdldFlTb3J0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55U29ydDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzLiBBIGxhcmdlciBudW1iZXIgbWVhbnMgdGhlIGxheWVyIHdpbGwgYmUgY2xvc2VyIHRvIHRoZSBzY3JlZW4uXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXG4gICAgICovXG4gICAgc2V0RGVwdGgoZGVwdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXG4gICAgICogQHJldHVybnMgVGhlIGRlcHRoXG4gICAgICovXG4gICAgZ2V0RGVwdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5vZGUgdG8gdGhpcyBsYXllclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGlzIGxheWVyLlxuICAgICAqL1xuICAgIGFkZE5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlLnNldExheWVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhpcyBsYXllclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgd2FzIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHJlbW92ZU5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcbiAgICAgICAgLy8gRmluZCBhbmQgcmVtb3ZlIHRoZSBub2RlXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihub2RlKTtcblxuICAgICAgICBpZihpbmRleCAhPT0gLTEpe1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgbm9kZS5zZXRMYXllcih1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmVzIGFsbCBHYW1lTm9kZXMgZnJvbSB0aGlzIGxheWVyXG4gICAgICogQHJldHVybnMgYW4gQXJyYXkgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIEdhbWVOb2RlcyBpbiB0aGlzIGxheWVyLlxuICAgICAqL1xuICAgIGdldEl0ZW1zKCk6IEFycmF5PEdhbWVOb2RlPiB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICAgIH1cbn0iLCJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL0xheWVyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgYSBMYXllciB0aGF0IGhhcyBhIHBhcmFsbGF4IHZhbHVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJhbGxheExheWVyIGV4dGVuZHMgTGF5ZXIge1xuXHQvKiogVGhlIHZhbHVlIG9mIHRoZSBwYXJhbGxheCBvZiB0aGUgTGF5ZXIgKi9cblx0cGFyYWxsYXg6IFZlYzI7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBQYXJhbGxheExheWVyLlxuXHQgKiBVc2UgYWRkUGFyYWxsYXhMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdG8gYWRkIHRoaXMgUGFyYWxsYXhMYXllciB0b1xuXHQgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgUGFyYWxsYXhMYXllclxuXHQgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZywgcGFyYWxsYXg6IFZlYzIpe1xuXHRcdHN1cGVyKHNjZW5lLCBuYW1lKTtcblx0XHR0aGlzLnBhcmFsbGF4ID0gcGFyYWxsYXg7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuL1BhcmFsbGF4TGF5ZXJcIjtcblxuLyoqXG4gKiBBIExheWVyIHN0cmljdGx5IHRvIGJlIHVzZWQgZm9yIG1hbmFnaW5nIFVJRWxlbWVudHMuXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGEgTGF5ZXIgdGhhdCBhbHdheXMgc3RheXMgaW4gdGhlIHNhbWUgcGxhY2UsXG4gKiBhbmQgdGh1cyByZW5kZXJzIHRoaW5ncyBsaWtlIGEgSFVEIG9yIGFuIGludmVudG9yeSB3aXRob3V0IHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIFxccmVmZXJlbmNlW1ZpZXdwb3J0XSBzY3JvbGwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJTGF5ZXIgZXh0ZW5kcyBQYXJhbGxheExheWVyIHtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgVUlMYXllci5cblx0ICogVXNlIGFkZFVJTGF5ZXIoKSBpbiBAcmVmZXJlbmNlW1NjZW5lXSB0byBhZGQgYSBsYXllciBvZiB0aGlzIHR5cGUgdG8geW91ciBnYW1lLlxuXHQgKiBAcGFyYW0gc2NlbmUgVGhlIFNjZW5lIHRvIGFkZCB0aGlzIFVJTGF5ZXIgdG9cblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFVJTGF5ZXJcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgbmFtZTogc3RyaW5nKXtcblx0XHRzdXBlcihzY2VuZSwgbmFtZSwgVmVjMi5aRVJPKTtcblx0fVxufSIsImltcG9ydCBMYXllciBmcm9tIFwiLi9MYXllclwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZUdyYXBoIGZyb20gXCIuLi9TY2VuZUdyYXBoL1NjZW5lR3JhcGhcIjtcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9QaHlzaWNzTWFuYWdlclwiO1xuaW1wb3J0IEJhc2ljUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvQmFzaWNQaHlzaWNzTWFuYWdlclwiO1xuaW1wb3J0IFNjZW5lR3JhcGhBcnJheSBmcm9tIFwiLi4vU2NlbmVHcmFwaC9TY2VuZUdyYXBoQXJyYXlcIjtcbmltcG9ydCBGYWN0b3J5TWFuYWdlciBmcm9tIFwiLi9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXJcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgR2FtZSBmcm9tIFwiLi4vTG9vcC9HYW1lXCI7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuL1NjZW5lTWFuYWdlclwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBOYXZpZ2F0aW9uTWFuYWdlciBmcm9tIFwiLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXJcIjtcbmltcG9ydCBBSU1hbmFnZXIgZnJvbSBcIi4uL0FJL0FJTWFuYWdlclwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL0NvbGxlY3Rpb25zL01hcFwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4vTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuL0xheWVycy9VSUxheWVyXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IFNjZW5lT3B0aW9ucyBmcm9tIFwiLi9TY2VuZU9wdGlvbnNcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IFRpbWVyTWFuYWdlciBmcm9tIFwiLi4vVGltaW5nL1RpbWVyTWFuYWdlclwiO1xuaW1wb3J0IFR3ZWVuTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5NYW5hZ2VyXCI7XG5pbXBvcnQgUGFydGljbGVTeXN0ZW1NYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9QYXJ0aWNsZVN5c3RlbU1hbmFnZXJcIjtcblxuLyoqXG4gKiBTY2VuZXMgYXJlIHRoZSBtYWluIGNvbnRhaW5lciBpbiB0aGUgZ2FtZSBlbmdpbmUuXG4gKiBZb3VyIG1haW4gc2NlbmUgaXMgdGhlIGN1cnJlbnQgbGV2ZWwgb3IgbWVudSBvZiB0aGUgZ2FtZSwgYW5kIHdpbGwgY29udGFpbiBhbGwgb2YgdGhlIEdhbWVOb2RlcyBuZWVkZWQuXG4gKiBTY2VuZXMgcHJvdmlkZSBhbiBlYXN5IHdheSB0byBsb2FkIGFzc2V0cywgYWRkIGFzc2V0cyB0byB0aGUgZ2FtZSB3b3JsZCwgYW5kIHVubG9hZCBhc3NldHMsXG4gKiBhbmQgaGF2ZSBsaWZlY3ljbGUgbWV0aG9kcyBleHBvc2VkIGZvciB0aGVzZSBmdW5jdGlvbnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBnYW1lIHdvcmxkLiAqL1xuICAgIHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XG5cbiAgICAvKiogVGhlIHZpZXdwb3J0LiAqL1xuICAgIHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XG5cbiAgICAvKiogQSBmbGFnIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgc2NlbmUgaXMgcnVubmluZyBvciBub3QuICovXG4gICAgcHJvdGVjdGVkIHJ1bm5pbmc6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIG1hbmFnZXIgb2YgdGhpcyBzY2VuZS4gKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXI7XG5cbiAgICAvKiogVGhlIHJlY2VpdmVyIGZvciB0aGlzIHNjZW5lLiAqL1xuICAgIHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG5cbiAgICAvKiogVGhlIGVtaXR0ZXIgZm9yIHRoaXMgc2NlbmUuICovXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cbiAgICAvKiogVGhpcyBsaXN0IG9mIHRpbGVtYXBzIGluIHRoaXMgc2NlbmUuICovXG4gICAgcHJvdGVjdGVkIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcblxuICAgIC8qKiBBIG1hcCBmcm9tIGxheWVyIG5hbWVzIHRvIHRoZSBsYXllcnMgdGhlbXNlbHZlcyAqL1xuICAgIHByb3RlY3RlZCBsYXllcnM6IE1hcDxMYXllcj47XG5cbiAgICAvKiogQSBtYXAgZnJvbSBwYXJhbGxheCBsYXllciBuYW1lcyB0byB0aGUgcGFyYWxsYXggbGF5ZXJzIHRoZW1zZWx2ZXMgKi9cbiAgICBwcm90ZWN0ZWQgcGFyYWxsYXhMYXllcnM6IE1hcDxQYXJhbGxheExheWVyPjtcblxuICAgIC8qKiBBIG1hcCBmcm9tIHVpTGF5ZXIgbmFtZXMgdG8gdGhlIHVpTGF5ZXJzIHRoZW1zZWx2ZXMgKi9cbiAgICBwcm90ZWN0ZWQgdWlMYXllcnM6IE1hcDxVSUxheWVyPjtcblxuICAgIC8qKiBUaGUgc2NlbmUgZ3JhcGggb2YgdGhlIFNjZW5lKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmVHcmFwaDogU2NlbmVHcmFwaDtcblxuICAgIC8qKiBUaGUgcGh5c2ljcyBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xuICAgIHByb3RlY3RlZCBwaHlzaWNzTWFuYWdlcjogUGh5c2ljc01hbmFnZXI7XG4gICAgXG4gICAgLyoqIFRoZSBuYXZpZ2F0aW9uIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXG4gICAgcHJvdGVjdGVkIG5hdk1hbmFnZXI6IE5hdmlnYXRpb25NYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSBBSSBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xuICAgIHByb3RlY3RlZCBhaU1hbmFnZXI6IEFJTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgcmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgc2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcblxuICAgIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGFkZGluZyBvZiBkaWZmZXJlbnQgbm9kZXMgdG8gdGhlIHNjZW5lICovXG4gICAgcHVibGljIGFkZDogRmFjdG9yeU1hbmFnZXI7XG5cbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBsb2FkaW5nIG9mIGRpZmZlcmVudCBmaWxlcyBmb3IgdXNlIGluIHRoZSBzY2VuZS4gQW4gYWxpYXMgZm9yIHJlc291cmNlTWFuYWdlciAqL1xuICAgIHB1YmxpYyBsb2FkOiBSZXNvdXJjZU1hbmFnZXI7XG5cbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBsb2FkaW5nIGFuZCB1bmxvYWRpbmcgb2YgZGlmZmVyZW50IGZpbGVzIGZvciB1c2UgaW4gdGhlIHNjZW5lICovXG4gICAgcHVibGljIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgc2NlbmUgKi9cbiAgICBwdWJsaWMgc2NlbmVPcHRpb25zOiBTY2VuZU9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNjZW5lLiBUbyBhZGQgYSBuZXcgU2NlbmUgaW4geW91ciBnYW1lLCB1c2UgY2hhbmdlVG9TY2VuZSgpIGluIEByZWZlcmVuY2VbU2NlbmVNYW5hZ2VyXVxuICAgICAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gc2NlbmVNYW5hZ2VyIFRoZSBTY2VuZU1hbmFnZXIgdGhhdCBvd25zIHRoaXMgU2NlbmVcbiAgICAgKiBAcGFyYW0gcmVuZGVyaW5nTWFuYWdlciBUaGUgUmVuZGVyaW5nTWFuYWdlciB0aGF0IHdpbGwgaGFuZGxlIHRoaXMgU2NlbmUncyByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0gZ2FtZSBUaGUgaW5zdGFuY2Ugb2YgdGhlIEdhbWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgU2NlbmUgaW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyLCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcbiAgICAgICAgdGhpcy5zY2VuZU9wdGlvbnMgPSBTY2VuZU9wdGlvbnMucGFyc2Uob3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLndvcmxkU2l6ZSA9IG5ldyBWZWMyKDUwMCwgNTAwKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCAyNTYwLCAxMjgwKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyID0gc2NlbmVNYW5hZ2VyO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnNjZW5lR3JhcGggPSBuZXcgU2NlbmVHcmFwaEFycmF5KHRoaXMudmlld3BvcnQsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMubGF5ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnVpTGF5ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMucGh5c2ljc01hbmFnZXIgPSBuZXcgQmFzaWNQaHlzaWNzTWFuYWdlcih0aGlzLnNjZW5lT3B0aW9ucy5waHlzaWNzKTtcbiAgICAgICAgdGhpcy5uYXZNYW5hZ2VyID0gbmV3IE5hdmlnYXRpb25NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuYWlNYW5hZ2VyID0gbmV3IEFJTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSByZW5kZXJpbmdNYW5hZ2VyO1xuXG4gICAgICAgIHRoaXMuYWRkID0gbmV3IEZhY3RvcnlNYW5hZ2VyKHRoaXMsIHRoaXMudGlsZW1hcHMpO1xuXG4gICAgICAgIHRoaXMubG9hZCA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gdGhpcy5sb2FkO1xuXG4gICAgICAgIC8vIEdldCB0aGUgdGltZXIgbWFuYWdlciBhbmQgY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyc1xuICAgICAgICBUaW1lck1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5jbGVhclRpbWVycygpO1xuICAgIH1cblxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBhIG5ldyBzY2VuZSBpcyBjcmVhdGVkLCBiZWZvcmUgYW55dGhpbmcgZWxzZS4gKi9cbiAgICBpbml0U2NlbmUoaW5pdDogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cblxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIGEgbmV3IHNjZW5lIGlzIGNyZWF0ZWQuIExvYWQgYWxsIGZpbGVzIHlvdSB3aXNoIHRvIGFjY2VzcyBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cbiAgICBsb2FkU2NlbmUoKTogdm9pZCB7fVxuXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgc3RyaWN0bHkgYWZ0ZXIgbG9hZFNjZW5lKCkuIENyZWF0ZSBhbnkgZ2FtZSBvYmplY3RzIHlvdSB3aXNoIHRvIHVzZSBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cbiAgICBzdGFydFNjZW5lKCk6IHZvaWQge31cblxuICAgIC8qKlxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgZXZlcnkgZnJhbWUgb2YgdGhlIGdhbWUuIFRoaXMgaXMgd2hlcmUgeW91IGNhbiBkeW5hbWljYWxseSBkbyB0aGluZ3MgbGlrZSBhZGQgaW4gbmV3IGVuZW1pZXNcbiAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIHRpbWUgdGhpcyBmcmFtZSByZXByZXNlbnRzXG4gICAgICovXG4gICAgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHt9XG5cbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgb24gc2NlbmUgZGVzdHJ1Y3Rpb24uIFNwZWNpZnkgd2hpY2ggZmlsZXMgeW91IG5vIGxvbmdlciBuZWVkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uICovXG4gICAgdW5sb2FkU2NlbmUoKTogdm9pZCB7fVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlU2NlbmUoZGVsdGFUKTtcblxuICAgICAgICAvLyBEbyB0aW1lIHVwZGF0ZXNcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gRG8gYWxsIEFJIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5haU1hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCBwaHlzaWNzIG9iamVjdHNcbiAgICAgICAgdGhpcy5waHlzaWNzTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBVcGRhdGUgYWxsIGNhbnZhcyBvYmplY3RzXG4gICAgICAgIHRoaXMuc2NlbmVHcmFwaC51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBVcGRhdGUgYWxsIHRpbGVtYXBzXG4gICAgICAgIHRoaXMudGlsZW1hcHMuZm9yRWFjaCh0aWxlbWFwID0+IHtcbiAgICAgICAgICAgIGlmKCF0aWxlbWFwLmdldExheWVyKCkuaXNQYXVzZWQoKSl7XG4gICAgICAgICAgICAgICAgdGlsZW1hcC51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGFsbCB0d2VlbnNcbiAgICAgICAgVHdlZW5NYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFsbCBwYXJ0aWNsZSBzeXN0ZW1zXG4gICAgICAgIFBhcnRpY2xlU3lzdGVtTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLnZpZXdwb3J0LnVwZGF0ZShkZWx0YVQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3RzIHJlbmRlcmFibGUgc2V0cyBhbmQgY29vcmRpbmF0ZXMgd2l0aCB0aGUgUmVuZGVyaW5nTWFuYWdlciB0byBkcmF3IHRoZSBTY2VuZVxuICAgICAqL1xuICAgIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSB2aXNpYmxlIHNldCBvZiBub2Rlc1xuICAgICAgICBsZXQgdmlzaWJsZVNldCA9IHRoaXMuc2NlbmVHcmFwaC5nZXRWaXNpYmxlU2V0KCk7XG5cbiAgICAgICAgLy8gQWRkIHBhcmFsbGF4IGxheWVyIGl0ZW1zIHRvIHRoZSB2aXNpYmxlIHNldCAod2UncmUgcmVuZGVyaW5nIHRoZW0gYWxsIGZvciBub3cpXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgbGV0IHBMYXllciA9IHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBmb3IobGV0IG5vZGUgb2YgcExheWVyLmdldEl0ZW1zKCkpe1xuICAgICAgICAgICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBDYW52YXNOb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2VuZCB0aGUgdmlzaWJsZSBzZXQsIHRpbGVtYXBzLCBhbmQgdWlMYXllcnMgdG8gdGhlIHJlbmRlcmVyXG4gICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5yZW5kZXIodmlzaWJsZVNldCwgdGhpcy50aWxlbWFwcywgdGhpcy51aUxheWVycyk7XG5cbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgICAgIHRoaXMudGlsZW1hcHMuZm9yRWFjaCh0aWxlbWFwID0+IHRpbGVtYXAudmlzaWJsZSA/IG5vZGVzLnB1c2godGlsZW1hcCkgOiAwKTtcbiAgICAgICAgRGVidWcuc2V0Tm9kZXMobm9kZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjZW5lIGFzIHJ1bm5pbmcgb3Igbm90XG4gICAgICogQHBhcmFtIHJ1bm5pbmcgVHJ1ZSBpZiB0aGUgU2NlbmUgc2hvdWxkIGJlIHJ1bm5pbmcsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIHNldFJ1bm5pbmcocnVubmluZzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBydW5uaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIFNjZW5lIGlzIHJ1bm5pbmdcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzY2VuZSBpcyBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGlzIFNjZW5lXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBzY2VuZSBncmFwaFxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQ2FudmFzTm9kZSl7XG4gICAgICAgICAgICB0aGlzLnNjZW5lR3JhcGgucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3lzIHRoaXMgc2NlbmUgYW5kIGFsbCBub2RlcyBpbiBpdCAqL1xuICAgIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLnNjZW5lR3JhcGguZ2V0QWxsTm9kZXMoKSl7XG4gICAgICAgICAgICBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcbiAgICAgICAgICAgIHRpbGVtYXAuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVHcmFwaDtcbiAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc01hbmFnZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5hdk1hbmFnZXI7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFpTWFuYWdlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVjZWl2ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBsYXllciB0byB0aGUgc2NlbmUgYW5kIHJldHVybnMgaXRcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IGxheWVyXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBMYXllclxuICAgICAqL1xuICAgIGFkZExheWVyKG5hbWU6IHN0cmluZywgZGVwdGg/OiBudW1iZXIpOiBMYXllciB7XG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxheWVyID0gbmV3IExheWVyKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMubGF5ZXJzLmFkZChuYW1lLCBsYXllcik7XG5cbiAgICAgICAgaWYoZGVwdGgpe1xuICAgICAgICAgICAgbGF5ZXIuc2V0RGVwdGgoZGVwdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHBhcmFsbGF4IGxheWVyIHRvIHRoaXMgc2NlbmUgYW5kIHJldHVybnMgaXRcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFyYWxsYXggbGF5ZXJcbiAgICAgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBQYXJhbGxheExheWVyXG4gICAgICovXG4gICAgYWRkUGFyYWxsYXhMYXllcihuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyLCBkZXB0aD86IG51bWJlcik6IFBhcmFsbGF4TGF5ZXIge1xuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBQYXJhbGxheExheWVyKHRoaXMsIG5hbWUsIHBhcmFsbGF4KTtcblxuICAgICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzLmFkZChuYW1lLCBsYXllcik7XG5cbiAgICAgICAgaWYoZGVwdGgpe1xuICAgICAgICAgICAgbGF5ZXIuc2V0RGVwdGgoZGVwdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgVUlMYXllciB0byB0aGUgc2NlbmVcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IFVJbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBVSUxheWVyXG4gICAgICovXG4gICAgYWRkVUlMYXllcihuYW1lOiBzdHJpbmcpOiBVSUxheWVyIHtcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGF5ZXIgPSBuZXcgVUlMYXllcih0aGlzLCBuYW1lKTtcblxuICAgICAgICB0aGlzLnVpTGF5ZXJzLmFkZChuYW1lLCBsYXllcik7XG5cbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsYXllciBmcm9tIHRoZSBzY2VuZSBieSBuYW1lIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBUaGlzIGNhbiBiZSBhIExheWVyIG9yIGFueSBvZiBpdHMgc3ViY2xhc3Nlc1xuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBMYXllciBmb3VuZCB3aXRoIHRoYXQgbmFtZVxuICAgICAqL1xuICAgIGdldExheWVyKG5hbWU6IHN0cmluZyk6IExheWVyIHtcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVycy5nZXQobmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbGxheExheWVycy5nZXQobmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51aUxheWVycy5nZXQobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBgUmVxdWVzdGVkIGxheWVyICR7bmFtZX0gZG9lcyBub3QgZXhpc3QuYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgUGFyYWxsYXhMYXllclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBhIFBhcmFsbGF4TGF5ZXJcbiAgICAgKi9cbiAgICBpc1BhcmFsbGF4TGF5ZXIobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsYXllciBpcyBhIFVJTGF5ZXJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgbGF5ZXIgaXMgUGFyYWxsYXhMYXllclxuICAgICAqL1xuICAgIGlzVUlMYXllcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWlMYXllcnMuaGFzKG5hbWUpO1xuICAgIH0gICAgXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiBvZiB0aGlzIG5vZGUgd2l0aCByZXNwZWN0IHRvIGNhbWVyYSBzcGFjZSAoZHVlIHRvIHRoZSB2aWV3cG9ydCBtb3ZpbmcpLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgYWZmZWN0ZWQgYnkgdGhlIHBhcmFsbGF4IGxldmVsIG9mIHRoZSBAcmVmZXJlbmNlW0xheWVyXSB0aGUgbm9kZSBpcyBvbi5cbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVjayB0aGUgdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHRyYW5zbGF0aW9uIG9mIHZpZXdwb3J0IHdpdGggcmVzcGVjdCB0byB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGU6IEdhbWVOb2RlKTogVmVjMiB7XG4gICAgICAgIGxldCBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcblxuICAgICAgICBpZihsYXllciBpbnN0YW5jZW9mIFBhcmFsbGF4TGF5ZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBVSUxheWVyKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0LmdldE9yaWdpbigpLm11bHQobGF5ZXIucGFyYWxsYXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luKCk7XG4gICAgICAgIH1cblx0fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgbGV2ZWwgb2YgdGhlIHZpZXdcbiAgICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcbiAgICAqL1xuXHRnZXRWaWV3U2NhbGUoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVmlld3BvcnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBWaWV3cG9ydFxuICAgICAqL1xuICAgIGdldFZpZXdwb3J0KCk6IFZpZXdwb3J0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgd29ybGQgc2l6ZSBvZiB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIHdvcmxkIHNpemUgaW4gYSBWZWMyXG4gICAgICovXG4gICAgZ2V0V29ybGRTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgU2NlbmVHcmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBTY2VuZUdyYXBoXG4gICAgICovXG4gICAgZ2V0U2NlbmVHcmFwaCgpOiBTY2VuZUdyYXBoIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVHcmFwaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBQaHlzaWNzTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBQaHlzaWNzTWFuYWdlclxuICAgICAqL1xuICAgIGdldFBoeXNpY3NNYW5hZ2VyKCk6IFBoeXNpY3NNYW5hZ2VyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGh5c2ljc01hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTmF2aWdhdGlvbk1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgTmF2aWdhdGlvbk1hbmFnZXJcbiAgICAgKi9cbiAgICBnZXROYXZpZ2F0aW9uTWFuYWdlcigpOiBOYXZpZ2F0aW9uTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdk1hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgQUlNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIEFJTWFuYWdlclxuICAgICAqL1xuICAgIGdldEFJTWFuYWdlcigpOiBBSU1hbmFnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5haU1hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIElEIGZvciBhIEdhbWVOb2RlXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBJRFxuICAgICAqL1xuICAgIGdlbmVyYXRlSWQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVNYW5hZ2VyLmdlbmVyYXRlSWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBUaWxlbWFwIGluIHRoaXMgU2NlbmVcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgVGlsZW1hcFxuICAgICAqIEByZXR1cm5zIFRoZSBUaWxlbWFwLCBpZiBvbmUgdGhpcyBuYW1lIGV4aXN0cywgb3RoZXJ3aXNlIG51bGxcbiAgICAgKi9cbiAgICBnZXRUaWxlbWFwKG5hbWU6IHN0cmluZyk6IFRpbGVtYXAge1xuICAgICAgICBmb3IobGV0IHRpbGVtYXAgb2YgdGhpcyAudGlsZW1hcHMpe1xuICAgICAgICAgICAgaWYodGlsZW1hcC5uYW1lID09PSBuYW1lKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlsZW1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4vU2NlbmVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyXCI7XG5pbXBvcnQgTWVtb3J5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL01lbW9yeVV0aWxzXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuXG4vKipcbiAqIFRoZSBTY2VuZU1hbmFnZXIgYWN0cyBhcyBhbiBpbnRlcmZhY2UgdG8gY3JlYXRlIFNjZW5lcywgYW5kIGhhbmRsZXMgdGhlIGxpZmVjeWNsZSBtZXRob2RzIG9mIFNjZW5lcy5cbiAqIEl0IGdpdmVzIFNjZW5lcyBhY2Nlc3MgdG8gaW5mb3JtYXRpb24gdGhleSBuZWVkIGZyb20gdGhlIEByZWZlcmVuY2VbR2FtZV0gY2xhc3Mgd2hpbGUga2VlcGluZyBhIGxheWVyIG9mIHNlcGFyYXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lTWFuYWdlciB7XG5cdC8qKiBUaGUgY3VycmVudCBTY2VuZSBvZiB0aGUgZ2FtZSAqL1xuXHRwcm90ZWN0ZWQgY3VycmVudFNjZW5lOiBTY2VuZTtcblxuXHQvKiogVGhlIFZpZXdwb3J0IG9mIHRoZSBnYW1lICovXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XG5cblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG5cdC8qKiBBIGNvdW50ZXIgdG8ga2VlcCB0cmFjayBvZiBnYW1lIGlkcyAqL1xuXHRwcm90ZWN0ZWQgaWRDb3VudGVyOiBudW1iZXI7XG5cblx0LyoqIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIG9mIHRoZSBnYW1lICovXG5cdHByb3RlY3RlZCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xuXG5cdC8qKiBGb3IgY29uc2lzdGVuY3ksIG9ubHkgY2hhbmdlIHNjZW5lcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB1cGRhdGUgY3ljbGUgKi9cblx0cHJvdGVjdGVkIHBlbmRpbmdTY2VuZTogU2NlbmU7XG5cdHByb3RlY3RlZCBwZW5kaW5nU2NlbmVJbml0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgU2NlbmVNYW5hZ2VyXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgVmlld3BvcnQgb2YgdGhlIGdhbWVcblx0ICogQHBhcmFtIGdhbWUgVGhlIEdhbWUgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHJlbmRlcmluZ01hbmFnZXIgVGhlIFJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIGdhbWVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcil7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblx0XHR0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG5cdFx0dGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gcmVuZGVyaW5nTWFuYWdlcjtcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XG5cdFx0dGhpcy5wZW5kaW5nU2NlbmUgPSBudWxsO1xuXG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuXHRcdHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEdhbWVFdmVudFR5cGUuQ0hBTkdFX1NDRU5FKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYSBzY2VuZSBhcyB0aGUgbWFpbiBzY2VuZS5cblx0ICogVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSd2ZSBjcmVhdGVkIGEgc3ViY2xhc3Mgb2YgU2NlbmUsIGFuZCB5b3Ugd2FudCB0byBhZGQgaXQgYXMgdGhlIG1haW4gU2NlbmUuXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzY2VuZSB0byBhZGRcblx0ICogQHBhcmFtIGluaXQgQW4gb2JqZWN0IHRvIHBhc3MgdG8gdGhlIGluaXQgZnVuY3Rpb24gb2YgdGhlIG5ldyBzY2VuZVxuXHQgKi9cblx0cHVibGljIGNoYW5nZVRvU2NlbmU8VCBleHRlbmRzIFNjZW5lPihjb25zdHI6IG5ldyAoLi4uYXJnczogYW55KSA9PiBULCBpbml0PzogUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHRoZSBuZXcgc2NlbmUgLSBjaGFuZ2UgaXMgcGVuZGluZyB1bnRpbCBuZXh0IHVwZGF0ZVwiKTtcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG5ldyBjb25zdHIodGhpcy52aWV3cG9ydCwgdGhpcywgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zKTtcblx0XHR0aGlzLnBlbmRpbmdTY2VuZUluaXQgPSBpbml0O1xuXHR9XG5cblx0cHJvdGVjdGVkIGRvU2NlbmVDaGFuZ2UoKXtcblx0XHRjb25zb2xlLmxvZyhcIlBlcmZvcm1pbmcgc2NlbmUgY2hhbmdlXCIpO1xuXHRcdHRoaXMudmlld3BvcnQuc2V0Q2VudGVyKHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54LCB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSk7XG5cdFx0XG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUpe1xuXHRcdFx0Y29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHNjZW5lXCIpXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS51bmxvYWRTY2VuZSgpO1xuXG5cdFx0XHRjb25zb2xlLmxvZyhcIkRlc3Ryb3lpbmcgb2xkIHNjZW5lXCIpO1xuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdGNvbnNvbGUubG9nKFwiVW5sb2FkaW5nIG9sZCByZXNvdXJjZXMuLi5cIik7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIudW5sb2FkQWxsUmVzb3VyY2VzKCk7XG5cblx0XHQvLyBNYWtlIHRoZSBwZW5kaW5nIHNjZW5lIHRoZSBjdXJyZW50IG9uZVxuXHRcdHRoaXMuY3VycmVudFNjZW5lID0gdGhpcy5wZW5kaW5nU2NlbmU7XG5cblx0XHQvLyBNYWtlIHRoZSBwZW5kaW5nIHNjZW5lIG51bGxcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XG5cblx0XHQvLyBJbml0IHRoZSBzY2VuZVxuXHRcdHRoaXMuY3VycmVudFNjZW5lLmluaXRTY2VuZSh0aGlzLnBlbmRpbmdTY2VuZUluaXQpO1xuXG5cdFx0Ly8gRW5xdWV1ZSBhbGwgc2NlbmUgYXNzZXQgbG9hZHNcblx0XHR0aGlzLmN1cnJlbnRTY2VuZS5sb2FkU2NlbmUoKTtcblxuXHRcdC8vIExvYWQgYWxsIGFzc2V0c1xuXHRcdGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgU2NlbmUgTG9hZFwiKTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgU2NlbmVcIik7XG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zdGFydFNjZW5lKCk7XG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zZXRSdW5uaW5nKHRydWUpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZW5kZXJpbmdNYW5hZ2VyLnNldFNjZW5lKHRoaXMuY3VycmVudFNjZW5lKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRFxuXHQgKiBAcmV0dXJucyBBIG5ldyBJRFxuXHQgKi9cblx0cHVibGljIGdlbmVyYXRlSWQoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5pZENvdW50ZXIrKztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIHRoZSBjdXJyZW50IFNjZW5lXG5cdCAqL1xuXHRwdWJsaWMgcmVuZGVyKCk6IHZvaWQge1xuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lKXtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnJlbmRlcigpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjdXJyZW50IFNjZW5lXG5cdCAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWVzdGVwIG9mIHRoZSBTY2VuZVxuXHQgKi9cblx0cHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XG5cdFx0d2hpbGUgKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcblx0XHRcdGxldCBldiA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XG5cdFx0XHRpZiAoZXYudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5DSEFOR0VfU0NFTkUpIHRoaXMuY2hhbmdlVG9TY2VuZShldi5kYXRhLmdldChcInNjZW5lXCIpLCBldi5kYXRhLmdldChcImluaXRcIikpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMucGVuZGluZ1NjZW5lICE9PSBudWxsKXtcblx0XHRcdHRoaXMuZG9TY2VuZUNoYW5nZSgpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmlzUnVubmluZygpKXtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnVwZGF0ZShkZWx0YVQpO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBBcnJheVV0aWxzIGZyb20gXCIuLi9VdGlscy9BcnJheVV0aWxzXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogVGhlIG9wdGlvbnMgdG8gZ2l2ZSBhIEByZWZlcmVuY2VbU2NlbmVdIGZvciBpbml0aWFsaXphdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZU9wdGlvbnMge1xuICAgIHBoeXNpY3M6IHtcbiAgICAgICAgZ3JvdXBzOiBBcnJheTxzdHJpbmc+LFxuICAgICAgICBjb2xsaXNpb25zOiBBcnJheTxBcnJheTxudW1iZXI+PjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2Uob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFNjZW5lT3B0aW9uc3tcbiAgICAgICAgbGV0IHNPcHQgPSBuZXcgU2NlbmVPcHRpb25zKCk7XG5cbiAgICAgICAgaWYob3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgc09wdC5waHlzaWNzID0ge2dyb3VwczogdW5kZWZpbmVkLCBjb2xsaXNpb25zOiB1bmRlZmluZWR9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc09wdC5waHlzaWNzID0gb3B0aW9ucy5waHlzaWNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNPcHQ7XG4gICAgfVxufSIsImltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi9WaWV3cG9ydFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IGludGVyZmFjZSBvZiBhIFNjZW5lR3JhcGguXG4gKiBFeHBvc2VzIG1ldGhvZHMgZm9yIHVzZSBieSBvdGhlciBjb2RlLCBidXQgbGVhdmVzIHRoZSBpbXBsZW1lbnRhdGlvbiB1cCB0byB0aGUgc3ViY2xhc3Nlcy5cbiAqIFRoZSBTY2VuZUdyYXBoIG1hbmFnZXMgdGhlIHBvc2l0aW9ucyBvZiBhbGwgR2FtZU5vZGVzLCBhbmQgY2FuIGVhc2lseSBwcnVuZSBhIHZpc2libGUgc2V0IGZvciByZW5kZXJpbmcuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNjZW5lR3JhcGgge1xuXHQvKipcdEEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCAqL1xuXHRwcm90ZWN0ZWQgdmlld3BvcnQ6IFZpZXdwb3J0O1xuXHQvKipcdEEgbWFwIG9mIENhbnZhc05vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xuXHRwcm90ZWN0ZWQgbm9kZU1hcDogQXJyYXk8Q2FudmFzTm9kZT47XG5cdC8qKiBBIGNvdW50ZXIgb2YgSURzIGZvciBub2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cblx0cHJvdGVjdGVkIGlkQ291bnRlcjogbnVtYmVyO1xuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoaXMgU2NlbmVHcmFwaCBiZWxvbmdzIHRvICovXG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgU2NlbmVHcmFwaFxuXHQgKiBAcGFyYW0gdmlld3BvcnQgVGhlIHZpZXdwb3J0XG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cblx0ICovXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZTogU2NlbmUpe1xuXHRcdHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XG5cdFx0dGhpcy5ub2RlTWFwID0gbmV3IEFycmF5KCk7XG5cdFx0dGhpcy5pZENvdW50ZXIgPSAwO1xuICAgIH1cblxuXHQvKipcblx0ICogQWRkIGEgbm9kZSB0byB0aGUgU2NlbmVHcmFwaFxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgQ2FudmFzTm9kZSB0byBhZGQgdG8gdGhlIFNjZW5lR3JhcGhcblx0ICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGggSUQgb2YgdGhpcyBuZXdseSBhZGRlZCBDYW52YXNOb2RlXG5cdCAqL1xuICAgIGFkZE5vZGUobm9kZTogQ2FudmFzTm9kZSk6IG51bWJlciB7XG5cdFx0dGhpcy5ub2RlTWFwW25vZGUuaWRdID0gbm9kZTtcblx0XHR0aGlzLmFkZE5vZGVTcGVjaWZpYyhub2RlLCB0aGlzLmlkQ291bnRlcik7XG5cdFx0dGhpcy5pZENvdW50ZXIgKz0gMTtcblx0XHRyZXR1cm4gdGhpcy5pZENvdW50ZXIgLSAxO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBvdmVycmlkYWJsZSBtZXRob2QgdG8gYWRkIGEgQ2FudmFzTm9kZSB0byB0aGUgc3BlY2lmaWMgZGF0YSBzdHJ1Y3R1cmUgb2YgdGhlIFNjZW5lR3JhcGhcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gYWRkIHRvIHRoZSBkYXRhIHN0cnVjdHVyZVxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBDYW52YXNOb2RlXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgYWRkTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBTY2VuZUdyYXBoXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuXHQgKi9cbiAgICByZW1vdmVOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcblx0XHQvLyBGaW5kIGFuZCByZW1vdmUgbm9kZSBpbiBPKG4pXG5cdFx0dGhpcy5ub2RlTWFwW25vZGUuaWRdID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucmVtb3ZlTm9kZVNwZWNpZmljKG5vZGUsIG5vZGUuaWQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gb2YgcmVtb3ZpbmcgYSBub2RlXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBub2RlIHRvIHJlbW92ZVxuXHQgKi9cblx0cHJvdGVjdGVkIGFic3RyYWN0IHJlbW92ZU5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZDtcblxuXHQvKipcblx0ICogR2V0IGEgc3BlY2lmaWMgbm9kZSB1c2luZyBpdHMgaWRcblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgQ2FudmFzTm9kZSB0byByZXRyaWV2ZVxuXHQgKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIHRoaXMgSURcblx0ICovXG5cdGdldE5vZGUoaWQ6IG51bWJlcik6IENhbnZhc05vZGUge1xuXHRcdHJldHVybiB0aGlzLm5vZGVNYXBbaWRdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5vZGVzIGF0IHNwZWNpZmljIGNvb3JkaW5hdGVzXG5cdCAqIEBwYXJhbSB2ZWNPclggVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb24sIG9yIHRoZSBjb29yZGluYXRlcyBpbiBhIFZlYzJcblx0ICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb25cblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgZm91bmQgYXQgdGhlIHBvc2l0aW9uIHByb3ZpZGVkXG5cdCAqL1xuICAgIGdldE5vZGVzQXQodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZXNBdENvb3Jkcyh2ZWNPclgueCwgdmVjT3JYLnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXROb2Rlc0F0Q29vcmRzKHZlY09yWCwgeSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5vZGVzIHRoYXQgb3ZlcmxhcCBhIHNwZWNpZmljIGJvdW5kYXJ5XG5cdCAqIEBwYXJhbSBib3VuZGFyeSBUaGUgcmVnaW9uIHRvIGNoZWNrXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIGZvdW5kIG92ZXJsYXBwaW5nIHRoZSBwcm92aWRlZCBib3VuZGFyeVxuXHQgKi9cblx0YWJzdHJhY3QgZ2V0Tm9kZXNJblJlZ2lvbihib3VuZGFyeTogQUFCQik6IEFycmF5PENhbnZhc05vZGU+O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXG5cdCAqIEByZXR1cm5zIEFuIEFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXG5cdCAqL1xuXHRnZXRBbGxOb2RlcygpOiBBcnJheTxDYW52YXNOb2RlPiB7XG5cdFx0bGV0IGFyciA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm5vZGVNYXAubGVuZ3RoOyBpKyspe1xuXHRcdFx0aWYodGhpcy5ub2RlTWFwW2ldICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRhcnIucHVzaCh0aGlzLm5vZGVNYXBbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiBnZXR0aW5nIGEgbm9kZSBhdCBjZXJ0YWluIGNvb3JkaW5hdGVzXG5cdCAqIEBwYXJhbSB4IFRoZSB4LWNvb3JkaW5hdGVzIG9mIHRoZSBub2RlXG5cdCAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGVzIG9mIHRoZSBub2RlXG5cdCAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBnZXROb2Rlc0F0Q29vcmRzKHg6IG51bWJlciwgeTogbnVtYmVyKTogQXJyYXk8Q2FudmFzTm9kZT47XG5cblx0YWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcblx0XG5cdGFic3RyYWN0IHJlbmRlcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzIGJhc2VkIG9uIHRoZSBAcmVmZXJlbmNlW1ZpZXdwb3J0XVxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCB2aXNpYmxlIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXG5cdCAqL1xuICAgIGFic3RyYWN0IGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT47XG59IiwiaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4vU2NlbmVHcmFwaFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi9WaWV3cG9ydFwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgU2NlbmVHcmFwaCB0aGF0IHNpbXBseSBzdG9yZWQgQ2FudmFzTm9kZXMgaW4gYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lR3JhcGhBcnJheSBleHRlbmRzIFNjZW5lR3JhcGgge1xuICAgIC8qKiBUaGUgbGlzdCBvZiBDYW52YXNOb2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cbiAgICBwcml2YXRlIG5vZGVMaXN0OiBBcnJheTxDYW52YXNOb2RlPjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2NlbmVHcmFwaEFycmF5XG4gICAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSBWaWV3cG9ydFxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lOiBTY2VuZSl7XG4gICAgICAgIHN1cGVyKHZpZXdwb3J0LCBzY2VuZSk7XG5cbiAgICAgICAgdGhpcy5ub2RlTGlzdCA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHByb3RlY3RlZCBhZGROb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLm5vZGVMaXN0LnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHJlbW92ZU5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubm9kZUxpc3QuaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYoaW5kZXggPiAtMSl7XG4gICAgICAgICAgICB0aGlzLm5vZGVMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBnZXROb2Rlc0F0Q29vcmRzKHg6IG51bWJlciwgeTogbnVtYmVyKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKG5vZGUuY29udGFpbnMoeCwgeSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldE5vZGVzSW5SZWdpb24oYm91bmRhcnk6IEFBQkIpOiBBcnJheTxDYW52YXNOb2RlPiB7XG4gICAgICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKGJvdW5kYXJ5Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpKXtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIFN0YXRzLmxvZyhcInNncXVlcnlcIiwgKHQxLXQwKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5ub2RlTGlzdCl7XG4gICAgICAgICAgICBpZighbm9kZS5nZXRMYXllcigpLmlzUGF1c2VkKCkpe1xuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIFN0YXRzLmxvZyhcInNndXBkYXRlXCIsICh0MS10MCkpO1xuICAgIH1cblxuICAgIHJlbmRlcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge31cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xuICAgICAgICBsZXQgdmlzaWJsZVNldCA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xuXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKCFub2RlLmdldExheWVyKCkuaXNIaWRkZW4oKSAmJiBub2RlLnZpc2libGUgJiYgdGhpcy52aWV3cG9ydC5pbmNsdWRlcyhub2RlKSl7XG4gICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpc2libGVTZXQ7XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvUXVldWVcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vSW5wdXQvSW5wdXRcIjtcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XG5cbi8qKlxuICogVGhlIHZpZXdwb3J0IG9mIHRoZSBnYW1lLiBDb3JyZXNwb25kcyB0byB0aGUgdmlzaWJsZSB3aW5kb3cgZGlzcGxheWVkIGluIHRoZSBicm93c2VyLlxuICogVGhlIHZpZXdwb3J0IGtlZXBzIHRyYWNrIG9mIGl0cyBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB3b3JsZCwgYW5kIGNhbiBhY3QgYXMgYSBjYW1lcmEgdG8gZm9sbG93IG9iamVjdHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdwb3J0IHtcbiAgICAvKiogVGhlIEFBQkIgdGhhdCBjb250YWlucyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHZpZXdwb3J0IHZpZXcgKi9cbiAgICBwdWJsaWMgdmlldzogQUFCQjtcbiAgICAvKiogVGhlIGJvdW5kYXJ5IGZvciB0aGUgdmlld3BvcnQuIFRoaXMgcmVwcmVzZW50cyB0aGUgbGltaXRzIHRvIHdoZXJlIHRoZSB2aWV3cG9ydCBjYW4gZ28gKi9cbiAgICBwcml2YXRlIGJvdW5kYXJ5OiBBQUJCO1xuICAgIC8qKiBUaGUgR2FtZU5vZGUgdGhlIFZpZXdwb3J0IGlzIGZvbGxvd2luZyAqL1xuICAgIHByaXZhdGUgZm9sbG93aW5nOiBHYW1lTm9kZTtcbiAgICAvKiogVGhlIHBvc2l0aW9uIHRoZSBHYW1lTm9kZSBpcyBmb2N1c2luZyBvbi4gVGhpcyBpcyBvdmVycmlkZGVuIGlmIFwiZm9sbG93aW5nXCIgaXMgc2V0LiAqL1xuICAgIHByaXZhdGUgZm9jdXM6IFZlYzI7XG5cbiAgICAvKiogQSBxdWV1ZSBvZiBwcmV2aW91cyBwb3NpdGlvbnMgb2Ygd2hhdCB0aGlzIHZpZXdwb3J0IGlzIGZvbGxvd2luZy4gVXNlZCBmb3Igc21vb3RoaW5nIHZpZXdwb3J0IG1vdmVtZW50ICovXG4gICAgcHVibGljIGxhc3RQb3NpdGlvbnM6IFF1ZXVlPFZlYzI+O1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgcG9zaXRpb25zIHRoaXMgdmlld3BvcnQgdHJhY2tzICovXG4gICAgcHJpdmF0ZSBzbW9vdGhpbmdGYWN0b3I6IG51bWJlcjtcblxuICAgIC8qKiBBIGJvb2xlYW4gdGhhIHJlcHJlc2VudHMgd2hldGhlciB0aGUgcGxheWVyIGNhbiB6b29tIGJ5IHNjcm9sbGluZyB3aXRoIHRoZSBtb3VzZSB3aGVlbCAqL1xuICAgIHByaXZhdGUgc2Nyb2xsWm9vbUVuYWJsZWQ6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIGFtb3VudCB0aGF0IGlzIHpvb21lZCBpbiBvciBvdXQuICovXG4gICAgcHJpdmF0ZSBaT09NX0ZBQ1RPUjogbnVtYmVyID0gMS4yO1xuXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBjYW52YXMgKi9cbiAgICBwcml2YXRlIGNhbnZhc1NpemU6IFZlYzI7XG5cbiAgICBjb25zdHJ1Y3RvcihjYW52YXNTaXplOiBWZWMyLCB6b29tTGV2ZWw6IG51bWJlcil7XG4gICAgICAgIGxldCBwb3N0aW9uID0gbmV3IFZlYzIoMjUsNDUwKVxuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgQUFCQihwb3N0aW9uKTtcbiAgICAgICAgdGhpcy5ib3VuZGFyeSA9IG5ldyBBQUJCKFZlYzIuWkVSTywgVmVjMi5aRVJPKTtcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuc21vb3RoaW5nRmFjdG9yID0gMTA7XG4gICAgICAgIHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW52YXNTaXplID0gVmVjMi5aRVJPO1xuICAgICAgICB0aGlzLmZvY3VzID0gVmVjMi5aRVJPO1xuXG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzXG4gICAgICAgIHRoaXMuc2V0Q2FudmFzU2l6ZShjYW52YXNTaXplKTtcblxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgIHRoaXMuc2V0U2l6ZShjYW52YXNTaXplKTtcbiAgICAgICAgdGhpcy5zZXRab29tTGV2ZWwoem9vbUxldmVsKTtcblxuICAgICAgICAvLyBTZXQgdGhlIGNlbnRlciAoYW5kIG1ha2UgdGhlIHZpZXdwb3J0IHN0YXkgdGhlcmUpXG4gICAgICAgIHRoaXMuc2V0Q2VudGVyKHRoaXMudmlldy5oYWxmU2l6ZS5jbG9uZSgpKTtcbiAgICAgICAgdGhpcy5zZXRGb2N1cyh0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XG4gICAgfVxuXG4gICAgLyoqIEVuYWJsZXMgdGhlIHZpZXdwb3J0IHRvIHpvb20gaW4gYW5kIG91dCAqL1xuICAgIGVuYWJsZVpvb20oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxuICAgICAqL1xuICAgIGdldENlbnRlcigpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5jZW50ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWMyIHdpdGggdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyBUaGUgdG9wIGxlZnQgY29ybmRlciBvZiB0aGUgVmllcG9ydCBhcyBhIFZlYzJcbiAgICAgKi9cbiAgICBnZXRPcmlnaW4oKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnZpZXcubGVmdCwgdGhpcy52aWV3LnRvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVnaW9uIHZpc2libGUgdG8gdGhpcyB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIFRoZSBBQUJCIGNvbnRhaW5pbmcgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIGdldFZpZXcoKTogQUFCQiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gdmVjT3JYIFRoZSBuZXcgcG9zaXRpb24gb3IgdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICovXG4gICAgc2V0Q2VudGVyKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xuICAgICAgICBsZXQgcG9zOiBWZWMyO1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuICAgICAgICAgICAgcG9zID0gdmVjT3JYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gbmV3IFZlYzIodmVjT3JYLCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIgPSBwb3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQgYXMgYSBWZWMyXG4gICAgICogQHJldHVybnMgVGhlIGhhbGYtc2l6ZSBvZiB0aGUgdmlld3BvcnQgYXMgYSBWZWMyXG4gICAgICovXG4gICAgZ2V0SGFsZlNpemUoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SGFsZlNpemUoKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gdmVjT3JYIFRoZSBuZXcgd2lkdGggb2YgdGhlIHZpZXdwb3J0IG9yIHRoZSBuZXcgc2l6ZSBhcyBhIFZlYzJcbiAgICAgKiBAcGFyYW0geSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBzZXRTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKHZlY09yWC5zY2FsZWQoMS8yKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZShuZXcgVmVjMih2ZWNPclgvMiwgeS8yKSk7XG5cdFx0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhbGYtc2l6ZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gdmVjT3JYIFRoZSBuZXcgaGFsZi13aWR0aCBvZiB0aGUgdmlld3BvcnQgb3IgdGhlIG5ldyBoYWxmLXNpemUgYXMgYSBWZWMyXG4gICAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgc2V0SGFsZlNpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUodmVjT3JYLmNsb25lKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYLCB5KSk7XG5cdFx0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZpZXdwb3J0IHdpdGggdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgQ2FudmFzXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcywgb3IgdGhlIGNhbnZhcyBzaXplIGFzIGEgVmVjMlxuICAgICAqIEBwYXJhbSB5IFRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIHNldENhbnZhc1NpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHR0aGlzLmNhbnZhc1NpemUgPSB2ZWNPclguY2xvbmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jYW52YXNTaXplID0gbmV3IFZlYzIodmVjT3JYLCB5KTtcblx0XHR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxuICAgICAqL1xuICAgIHNldFpvb21MZXZlbCh6b29tOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52aWV3LmhhbGZTaXplLmNvcHkodGhpcy5jYW52YXNTaXplLnNjYWxlZCgxL3pvb20vMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHJldHVybnMgVGhlIHpvb20gbGV2ZWxcbiAgICAgKi9cbiAgICBnZXRab29tTGV2ZWwoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzU2l6ZS54L3RoaXMudmlldy5ody8yXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc21vb3RoaW5nIGZhY3RvciBmb3IgdGhlIHZpZXdwb3J0IG1vdmVtZW50LlxuICAgICAqIEBwYXJhbSBzbW9vdGhpbmdGYWN0b3IgVGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldFNtb290aGluZ0ZhY3RvcihzbW9vdGhpbmdGYWN0b3I6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZihzbW9vdGhpbmdGYWN0b3IgPCAxKSBzbW9vdGhpbmdGYWN0b3IgPSAxO1xuICAgICAgICB0aGlzLnNtb290aGluZ0ZhY3RvciA9IHNtb290aGluZ0ZhY3RvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgdmlld3BvcnQgdG8gZm9jdXMgb24gYSBwb2ludC4gT3ZlcmlkZGVuIGJ5IFwiZm9sbG93aW5nXCIuXG4gICAgICogQHBhcmFtIGZvY3VzIFRoZSBwb2ludCB0aGUgIHZpZXdwb3J0IHNob3VsZCBmb2N1cyBvblxuICAgICAqL1xuICAgIHNldEZvY3VzKGZvY3VzOiBWZWMyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXMuY29weShmb2N1cyk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgQ2FudmFzTm9kZSBpcyBpbnNpZGUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBub2RlIGlzIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydCwgZmFsc2UgaWYgbm90XG4gICAgICovXG4gICAgaW5jbHVkZXMobm9kZTogQ2FudmFzTm9kZSk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgcGFyYWxsYXggPSBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyIHx8IG5vZGUuZ2V0TGF5ZXIoKSBpbnN0YW5jZW9mIFVJTGF5ZXIgPyAoPFBhcmFsbGF4TGF5ZXI+bm9kZS5nZXRMYXllcigpKS5wYXJhbGxheCA6IG5ldyBWZWMyKDEsIDEpO1xuICAgICAgICBsZXQgY2VudGVyID0gdGhpcy52aWV3LmNlbnRlci5jbG9uZSgpO1xuICAgICAgICB0aGlzLnZpZXcuY2VudGVyLm11bHQocGFyYWxsYXgpO1xuICAgICAgICBsZXQgb3ZlcmxhcHMgPSB0aGlzLnZpZXcub3ZlcmxhcHMobm9kZS5ib3VuZGFyeSk7XG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIgPSBjZW50ZXJcbiAgICAgICAgcmV0dXJuIG92ZXJsYXBzO1xuICAgIH1cblxuXHQvLyBUT0RPOiBQdXQgc29tZSBlcnJvciBoYW5kbGluZyBvbiB0aGlzIGZvciB0cnlpbmcgdG8gbWFrZSB0aGUgYm91bmRzIHRvbyBzbWFsbCBmb3IgdGhlIHZpZXdwb3J0XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSBhdXRvbWF0aWNhbGx5LCBvciBzaG91bGQgY29uc2lkZXIgdGhlIGFzcGVjdCByYXRpbyBvciBzb21ldGhpbmdcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib3VuZHMgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIGxvd2VyWCBUaGUgbGVmdCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBsb3dlclkgVGhlIHRvcCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB1cHBlclggVGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHVwcGVyWSBUaGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgc2V0Qm91bmRzKGxvd2VyWDogbnVtYmVyLCBsb3dlclk6IG51bWJlciwgdXBwZXJYOiBudW1iZXIsIHVwcGVyWTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBod2lkdGggPSAodXBwZXJYIC0gbG93ZXJYKS8yO1xuICAgICAgICBsZXQgaGhlaWdodCA9ICh1cHBlclkgLSBsb3dlclkpLzI7XG4gICAgICAgIGxldCB4ID0gbG93ZXJYICsgaHdpZHRoO1xuICAgICAgICBsZXQgeSA9IGxvd2VyWSArIGhoZWlnaHQ7XG4gICAgICAgIHRoaXMuYm91bmRhcnkuY2VudGVyLnNldCh4LCB5KTtcbiAgICAgICAgdGhpcy5ib3VuZGFyeS5oYWxmU2l6ZS5zZXQoaHdpZHRoLCBoaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRoZSB2aWV3cG9ydCBmb2xsb3cgdGhlIHNwZWNpZmllZCBHYW1lTm9kZVxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBHYW1lTm9kZSB0byBmb2xsb3dcbiAgICAgKi9cbiAgICBmb2xsb3cobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2xsb3dpbmcgPSBub2RlO1xuICAgIH1cblxuICAgIHVwZGF0ZVZpZXcoKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMubGFzdFBvc2l0aW9ucy5nZXRTaXplKCkgPiB0aGlzLnNtb290aGluZ0ZhY3Rvcil7XG4gICAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZGVxdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIGF2ZXJhZ2Ugb2YgdGhlIGxhc3QgMTAgcG9zaXRpb25zXG4gICAgICAgIGxldCBwb3MgPSBWZWMyLlpFUk87XG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5mb3JFYWNoKHBvc2l0aW9uID0+IHBvcy5hZGQocG9zaXRpb24pKTtcbiAgICAgICAgcG9zLnNjYWxlKDEvdGhpcy5sYXN0UG9zaXRpb25zLmdldFNpemUoKSk7XG5cbiAgICAgICAgLy8gU2V0IHRoaXMgcG9zaXRpb24gZWl0aGVyIHRvIHRoZSBvYmplY3Qgb3IgdG8gaXRzIGJvdW5kc1xuICAgICAgICBwb3MueCA9IE1hdGhVdGlscy5jbGFtcChwb3MueCwgdGhpcy5ib3VuZGFyeS5sZWZ0ICsgdGhpcy52aWV3Lmh3LCB0aGlzLmJvdW5kYXJ5LnJpZ2h0IC0gdGhpcy52aWV3Lmh3KTtcbiAgICAgICAgcG9zLnkgPSBNYXRoVXRpbHMuY2xhbXAocG9zLnksIHRoaXMuYm91bmRhcnkudG9wICsgdGhpcy52aWV3LmhoLCB0aGlzLmJvdW5kYXJ5LmJvdHRvbSAtIHRoaXMudmlldy5oaCk7XG5cbiAgICAgICAgLy8gQXNzdXJlIHRoZXJlIGFyZSBubyBsaW5lcyBpbiB0aGUgdGlsZW1hcFxuICAgICAgICBwb3MueCA9IE1hdGguZmxvb3IocG9zLngpO1xuICAgICAgICBwb3MueSA9IE1hdGguZmxvb3IocG9zLnkpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlci5jb3B5KHBvcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIElmIHpvb20gaXMgZW5hYmxlZFxuICAgICAgICBpZih0aGlzLnNjcm9sbFpvb21FbmFibGVkKXtcbiAgICAgICAgICAgIGlmKElucHV0LmRpZEp1c3RTY3JvbGwoKSl7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTaXplID0gdGhpcy52aWV3LmdldEhhbGZTaXplKCkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBpZihJbnB1dC5nZXRTY3JvbGxEaXJlY3Rpb24oKSA8IDApe1xuICAgICAgICAgICAgICAgICAgICAvLyBab29tIGluXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnNjYWxlKDEvdGhpcy5aT09NX0ZBQ1RPUik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWm9vbSBvdXRcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUuc2NhbGUodGhpcy5aT09NX0ZBQ1RPUik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudFNpemUueCA+IHRoaXMuYm91bmRhcnkuaHcpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjdG9yID0gdGhpcy5ib3VuZGFyeS5ody9jdXJyZW50U2l6ZS54O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS54ID0gdGhpcy5ib3VuZGFyeS5odztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUueSAqPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoY3VycmVudFNpemUueSA+IHRoaXMuYm91bmRhcnkuaGgpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjdG9yID0gdGhpcy5ib3VuZGFyeS5oaC9jdXJyZW50U2l6ZS55O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS55ID0gdGhpcy5ib3VuZGFyeS5oaDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUueCAqPSBmYWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldEhhbGZTaXplKGN1cnJlbnRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHZpZXdwb3J0IGlzIGZvbGxvd2luZyBhbiBvYmplY3RcbiAgICAgICAgaWYodGhpcy5mb2xsb3dpbmcpe1xuICAgICAgICAgICAgLy8gVXBkYXRlIG91ciBsaXN0IG9mIHByZXZpb3VzIHBvc2l0aW9uc1xuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmVucXVldWUodGhpcy5mb2xsb3dpbmcucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZW5xdWV1ZSh0aGlzLmZvY3VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvQ29sbGVjdGlvbnMvTWFwXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuXG4vKipcbiAqIE1hbmFnZXMgYW55IHNvdW5kcyBvciBtdXNpYyBuZWVkZWQgZm9yIHRoZSBnYW1lLlxuICogVGhyb3VnaCB0aGUgRXZlbnRRdWV1ZSwgZXhwb3NlcyBpbnRlcmZhY2UgdG8gcGxheSBzb3VuZHMgc28gR2FtZU5vZGVzIGNhbiBhY3RpdmF0ZSBzb3VuZHMgd2l0aG91dFxuICogbmVlZGluZyBkaXJlY3QgcmVmZXJlbmNlcyB0byB0aGUgYXVkaW8gc3lzdGVtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvTWFuYWdlciB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEF1ZGlvTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgZXZlbnQgcmVjZWl2ZXIgb2YgdGhpcyBBdWRpb01hbmFnZXIgKi9cbiAgICBwcml2YXRlIHJlY2VpdmVyOiBSZWNlaXZlcjtcblxuICAgIC8qKiBBIE1hcCBvZiB0aGUgbmFtZXMgb2YgY3VycmVudGx5IHBsYXlpbmcgKG9yIHBhdXNlZCkgc291bmRzIHRvIHRoZWlyIEF1ZGlvQnVmZmVycyAqL1xuICAgIHByaXZhdGUgY3VycmVudFNvdW5kczogTWFwPEF1ZGlvQnVmZmVyU291cmNlTm9kZT47XG5cbiAgICBwcml2YXRlIGF1ZGlvQ3R4OiBBdWRpb0NvbnRleHQ7XG5cbiAgICBwcml2YXRlIGdhaW5Ob2RlczogQXJyYXk8R2Fpbk5vZGU+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmluaXRBdWRpbygpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFtcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9TT1VORCxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9TRlgsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLk1VVEVfQ0hBTk5FTCxcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuVU5NVVRFX0NIQU5ORUxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuY3VycmVudFNvdW5kcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLmdhaW5Ob2RlcyA9IG5ldyBBcnJheTxHYWluTm9kZT4oTUFYX0FVRElPX0NIQU5ORUxTKTtcbiAgICAgICAgdGhpcy5pbml0R2Fpbk5vZGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbnN0YW5jZSBvZiB0aGUgQXVkaW9NYW5hZ2VyIGNsYXNzIG9yIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm9uZSBleGlzdHNcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9NYW5hZ2VyXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBBdWRpb01hbmFnZXIge1xuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IEF1ZGlvTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSB3ZWJBdWRpbyBjb250ZXh0XG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0QXVkaW8oKTogdm9pZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dDsvLyB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0OyBcbiAgICAgICAgICAgIHRoaXMuYXVkaW9DdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7IFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dlYiBBdWRpbyBBUEkgc3VjY2Vzc2Z1bGx5IGxvYWRlZCcpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViIEF1ZGlvIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpOyBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdEdhaW5Ob2RlcygpOiB2b2lkIHtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IE1BWF9BVURJT19DSEFOTkVMUzsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2ldID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVHYWluKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1ZGlvIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9Db250ZXh0XG4gICAgICovXG4gICAgcHVibGljIGdldEF1ZGlvQ29udGV4dCgpOiBBdWRpb0NvbnRleHQge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWRpb0N0eDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBBY2NvcmRpbmcgdG8gdGhlIE1ETiwgY3JlYXRlIGEgbmV3IHNvdW5kIGZvciBldmVyeSBjYWxsOlxuXG4gICAgICAgIEFuIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBjYW4gb25seSBiZSBwbGF5ZWQgb25jZTsgYWZ0ZXIgZWFjaCBjYWxsIHRvIHN0YXJ0KCksIHlvdSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBub2RlXG4gICAgICAgIGlmIHlvdSB3YW50IHRvIHBsYXkgdGhlIHNhbWUgc291bmQgYWdhaW4uIEZvcnR1bmF0ZWx5LCB0aGVzZSBub2RlcyBhcmUgdmVyeSBpbmV4cGVuc2l2ZSB0byBjcmVhdGUsIGFuZCB0aGVcbiAgICAgICAgYWN0dWFsIEF1ZGlvQnVmZmVycyBjYW4gYmUgcmV1c2VkIGZvciBtdWx0aXBsZSBwbGF5cyBvZiB0aGUgc291bmQuIEluZGVlZCwgeW91IGNhbiB1c2UgdGhlc2Ugbm9kZXMgaW4gYVxuICAgICAgICBcImZpcmUgYW5kIGZvcmdldFwiIG1hbm5lcjogY3JlYXRlIHRoZSBub2RlLCBjYWxsIHN0YXJ0KCkgdG8gYmVnaW4gcGxheWluZyB0aGUgc291bmQsIGFuZCBkb24ndCBldmVuIGJvdGhlciB0b1xuICAgICAgICBob2xkIGEgcmVmZXJlbmNlIHRvIGl0LiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgYXQgYW4gYXBwcm9wcmlhdGUgdGltZSwgd2hpY2ggd29uJ3QgYmVcbiAgICAgICAgdW50aWwgc29tZXRpbWUgYWZ0ZXIgdGhlIHNvdW5kIGhhcyBmaW5pc2hlZCBwbGF5aW5nLlxuICAgICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzb3VuZCBmcm9tIHRoZSBrZXkgb2YgYSBsb2FkZWQgYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIGF1ZGlvIGZpbGUgdG8gY3JlYXRlIGEgbmV3IHNvdW5kIGZvclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIEF1ZGlvQnVmZmVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVNvdW5kKGtleTogc3RyaW5nLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCBvcHRpb25zOiBNYXA8YW55Pik6IEF1ZGlvQnVmZmVyU291cmNlTm9kZSB7XG4gICAgICAgIC8vIEdldCBhdWRpbyBidWZmZXJcbiAgICAgICAgbGV0IGJ1ZmZlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEF1ZGlvKGtleSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgc291bmQgc291cmNlXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmF1ZGlvQ3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpOyBcbiAgICAgIFxuICAgICAgICAvLyBUZWxsIHRoZSBzb3VyY2Ugd2hpY2ggc291bmQgdG8gcGxheVxuICAgICAgICBzb3VyY2UuYnVmZmVyID0gYnVmZmVyOyAgICAgICAgICAgICAgIFxuICAgICAgXG4gICAgICAgIC8vIEFkZCBhbnkgYWRkaXRpb25hbCBub2Rlc1xuICAgICAgICBjb25zdCBub2RlczogQXJyYXk8QXVkaW9Ob2RlPiA9IFtzb3VyY2VdO1xuXG4gICAgICAgIC8vIERvIGFueSBhZGRpdGlvbmFsIG5vZGVzIGhlcmU/XG4gICAgICAgIC8vIE9mIGNvdXJzZSwgdGhlcmUgYXJlbid0IGFueSBzdXBwb3J0ZWQgeWV0Li4uXG5cbiAgICAgICAgLy8gQWRkIHRoZSBnYWluIG5vZGUgZm9yIHRoaXMgY2hhbm5lbFxuICAgICAgICBub2Rlcy5wdXNoKHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdKTtcblxuICAgICAgICAvLyBDb25uZWN0IGFueSBub2RlcyBhbG9uZyB0aGUgcGF0aFxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbm9kZXNbaS0xXS5jb25uZWN0KG5vZGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIHNvdXJjZSB0byB0aGUgY29udGV4dCdzIGRlc3RpbmF0aW9uXG4gICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5hdWRpb0N0eC5kZXN0aW5hdGlvbik7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYXkgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzb3VuZCB0byBwbGF5XG4gICAgICogQHBhcmFtIGxvb3AgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBzb3VuZFxuICAgICAqIEBwYXJhbSBob2xkUmVmZXJlbmNlIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3Qgd2Ugd2FudCB0byBob2xkIG9uIHRvIGEgcmVmZXJlbmNlIG9mIHRoZSBhdWRpbyBub2RlLiBUaGlzIGlzIGdvb2QgZm9yIHBsYXlpbmcgbXVzaWMgb24gYSBsb29wIHRoYXQgd2lsbCBldmVudHVhbGx5IG5lZWQgdG8gYmUgc3RvcHBlZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGxheVNvdW5kKGtleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCBvcHRpb25zOiBNYXA8YW55Pik6IHZvaWQge1xuICAgICAgICBsZXQgc291bmQgPSB0aGlzLmNyZWF0ZVNvdW5kKGtleSwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYobG9vcCl7XG4gICAgICAgICAgICBzb3VuZC5sb29wID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhIHJlZmVyZW5jZSBvZiB0aGUgbmV3IHNvdW5kIHRvIGEgbWFwLiBUaGlzIHdpbGwgYWxsb3cgdXMgdG8gc3RvcCBhIGxvb3Bpbmcgb3IgbG9uZyBzb3VuZCBhdCBhIGxhdGVyIHRpbWVcbiAgICAgICAgaWYoaG9sZFJlZmVyZW5jZSl7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTb3VuZHMuYWRkKGtleSwgc291bmQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzb3VuZC5zdGFydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0b3BTb3VuZChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsZXQgc291bmQgPSB0aGlzLmN1cnJlbnRTb3VuZHMuZ2V0KGtleSk7XG4gICAgICAgIGlmKHNvdW5kKXtcbiAgICAgICAgICAgIHNvdW5kLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNvdW5kcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBtdXRlQ2hhbm5lbChjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcbiAgICAgICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdW5tdXRlQ2hhbm5lbChjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcbiAgICAgICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2b2x1bWUgb2YgYSBjaGFubmVsIHVzaW5nIHRoZSBHYWluTm9kZSBmb3IgdGhhdCBjaGFubmVsLiBGb3IgbW9yZVxuICAgICAqIGluZm9ybWF0aW9uIG9uIEdhaW5Ob2Rlcywgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBhdWRpbyBjaGFubmVsIHRvIHNldCB0aGUgdm9sdW1lIGZvclxuICAgICAqIEBwYXJhbSB2b2x1bWUgVGhlIHZvbHVtZSBvZiB0aGUgY2hhbm5lbC4gMCBpcyBtdXRlZC4gVmFsdWVzIGJlbG93IHplcm8gd2lsbCBiZSBzZXQgdG8gemVyby5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0Vm9sdW1lKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUsIHZvbHVtZTogbnVtYmVyKXtcbiAgICAgICAgaWYodm9sdW1lIDwgMCl7XG4gICAgICAgICAgICB2b2x1bWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYW0gPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgYW0uZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sdW1lLCBhbS5hdWRpb0N0eC5jdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgR2Fpbk5vZGUgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKiBMZWFybiBtb3JlIGFib3V0IEdhaW5Ob2RlcyBoZXJlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxuICAgICAqIERPTidUIFVTRSBUSElTIFVOTEVTUyBZT1UgS05PVyBXSEFUIFlPVSdSRSBET0lOR1xuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBjaGFubmVsXG4gICAgICogQHJldHVybnMgVGhlIEdhaW5Ob2RlIGZvciB0aGUgc3BlY2lmaWVkIGNoYW5uZWxcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsR2Fpbk5vZGUoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XG4gICAgICAgIHJldHVybiB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXTtcbiAgICB9XG4gICAgXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIFBsYXkgZWFjaCBhdWRpbyBjbGlwIHJlcXVlc3RlZFxuICAgICAgICAvLyBUT0RPIC0gQWRkIGxvZ2ljIHRvIG1lcmdlIHNvdW5kcyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgb2YgdGhlIHNhbWUga2V5XG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9TT1VORCB8fCBldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMgfHwgZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX1NGWCl7XG4gICAgICAgICAgICAgICAgbGV0IHNvdW5kS2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XG4gICAgICAgICAgICAgICAgbGV0IGxvb3AgPSBldmVudC5kYXRhLmdldChcImxvb3BcIik7XG4gICAgICAgICAgICAgICAgbGV0IGhvbGRSZWZlcmVuY2UgPSBldmVudC5kYXRhLmdldChcImhvbGRSZWZlcmVuY2VcIik7XG5cbiAgICAgICAgICAgICAgICBsZXQgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuREVGQVVMVDtcblxuICAgICAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyl7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLk1VU0lDO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYKXtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuU0ZYO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihldmVudC5kYXRhLmhhcyhcImNoYW5uZWxcIikpe1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucGxheVNvdW5kKHNvdW5kS2V5LCBsb29wLCBob2xkUmVmZXJlbmNlLCBjaGFubmVsLCBldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5TVE9QX1NPVU5EKXtcbiAgICAgICAgICAgICAgICBsZXQgc291bmRLZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BTb3VuZChzb3VuZEtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTVVURV9DSEFOTkVMKXtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVDaGFubmVsKGV2ZW50LmRhdGEuZ2V0KFwiY2hhbm5lbFwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuVU5NVVRFX0NIQU5ORUwpe1xuICAgICAgICAgICAgICAgIHRoaXMudW5tdXRlQ2hhbm5lbChldmVudC5kYXRhLmdldChcImNoYW5uZWxcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBBdWRpb0NoYW5uZWxUeXBlIHtcbiAgICBERUZBVUxUID0gMCxcbiAgICBTRlggPSAxLFxuICAgIE1VU0lDID0gMixcbiAgICBDVVNUT01fMSA9IDMsXG4gICAgQ1VTVE9NXzIgPSA0LFxuICAgIENVU1RPTV8zID0gNSxcbiAgICBDVVNUT01fNCA9IDYsXG4gICAgQ1VTVE9NXzUgPSA3LFxuICAgIENVU1RPTV82ID0gOCxcbiAgICBDVVNUT01fNyA9IDksXG4gICAgQ1VTVE9NXzggPSAxMCxcbiAgICBDVVNUT01fOSA9IDExLFxufVxuXG5leHBvcnQgY29uc3QgTUFYX0FVRElPX0NIQU5ORUxTID0gMTI7IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IFRpbWVyTWFuYWdlciBmcm9tIFwiLi9UaW1lck1hbmFnZXJcIjtcblxuLyoqICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgdGltZXIgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGU6IFRpbWVyU3RhdGU7XG4gICAgXG4gICAgLyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyB0aW1lciBlbmRzICovXG4gICAgcHJvdGVjdGVkIG9uRW5kOiBGdW5jdGlvbjtcblxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpbWVyIHNob3VsZCBsb29wICovXG4gICAgcHJvdGVjdGVkIGxvb3A6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIHRvdGFsIGFtb3VudCBvZiB0aW1lIHRoaXMgdGltZXIgcnVucyBmb3IgKi9cbiAgICBwcm90ZWN0ZWQgdG90YWxUaW1lOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGxlZnQgb24gdGhlIGN1cnJlbnQgcnVuICovXG4gICAgcHJvdGVjdGVkIHRpbWVMZWZ0OiBudW1iZXI7XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiB0aW1lcyB0aGlzIHRpbWVyIGhhcyBiZWVuIHJ1biAqL1xuICAgIHByb3RlY3RlZCBudW1SdW5zOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcih0aW1lOiBudW1iZXIsIG9uRW5kPzogRnVuY3Rpb24sIGxvb3A6IGJvb2xlYW4gPSBmYWxzZSl7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoaXMgdGltZXJcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuYWRkVGltZXIodGhpcyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnRvdGFsVGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMudGltZUxlZnQgPSAwO1xuICAgICAgICB0aGlzLm9uRW5kID0gb25FbmQ7XG4gICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHRoaXMubnVtUnVucyA9IDA7XG4gICAgfVxuXG4gICAgaXNTdG9wcGVkKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBUaW1lclN0YXRlLlNUT1BQRUQ7XG4gICAgfVxuXG4gICAgaXNQYXVzZWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFRpbWVyU3RhdGUuUEFVU0VEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyB0aW1lciBoYXMgYmVlbiBydW4gYmVmb3JlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBpdCBoYXMgYmVlbiBydW4gYXQgbGVhc3Qgb25jZSAoYWZ0ZXIgdGhlIGxhdGVzdCByZXNldCksIGFuZCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBoYXNSdW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bVJ1bnMgPiAwO1xuICAgIH1cblxuICAgIHN0YXJ0KHRpbWU/OiBudW1iZXIpe1xuICAgICAgICBpZih0aW1lICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLkFDVElWRTtcbiAgICAgICAgdGhpcy50aW1lTGVmdCA9IHRoaXMudG90YWxUaW1lO1xuICAgIH1cblxuICAgIC8qKiBSZXNldHMgdGhpcyB0aW1lci4gU2V0cyB0aGUgcHJvZ3Jlc3MgYmFjayB0byB6ZXJvLCBhbmQgc2V0cyB0aGUgbnVtYmVyIG9mIHJ1bnMgYmFjayB0byB6ZXJvICovXG4gICAgcmVzZXQoKXtcbiAgICAgICAgdGhpcy50aW1lTGVmdCA9IHRoaXMudG90YWxUaW1lO1xuICAgICAgICB0aGlzLm51bVJ1bnMgPSAwO1xuICAgIH1cblxuICAgIHBhdXNlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5QQVVTRUQ7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKXtcbiAgICAgICAgaWYodGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5BQ1RJVkUpe1xuICAgICAgICAgICAgdGhpcy50aW1lTGVmdCAtPSBkZWx0YVQqMTAwMDtcblxuICAgICAgICAgICAgaWYodGhpcy50aW1lTGVmdCA8PSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gTWF0aFV0aWxzLmNsYW1wTG93MCh0aGlzLnRpbWVMZWZ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGVuZCgpe1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHN0YXRlXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHRoaXMubnVtUnVucyArPSAxO1xuXG4gICAgICAgIC8vIENhbGwgdGhlIGVuZCBmdW5jdGlvbiBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgaWYodGhpcy5vbkVuZCl7XG4gICAgICAgICAgICB0aGlzLm9uRW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIGlmIHdlIHdhbnQgdG9cbiAgICAgICAgaWYodGhpcy5sb29wKXtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLkFDVElWRTtcbiAgICAgICAgICAgIHRoaXMudGltZUxlZnQgPSB0aGlzLnRvdGFsVGltZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ3tcbiAgICAgICAgcmV0dXJuIFwiVGltZXI6IFwiICsgdGhpcy5zdGF0ZSArIFwiIC0gVGltZSBMZWZ0OiBcIiArIHRoaXMudGltZUxlZnQgKyBcIm1zIG9mIFwiICsgdGhpcy50b3RhbFRpbWUgKyBcIm1zXCI7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBUaW1lclN0YXRlIHtcbiAgICBBQ1RJVkUgPSBcIkFDVElWRVwiLFxuICAgIFBBVVNFRCA9IFwiUEFVU0VEXCIsXG4gICAgU1RPUFBFRCA9IFwiU1RPUFBFRFwiXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBUaW1lciBmcm9tIFwiLi9UaW1lclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lck1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIHByb3RlY3RlZCB0aW1lcnM6IEFycmF5PFRpbWVyPjtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMudGltZXJzID0gbmV3IEFycmF5KCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBpbnN0YW5jZTogVGltZXJNYW5hZ2VyO1xuXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCk6IFRpbWVyTWFuYWdlciB7XG4gICAgICAgIGlmKCF0aGlzLmluc3RhbmNlKXtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgVGltZXJNYW5hZ2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBhZGRUaW1lcih0aW1lcjogVGltZXIpe1xuICAgICAgICB0aGlzLnRpbWVycy5wdXNoKHRpbWVyKTtcbiAgICB9XG5cbiAgICBjbGVhclRpbWVycygpe1xuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnRpbWVycy5mb3JFYWNoKHRpbWVyID0+IHRpbWVyLnVwZGF0ZShkZWx0YVQpKTtcbiAgICB9XG59IiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi9NYXRoVXRpbHNcIjtcblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbW92ZWQgdG8gdGhlIGRhdGF0eXBlcyBmb2xkZXJcbi8qKlxuICogQSBDb2xvciB1dGlsIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgY29sb3JzIGxpa2UgYSB2ZWN0b3IsIGJ1dCBjYW4gYmUgY29udmVydGVkIGludG8gYSBzdHJpbmcgZm9ybWF0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yIHtcblx0LyoqIFRoZSByZWQgdmFsdWUgKi9cblx0cHVibGljIHI6IG51bWJlcjtcblx0LyoqIFRoZSBncmVlbiB2YWx1ZSAqL1xuXHRwdWJsaWMgZzogbnVtYmVyO1xuXHQvKiogVGhlIGJsdWUgdmFsdWUgKi9cblx0cHVibGljIGI6IG51bWJlcjtcblx0LyoqIFRoZSBhbHBoYSB2YWx1ZSAqL1xuXHRwdWJsaWMgYTogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IGNvbG9yXG5cdCAqIEBwYXJhbSByIFJlZFxuXHQgKiBAcGFyYW0gZyBHcmVlblxuXHQgKiBAcGFyYW0gYiBCbHVlXG5cdCAqIEBwYXJhbSBhIEFscGhhXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihyOiBudW1iZXIgPSAwLCBnOiBudW1iZXIgPSAwLCBiOiBudW1iZXIgPSAwLCBhOiBudW1iZXIgPSAxKXtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5hID0gYTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIFRyYW5zcGFyZW50IGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYmEoMCwgMCwgMCwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgVFJBTlNQQVJFTlQoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG5cdH1cblx0c3RhdGljIGdldCBGT0dfT0ZfV0FSX1RSQU5TUEFSRU5UKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDAuMDEpO1xuXHR9XG5cdHN0YXRpYyBnZXQgRk9HX09GX1dBUl9CTEFDSygpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAwLjk5KTtcblx0fVxuXHQvKipcdFxuXHQgKiBSZWQgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMCwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgUkVEKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMCwgMCwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBHcmVlbiBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBHUkVFTigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDAsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogQmx1ZSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMCwgMjU1KVxuXHQgKi9cblx0c3RhdGljIGdldCBCTFVFKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDAsIDI1NSwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBZZWxsb3cgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMjU1LCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBZRUxMT1coKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAyNTUsIDAsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogTWFnZW50YSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IE1BR0VOVEEoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAyNTUsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogQ3lhbiBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IENZQU4oKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMCwgMjU1LCAyNTUsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogV2hpdGUgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMjU1LCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IFdISVRFKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMjU1LCAyNTUsIDEpO1xuXHR9IFxuXG5cdC8qKlx0XG5cdCAqIEJsYWNrIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigwLCAwLCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBCTEFDSygpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIE9yYW5nZSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAxMDAsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IE9SQU5HRSgpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDEwMCwgMCwgMSk7XG5cdH1cblx0c3RhdGljIGdldCBQVVJQTEUoKTogQ29sb3J7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigxMTIsIDkwLCAyNDgsIDEpO1xuXHR9XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb2xvciB0byB0aGUgdmFsdWVzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSByIFJlZFxuXHQgKiBAcGFyYW0gZyBHcmVlblxuXHQgKiBAcGFyYW0gYiBCbHVlXG5cdCAqIEBwYXJhbSBhIEFscGhhXG5cdCAqL1xuXHRzZXQocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlciwgYTogbnVtYmVyID0gMSk6IHZvaWQge1xuXHRcdHRoaXMuciA9IHI7XG5cdFx0dGhpcy5nID0gZztcblx0XHR0aGlzLmIgPSBiO1xuXHRcdHRoaXMuYSA9IGE7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyBjb2xvciBzbGlnaHRseSBsaWdodGVyIHRoYW4gdGhlIGN1cnJlbnQgY29sb3Jcblx0ICogQHJldHVybnMgQSBuZXcgbGlnaHRlciBDb2xvclxuXHQgKi9cblx0bGlnaHRlbigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihNYXRoVXRpbHMuY2xhbXAodGhpcy5yICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmcgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYiArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5hICsgMTAsIDAsIDI1NSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igc2xpZ2h0bHkgZGFya2VyIHRoYW4gdGhlIGN1cnJlbnQgY29sb3Jcblx0ICogQHJldHVybnMgQSBuZXcgZGFya2VyIENvbG9yXG5cdCAqL1xuXHRkYXJrZW4oKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoTWF0aFV0aWxzLmNsYW1wKHRoaXMuciAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5nIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmIgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYSArIDEwLCAwLCAyNTUpKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhpcyBjb2xvciBhcyBhbiBhcnJheVxuXHQgKiBAcmV0dXJucyBbciwgZywgYiwgYV1cblx0ICovXG5cdHRvQXJyYXkoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuXHRcdHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXTtcblx0fVxuXHRpc0VxdWFsKGNvbG9yOkNvbG9yKTpib29sZWFue1xuXHRcdGlmKGNvbG9yLmEgPT0gdGhpcy5hICYmIGNvbG9yLnIgPT0gdGhpcy5yICYmIGNvbG9yLmcgPT0gdGhpcy5nICYmIGNvbG9yLmIgPT0gdGhpcy5iIClcbiAgICAgXHRcdHJldHVybiB0cnVlO1xuXHRcdGVsc2UgZmFsc2U7XG5cdH1cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbG9yIGFzIGEgc3RyaW5nIG9mIHRoZSBmb3JtICNSUkdHQkJcblx0ICogQHJldHVybnMgI1JSR0dCQlxuXHQgKi9cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCIjXCIgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5yLCAyKSArIE1hdGhVdGlscy50b0hleCh0aGlzLmcsIDIpICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuYiwgMik7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiKHIsIGcsIGIpXG5cdCAqIEByZXR1cm5zIHJnYihyLCBnLCBiKVxuXHQgKi9cblx0dG9TdHJpbmdSR0IoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCJyZ2IoXCIgKyB0aGlzLnIudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuZy50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5iLnRvU3RyaW5nKCkgKyBcIilcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb2xvciBhcyBhIHN0cmluZyBvZiB0aGUgZm9ybSByZ2JhKHIsIGcsIGIsIGEpXG5cdCAqIEByZXR1cm5zIHJnYmEociwgZywgYiwgYSlcblx0ICovXG5cdHRvU3RyaW5nUkdCQSgpOiBzdHJpbmcge1xuXHRcdGlmKHRoaXMuYSA9PT0gMCl7XG5cdFx0XHRyZXR1cm4gdGhpcy50b1N0cmluZ1JHQigpO1xuXHRcdH1cblx0XHRyZXR1cm4gXCJyZ2JhKFwiICsgdGhpcy5yLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmcudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYi50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5hLnRvU3RyaW5nKCkgK1wiKVwiXG5cdH1cblxuXHQvKipcblx0ICogVHVybnMgdGhpcyBjb2xvciBpbnRvIGEgZmxvYXQzMkFycmF5IGFuZCBjaGFuZ2VzIGNvbG9yIHJhbmdlIHRvIFswLjAsIDEuMF1cblx0ICogQHJldHVybnMgYSBGbG9hdDMyQXJyYXkgY29udGFpbmluZyB0aGUgY29sb3Jcblx0ICovXG5cdHRvV2ViR0woKTogRmxvYXQzMkFycmF5IHtcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHR0aGlzLnIvMjU1LFxuXHRcdFx0dGhpcy5nLzI1NSxcblx0XHRcdHRoaXMuYi8yNTUsXG5cdFx0XHR0aGlzLmFcblx0XHRdKTtcblx0fVxuXG5cdHN0YXRpYyBmcm9tU3RyaW5nSGV4KHN0cjogc3RyaW5nKTogQ29sb3Ige1xuXHRcdGxldCBpID0gMDtcblx0XHRpZihzdHIuY2hhckF0KDApID09IFwiI1wiKSBpKz0gMTtcblx0XHRsZXQgciA9IE1hdGhVdGlscy5mcm9tSGV4KHN0ci5zdWJzdHJpbmcoaSwgaSsyKSk7XG5cdFx0bGV0IGcgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGkrMiwgaSs0KSk7XG5cdFx0bGV0IGIgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGkrNCwgaSs2KSk7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiKTtcblx0fVxufSIsIi8vIEBpZ25vcmVQYWdlXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVhc2VGdW5jdGlvbnMge1xuXG4gICAgc3RhdGljIGVhc2VJbk91dFNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIC0oTWF0aC5jb3MoTWF0aC5QSSAqIHgpIC0gMSkgLyAyO1xuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlT3V0SW5TaW5lKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gLU1hdGguY29zKE1hdGguUEkqKHggKyAwLjUpKS8yIDogLU1hdGguY29zKE1hdGguUEkqKHggLSAwLjUpKS8yICsgMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZU91dFNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKCh4ICogTWF0aC5QSSkgLyAyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZUluU2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKCh4ICogTWF0aC5QSSkgLyAyKTsgXG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VJbk91dFF1aW50KHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gMTYgKiB4ICogeCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCA1KSAvIDI7ICAgIFxuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWFkKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gMiAqIHggKiB4IDogMSAtIE1hdGgucG93KC0yICogeCArIDIsIDIpIC8gMjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZU91dEluUXVhZCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAuNSA/IHRoaXMuZWFzZU91dEluX091dFBvdyh4LCAyKSA6IHRoaXMuZWFzZU91dEluX0luUG93KHgsIDIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGVhc2VPdXRJbl9PdXRQb3coeDogbnVtYmVyLCBwb3c6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAwLjUgLSBNYXRoLnBvdygtMiAqIHggKyAxLCBwb3cpIC8gMjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fSW5Qb3coeDogbnVtYmVyLCBwb3c6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAwLjUgKyBNYXRoLnBvdygyICogeCAtIDEsIHBvdykgLyAyO1xuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gRWFzZUZ1bmN0aW9uVHlwZSB7XG4gICAgLy8gU0lORVxuICAgIElOX09VVF9TSU5FID0gXCJlYXNlSW5PdXRTaW5lXCIsXG4gICAgT1VUX0lOX1NJTkUgPSBcImVhc2VPdXRJblNpbmVcIixcbiAgICBJTl9TSU5FID0gXCJlYXNlSW5TaW5lXCIsXG4gICAgT1VUX1NJTkUgPSBcImVhc2VPdXRTaW5lXCIsXG5cbiAgICAvLyBRVUFEXG4gICAgSU5fT1VUX1FVQUQgPSBcImVhc2VJbk91dFF1YWRcIixcbiAgICBPVVRfSU5fUVVBRCA9IFwiZWFzZU91dEluUXVhZFwiLFxuXG4gICAgLy8gUVVJTlRcbiAgICBJTl9PVVRfUVVJTlQgPSBcImVhc2VJbk91dFF1aW50XCJcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcbmltcG9ydCBFZGdlTm9kZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9FZGdlTm9kZVwiO1xuaW1wb3J0IEJpbmFyeUhlYXBTZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9Db2xsZWN0aW9ucy9CaW5hcnlIZWFwU2V0XCI7XG5cbi8qKiBBIGNsYXNzIHRvIHByb3ZpZGVzIHNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGdyYXBocyAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhVdGlscyB7XG5cblx0LyoqXG5cdCAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERqaWtzdHJhJ3Mgc2hvcnRlc3QgcGF0aCBhbGdvcml0aG0gYmFzZWQgb24gdGhlIG9uZSBkZXNjcmliZWQgaW4gVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxuXHQgKiBAcGFyYW0gZyBUaGUgZ3JhcGhcblx0ICogQHBhcmFtIHN0YXJ0IFRoZSBudW1iZXIgdG8gc3RhcnQgdGhlIHNob3J0ZXN0IHBhdGggZnJvbVxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwYXJlbnQgb2YgZWFjaCBub2RlIG9mIHRoZSBHcmFwaCBpbiB0aGUgc2hvcnRlc3QgcGF0aC5cblx0ICovXG5cdHN0YXRpYyBkamlrc3RyYShnOiBHcmFwaCwgc3RhcnQ6IG51bWJlcik6IEFycmF5PG51bWJlcj4ge1xuXHRcdGxldCBpOiBudW1iZXI7XHRcdC8vIENvdW50ZXJcblx0XHRsZXQgcDogRWRnZU5vZGU7XHQvLyBQb2ludGVyIHRvIGVkZ2Vub2RlXG5cdFx0bGV0IGluVHJlZTogQXJyYXk8Ym9vbGVhbj4gPSBuZXcgQXJyYXkoZy5udW1WZXJ0aWNlcyk7XG5cdFx0bGV0IGRpc3RhbmNlOiBBcnJheTxudW1iZXI+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xuXHRcdGxldCBwYXJlbnQ6IEFycmF5PG51bWJlcj4gPSBuZXcgQXJyYXkoZy5udW1WZXJ0aWNlcyk7XG5cdFx0bGV0IHY6IG51bWJlcjtcdFx0Ly8gQ3VycmVudCB2ZXJ0ZXggdG8gcHJvY2Vzc1xuXHRcdGxldCB3OiBudW1iZXI7IFx0XHQvLyBDYW5kaWRhdGUgZm9yIG5leHQgdmVydGV4XG5cdFx0bGV0IHdlaWdodDogbnVtYmVyO1x0Ly8gRWRnZSB3ZWlnaHRcblx0XHRsZXQgZGlzdDtcdFx0XHQvLyBCZXN0IGN1cnJlbnQgZGlzdGFuY2UgZnJvbSBzdGFydFxuXG5cdFx0Zm9yKGkgPSAwOyBpIDwgZy5udW1WZXJ0aWNlczsgaSsrKXtcblx0XHRcdGluVHJlZVtpXSA9IGZhbHNlO1xuXHRcdFx0ZGlzdGFuY2VbaV0gPSBJbmZpbml0eTtcblx0XHRcdHBhcmVudFtpXSA9IC0xO1xuXHRcdH1cblxuXHRcdGRpc3RhbmNlW3N0YXJ0XSA9IDA7XG5cdFx0diA9IHN0YXJ0O1xuXG5cdFx0d2hpbGUoIWluVHJlZVt2XSl7XG5cdFx0XHRpblRyZWVbdl0gPSB0cnVlO1xuXHRcdFx0cCA9IGcuZWRnZXNbdl07XG5cblx0XHRcdHdoaWxlKHAgIT09IG51bGwpe1xuXHRcdFx0XHR3ID0gcC55O1xuXHRcdFx0XHR3ZWlnaHQgPSBwLndlaWdodDtcblxuXHRcdFx0XHRpZihkaXN0YW5jZVt3XSA+IGRpc3RhbmNlW3ZdICsgd2VpZ2h0KXtcblx0XHRcdFx0XHRkaXN0YW5jZVt3XSA9IGRpc3RhbmNlW3ZdICsgd2VpZ2h0O1xuXHRcdFx0XHRcdHBhcmVudFt3XSA9IHY7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwID0gcC5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHR2ID0gMDtcblxuXHRcdFx0ZGlzdCA9IEluZmluaXR5O1xuXG5cdFx0XHRmb3IoaSA9IDA7IGkgPD0gZy5udW1WZXJ0aWNlczsgaSsrKXtcblx0XHRcdFx0aWYoIWluVHJlZVtpXSAmJiBkaXN0ID4gZGlzdGFuY2VbaV0pe1xuXHRcdFx0XHRcdGRpc3QgPSBkaXN0YW5jZTtcblx0XHRcdFx0XHR2ID0gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJlbnQ7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQSogYWxnb3JpdGhtXG5cdCAqIEBwYXJhbSBnIHRoZSBncmFwaCB0byBzZWFyY2hcblx0ICogQHBhcmFtIHN0YXJ0IHRoZSBub2RlIGluIHRoZSBncmFwaCwgZywgdG8gc3RhcnQgc2VhcmNoaW5nIGZyb21cblx0ICogQHBhcmFtIGdvYWwgdGhlIG5vZGUgaW4gdGhlIGdyYXBoLCBnLCB0aGF0IEEqIHNob3VsZCB0cnkgdG8gcmVhY2hcblx0ICogQHBhcmFtIGhldXJpc3RpYyB0aGUgaGV1cmlzdGljIGZ1bmN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBmLXNjb3JlIG9mIGEgbm9kZSBpbiB0aGUgZ3JhcGgsIGdcblx0ICogQHJldHVybiBpZiBhIHBhdGggYmV0d2VlbiBzdGFydCBhbmQgZ29hbCBleGlzdHMsIGFuIGFycmF5IG9mIG5vZGVzIHJlcHJlc2VudGluZyB0aGUgcGF0aCBmcm9tIHN0YXJ0IFxuXHQgKiB0byBnb2FsIGZvdW5kIGJ5IEEqOyBvdGhlcndpc2UgbnVsbFxuXHQgKi9cblx0c3RhdGljIGFzdGFyKGc6IEdyYXBoLCBzdGFydDogbnVtYmVyLCBnb2FsOiBudW1iZXIsIGhldXJpc3RpYzogKG5vZGU6IG51bWJlcikgPT4gbnVtYmVyKTogQXJyYXk8bnVtYmVyPiB7XG5cblx0XHQvLyBDb25zdHJ1Y3QgYSBuZXcgbWFwIG9mIHRoZSBnU2NvcmVzIC0gc3RhcnQgZ2V0cyBhIGdTY29yZSBvZiAwXG5cdFx0bGV0IGdTY29yZSA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XG5cdFx0Z1Njb3JlLnNldChzdGFydCwgMCk7XG5cblx0XHQvLyBDb25zdHJ1Y3QgYSBuZXcgbWFwIG9mIHRoZSBmU2NvcmVzIC0gZihuKSA9IGcobikgKyBoKG4pXG5cdFx0bGV0IGZTY29yZSA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XG5cdFx0ZlNjb3JlLnNldChzdGFydCwgaGV1cmlzdGljKHN0YXJ0KSk7XG5cblx0XHQvLyBDb25zdHJ1Y3QgYSBuZXcgbWFwIHRvIGhvbGQgdGhlIHBhdGggZnJvbSBzdGFydCB0byBnb2FsXG5cdFx0bGV0IGNhbWVGcm9tID0gbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKTtcblxuXHRcdC8vIFRoZSBvcGVuLXNldCBvZiBub2RlcyB0byBiZSBleHBsb3JlZC4gU3RhcnRzIG9mZiB3aXRoIGp1c3Qgc3RhcnRpbmcgbm9kZVxuXHRcdGxldCBvcGVuU2V0ID0gbmV3IEJpbmFyeUhlYXBTZXQ8bnVtYmVyPigoZTEsIGUyKSA9PiB7XG5cdFx0XHRsZXQgZTFmU2NvcmUgPSBmU2NvcmUuaGFzKGUxKSA/IGZTY29yZS5nZXQoZTEpIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdFx0bGV0IGUyZlNjb3JlID0gZlNjb3JlLmhhcyhlMikgPyBmU2NvcmUuZ2V0KGUyKSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHRcdGlmIChlMWZTY29yZSA8IGUyZlNjb3JlKSByZXR1cm4gMTtcblx0XHRcdHJldHVybiAwXG5cdFx0fSlcblx0XHRvcGVuU2V0LnB1c2goc3RhcnQpO1xuXG5cdFx0Ly8gV2hpbGUgdGhlcmUgYXJlIGVsZW1lbnRzIGluIHRoZSBvcGVuU2V0IC0gZXhwbG9yZSB0aGUgbm9kZXNcblx0XHR3aGlsZSAoIW9wZW5TZXQuaXNFbXB0eSgpKSB7XG5cblx0XHRcdGxldCBjdXJyZW50ID0gb3BlblNldC5wZWVrKCk7XG5cblx0XHRcdC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgdGhlIGdvYWwgLSByZXR1cm4gdGhlIHBhdGhcblx0XHRcdGlmIChjdXJyZW50ID09PSBnb2FsKSB7XG5cdFx0XHRcdGxldCByZXMgPSBHcmFwaFV0aWxzLmFzdGFyUGF0aEJ1aWxkZXIoY2FtZUZyb20sIGN1cnJlbnQpO1xuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UgLSByZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSBmcm9tIHRoZSBvcGVuU2V0IGFuZCBleHBsb3JlIGl0J3MgbmVpZ2hib3JzXG5cdFx0XHRvcGVuU2V0LnBvcCgpO1xuXG5cdFx0XHQvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGN1cnJlbnQgbm9kZSdzIGVkZ2UgbGlzdFxuXHRcdFx0bGV0IGVkZ2UgPSBnLmVkZ2VzW2N1cnJlbnRdXG5cblx0XHRcdHdoaWxlIChlZGdlICE9PSBudWxsICYmIGVkZ2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBHZXQgdGhlIG5laWdoYm9yIG5vZGUgZnJvbSB0aGUgZWRnZVxuXHRcdFx0XHRsZXQgbmVpZ2hib3IgPSBlZGdlLnk7XG5cblx0XHRcdFx0Ly8gR2V0IHRlbnRhdGl2ZSBnc2NvcmVcblx0XHRcdFx0bGV0IHRlbnRhdGl2ZV9nc2NvcmUgPSBnU2NvcmUuZ2V0KGN1cnJlbnQpICsgZWRnZS53ZWlnaHQ7XG5cblx0XHRcdFx0Ly8gR2V0IG5laWdoYm9ycyBnc2NvcmUgLSBpZiBuZWlnaGJvciBkb2Vzbid0IGhhdmUgYSBnc2NvcmUsIGRlZmF1bHQgaXMgcG9zaXRpdmUgaW5maW5pdHlcblx0XHRcdFx0bGV0IG5laWdoYm9yX2dzY29yZSA9IGdTY29yZS5oYXMobmVpZ2hib3IpID8gZ1Njb3JlLmdldChuZWlnaGJvcikgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cblx0XHRcdFx0aWYgKHRlbnRhdGl2ZV9nc2NvcmUgPCBuZWlnaGJvcl9nc2NvcmUpIHtcblxuXHRcdFx0XHRcdGNhbWVGcm9tLnNldChuZWlnaGJvciwgY3VycmVudCk7XG5cdFx0XHRcdFx0Z1Njb3JlLnNldChuZWlnaGJvciwgdGVudGF0aXZlX2dzY29yZSk7XG5cdFx0XHRcdFx0ZlNjb3JlLnNldChuZWlnaGJvciwgdGVudGF0aXZlX2dzY29yZSArIGhldXJpc3RpYyhuZWlnaGJvcikpO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG9wZW5TZXQgYWxyZWFkeSBjb250YWlucyB0aGUgbmVpZ2hib3IsIHRoZW4gcmVzdG9yZSB0aGUgaGVhcCBhYm91dCB0aGUgbmVpZ2hib3Jcblx0XHRcdFx0XHRpZiAob3BlblNldC5oYXMobmVpZ2hib3IpKSB7XG5cdFx0XHRcdFx0XHRvcGVuU2V0LnJlc3RvcmUobmVpZ2hib3IpO1xuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhlIG9wZW5TZXQgZG9lc24ndCBjb250YWluIHRoZSBuZWlnaGJvciwgc28gd2UgYWRkIHRoZSBuZWlnaGJvciB0byB0aGUgb3BlblNldFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvcGVuU2V0LnB1c2gobmVpZ2hib3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgYXN0YXJQYXRoQnVpbGRlcihjYW1lRnJvbTogTWFwPG51bWJlciwgbnVtYmVyPiwgY3VycmVudDogbnVtYmVyKTogQXJyYXk8bnVtYmVyPiB7XG5cdFx0bGV0IHBhdGggPSBuZXcgQXJyYXkoKTtcblx0XHRwYXRoLnB1c2goY3VycmVudCk7XG5cdFx0d2hpbGUgKGNhbWVGcm9tLmhhcyhjdXJyZW50KSkge1xuXHRcdFx0Y3VycmVudCA9IGNhbWVGcm9tLmdldChjdXJyZW50KTtcblx0XHRcdHBhdGgucHVzaChjdXJyZW50KTtcblx0XHR9XG5cdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH0gICAgXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKiBBIGNsYXNzIGNvbnRhaW5pbmcgc29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgbWF0aCBvcGVyYXRpb25zICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRoVXRpbHMge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgdGhlIHZhbHVlIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGV4dHJhY3QgdGhlIHNpZ24gZnJvbVxuICAgICAqIEByZXR1cm5zIC0xIGlmIHRoZSBudW1iZXIgaXMgbGVzcyB0aGFuIDAsIDEgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIHNpZ24oeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gLTEgOiAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgeCBpcyBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKiBAcGFyYW0gYSBUaGUgbWluIGJvdW5kXG4gICAgICogQHBhcmFtIGIgVGhlIG1heCBib3VuZFxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICAqIEBwYXJhbSBleGNsdXNpdmUgV2hldGhlciBvciBub3QgYSBhbmQgYiBhcmUgZXhjbHVzaXZlIGJvdW5kc1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgeCBpcyBiZXR3ZWVuIGEgYW5kIGIsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBiZXR3ZWVuKGE6IG51bWJlciwgYjogbnVtYmVyLCB4OiBudW1iZXIsIGV4Y2x1c2l2ZT86IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICAgICAgaWYoZXhjbHVzaXZlKXtcbiAgICAgICAgICAgIHJldHVybiAoYSA8IHgpICYmICh4IDwgYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgPD0geCkgJiYgKHggPD0gYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgdGhlIHZhbHVlIHggdG8gdGhlIHJhbmdlIFttaW4sIG1heF0sIHJvdW5kaW5nIHVwIG9yIGRvd24gaWYgbmVlZGVkXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW4gb2YgdGhlIHJhbmdlXG4gICAgICogQHBhcmFtIG1heCBUaGUgbWF4IG9mIHRoZSByYW5nZVxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGJldHdlZW4gbWluIGFuZCBtYXgsIG9yIG1pbi9tYXggaWYgaXQgZXhjZWVkcyB0aGVpciBib3VuZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2xhbXAoeDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBpZih4IDwgbWluKSByZXR1cm4gbWluO1xuICAgICAgICBpZih4ID4gbWF4KSByZXR1cm4gbWF4O1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgdGhlIHZhbHVlIHggdG8gdGhlIHJhbmdlIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gICAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgYmV0d2VlbiAwIGFuZCAxLCBvciAwLzEgaWYgaXQgZXhjZWVkcyB0aGVpciBib3VuZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2xhbXAwMSh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmNsYW1wKHgsIDAsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgbG93ZXIgZW5kIG9mIHRoZSB2YWx1ZSBvZiB4IHRvIHRoZSByYW5nZSB0byBtaW5cbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxuICAgICAqIEBwYXJhbSBtaW4gVGhlIG1pbmltdW0gYWxsb3dlZCB2YWx1ZSBvZiB4XG4gICAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIG1pbiwgb3RoZXJ3aXNlIG1pblxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcExvdyh4OiBudW1iZXIsIG1pbjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCBtaW4gPyBtaW4gOiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgbG93ZXIgZW5kIG9mIHRoZSB2YWx1ZSBvZiB4IHRvIHplcm9cbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiAwLCBvdGhlcndpc2UgMFxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcExvdzAoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5jbGFtcExvdyh4LCAwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXBNYWduaXR1ZGUodjogVmVjMiwgbTogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGlmKHYubWFnU3EoKSA+IG0qbSl7XG4gICAgICAgICAgICByZXR1cm4gdi5zY2FsZVRvKG0pO1xuICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjaGFuZ2VSYW5nZSh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgbmV3TWluOiBudW1iZXIsIG5ld01heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVycChuZXdNaW4sIG5ld01heCwgdGhpcy5pbnZMZXJwKG1pbiwgbWF4LCB4KSk7XG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIExpbmVhciBJbnRlcnBvbGF0aW9uXG5cdCAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcblx0ICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcblx0ICogQHBhcmFtIHQgVGhlIHRpbWUgd2UgYXJlIGludGVycG9sYXRpbmcgdG9cbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgYmV0d2VlbiBhIGFuZCBiIGF0IHRpbWUgdFxuXHQgKi9cblx0c3RhdGljIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBhICsgdCAqIChiIC0gYSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBMaW5lYXIgSW50ZXJwb2xhdGlvbi4gRmluZHMgdGhlIHRpbWUgYXQgd2hpY2ggYSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIgd291bGQgb2NjdXJcbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXG4gICAgICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBUaGUgdGltZSBhdCB3aGljaCB0aGUgY3VycmVudCB2YWx1ZSBvY2N1cnMgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgc3RhdGljIGludkxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpe1xuICAgICAgICByZXR1cm4gKHZhbHVlIC0gYSkvKGIgLSBhKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3V0cyBvZmYgZGVjaW1hbCBwb2ludHMgb2YgYSBudW1iZXIgYWZ0ZXIgYSBzcGVjaWZpZWQgcGxhY2VcbiAgICAgKiBAcGFyYW0gbnVtIFRoZSBudW1iZXIgdG8gZmxvb3JcbiAgICAgKiBAcGFyYW0gcGxhY2UgVGhlIGxhc3QgZGVjaW1hbCBwbGFjZSBvZiB0aGUgbmV3IG51bWJlclxuICAgICAqIEByZXR1cm5zIFRoZSBmbG9vcmVkIG51bWJlclxuICAgICAqL1xuICAgIHN0YXRpYyBmbG9vclRvUGxhY2UobnVtOiBudW1iZXIsIHBsYWNlOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBpZihwbGFjZSA9PT0gMCl7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZhY3RvciA9IDEwO1xuICAgICAgICB3aGlsZShwbGFjZSA+IDEpe1xuICAgICAgICAgICAgZmFjdG9yICE9IDEwO1xuICAgICAgICAgICAgcGxhY2UtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bSpmYWN0b3IpL2ZhY3RvcjtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgZnJvbSBhIGhleCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgaGV4IG51bWJlclxuICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgaW4gZGVjaW1hbCByZXByZXNlbnRlZCBieSB0aGUgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBhcyBhIGhleGFkZWNpbWFsXG4gICAgICogQHBhcmFtIG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gaGV4XG4gICAgICogQHBhcmFtIG1pbkxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBoZXggc3RyaW5nIChhZGRzIHplcm8gcGFkZGluZyBpZiBuZWVkZWQpXG4gICAgICogQHJldHVybnMgVGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIHRvSGV4KG51bTogbnVtYmVyLCBtaW5MZW5ndGg6IG51bWJlciA9IG51bGwpOiBzdHJpbmcge1xuICAgICAgICBsZXQgZmFjdG9yID0gMTtcbiAgICAgICAgd2hpbGUoZmFjdG9yKjE2IDwgbnVtKXtcbiAgICAgICAgICAgIGZhY3RvciAqPSAxNjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGV4U3RyID0gXCJcIjtcbiAgICAgICAgd2hpbGUoZmFjdG9yID49IDEpe1xuICAgICAgICAgICAgbGV0IGRpZ2l0ID0gTWF0aC5mbG9vcihudW0vZmFjdG9yKTtcbiAgICAgICAgICAgIGhleFN0ciArPSBNYXRoVXRpbHMudG9IZXhEaWdpdChkaWdpdCk7XG4gICAgICAgICAgICBudW0gLT0gZGlnaXQgKiBmYWN0b3I7XG4gICAgICAgICAgICBmYWN0b3IgLz0gMTY7XG5cdFx0fVxuXHRcdFxuXHRcdGlmKG1pbkxlbmd0aCAhPT0gbnVsbCl7XG5cdFx0XHR3aGlsZShoZXhTdHIubGVuZ3RoIDwgbWluTGVuZ3RoKXtcblx0XHRcdFx0aGV4U3RyID0gXCIwXCIgKyBoZXhTdHI7XG5cdFx0XHR9XG5cdFx0fVxuXG4gICAgICAgIHJldHVybiBoZXhTdHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBkaWdpdCB0byBoZXhhZGVjaW1hbC4gSW4gdGhpcyBjYXNlLCBhIGRpZ2l0IGlzIGJldHdlZW4gMCBhbmQgMTUgaW5jbHVzaXZlXG4gICAgICogQHBhcmFtIG51bSBUaGUgZGlnaXQgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbFxuICAgICAqIEByZXR1cm5zIFRoZSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGRpZ2l0IGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIHRvSGV4RGlnaXQobnVtOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBpZihudW0gPCAxMCl7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIG51bTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgbnVtIC0gMTApO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuL0NvbG9yXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuL01hdGhVdGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJpbmdVdGlscyB7XG5cdHN0YXRpYyB0b1dlYkdMQ29vcmRzKHBvaW50OiBWZWMyLCBvcmlnaW46IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKHBvaW50LngsIG9yaWdpbi54LCBvcmlnaW4ueCArIHdvcmxkU2l6ZS54LCAtMSwgMSksXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueSwgb3JpZ2luLnksIG9yaWdpbi55ICsgd29ybGRTaXplLnksIDEsIC0xKVxuXHRcdF0pO1xuXHR9XG5cblx0c3RhdGljIHRvV2ViR0xTY2FsZShzaXplOiBWZWMyLCB3b3JsZFNpemU6IFZlYzIpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdDIqc2l6ZS54L3dvcmxkU2l6ZS54LFxuXHRcdFx0MipzaXplLnkvd29ybGRTaXplLnksXG5cdFx0XSk7XG5cdH1cblxuXHRzdGF0aWMgdG9XZWJHTENvbG9yKGNvbG9yOiBDb2xvcik6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLnIsIDAsIDI1NSwgMCwgMSksXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuZywgMCwgMjU1LCAwLCAxKSxcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5iLCAwLCAyNTUsIDAsIDEpLFxuXHRcdFx0Y29sb3IuYVxuXHRcdF0pO1xuXHR9XG59IiwiLyoqIFNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBzdHJpbmdzICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdVdGlscyB7XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHBhdGggZnJvbSBhIGZpbGVwYXRoIHRoYXQgaW5jbHVkZXMgdGhlIGZpbGVcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggdGhlIGZpbGVwYXRoIHRvIGV4dHJhY3QgdGhlIHBhdGggZnJvbVxuICAgICAqIEByZXR1cm5zIFRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIGZpbGVwYXRoIHByb3ZpZGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldFBhdGhGcm9tRmlsZVBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIHNwbGl0UGF0aC5wb3AoKTtcbiAgICAgICAgc3BsaXRQYXRoLnB1c2goXCJcIik7XG4gICAgICAgIHJldHVybiBzcGxpdFBhdGguam9pbihcIi9cIik7XG4gICAgfVxufSIsImltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XG5pbXBvcnQgTlBDQWN0b3IgZnJvbSBcIi4uLy4uLy4uL0FjdG9ycy9OUENBY3RvclwiO1xuaW1wb3J0IHsgVGFyZ2V0YWJsZUVudGl0eSB9IGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvVGFyZ2V0YWJsZUVudGl0eVwiO1xuaW1wb3J0IE5QQ0FjdGlvbiBmcm9tIFwiLi9OUENBY3Rpb25cIjtcbmltcG9ydCB7IEJhdHRsZXJFdmVudHMgfSBmcm9tIFwiLi4vLi4vLi4vUHJvamVjdEV2ZW50c1wiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgTW9uc3RlckFuaW1hdGlvbnMgfSBmcm9tIFwiLi4vLi4vUGxheWVyL1BsYXllckNvbnRyb2xsZXJcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dGFja0VuZW15IGV4dGVuZHMgTlBDQWN0aW9uIHtcbiAgICBwcm90ZWN0ZWQgdGltZXI6IFRpbWVyO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHBhcmVudCwgYWN0b3I6IE5QQ0FjdG9yKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgYWN0b3IpO1xuICAgICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVyID0gbmV3IFRpbWVyKDIwMDApO1xuICAgIH1cbiAgICBwdWJsaWMgcGVyZm9ybUFjdGlvbih0YXJnZXQ6IFRhcmdldGFibGVFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aW1lci5pc1N0b3BwZWQoKSA/IGNvbnNvbGUubG9nKFwid2VhcG9uIGNvb2xpbmcgZG93biFcIikgOiBjb25zb2xlLmxvZyhcIndlYXBvbiByZWFkeVwiKTtcbiAgICAgICAgaWYgKHRoaXMudGltZXIuaXNTdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdG9yLmlzQ29sbGlkaW5nKVxuICAgICAgICAgICAgdGhpcy5hY3Rvci5hbmltYXRpb24ucGxheShcIkFUVEFDS1wiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQmF0dGxlckV2ZW50cy5NT05TVEVSX0FUVEFDSyk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5pc2hlZCgpO1xuICAgIH1cbiAgICBwdWJsaWMgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm9uRW50ZXIob3B0aW9ucyk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICByZXR1cm4gc3VwZXIub25FeGl0KCk7XG4gICAgfVxuXG5cbn0iLCJpbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgeyBUYXJnZXRhYmxlRW50aXR5IH0gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9UYXJnZXRhYmxlRW50aXR5XCI7XG5pbXBvcnQgTlBDQWN0aW9uIGZyb20gXCIuL05QQ0FjdGlvblwiO1xuXG4vKipcbiAqIEFuIElkbGUgYWN0aW9uIGZvciB0aGUgTlBDR29hcEFJLiBCYXNpY2FsbHkgYSBkZWZhdWx0IGFjdGlvbiBmb3IgYWxsIG9mIHRoZSBOUENzXG4gKiB0byBkbyBub3RoaW5nLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZGxlQWN0aW9uIGV4dGVuZHMgTlBDQWN0aW9uIHtcblxuICAgIHB1YmxpYyBwZXJmb3JtQWN0aW9uKHRhcmdldDogVGFyZ2V0YWJsZUVudGl0eSk6IHZvaWQge1xuICAgICAgICB0aGlzLmZpbmlzaGVkKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBzdXBlci5oYW5kbGVJbnB1dChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG59IiwiaW1wb3J0IEdvYXBBY3Rpb24gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0FJL0dvYXAvR29hcEFjdGlvblwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IEhlYWx0aHBhY2sgZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSXRlbXMvSGVhbHRocGFja1wiO1xuaW1wb3J0IE5QQ0FjdG9yIGZyb20gXCIuLi8uLi8uLi9BY3RvcnMvTlBDQWN0b3JcIjtcbmltcG9ydCBOUENCZWhhdmlvciBmcm9tIFwiLi4vTlBDQmVoYXZpb3JcIjtcbmltcG9ydCBGaW5kZXIgZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9GaW5kZXJcIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvVGFyZ2V0aW5nL1RhcmdldGFibGVFbnRpdHlcIjtcbmltcG9ydCBCYXNpY0ZpbmRlciBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvU2VhcmNoaW5nL0Jhc2ljRmluZGVyXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBHb2FwQWN0aW9uIGZvciBhbiBOUEMuIEFsbCBOUEMgYWN0aW9ucyBjb25zaXN0IG9mIGRvaW5nIHRocmVlIHRoaW5nczpcbiAqIFxuICogIDEuIFNlbGVjdGluZyBzb21lIHRhcmdldC9sb2NhdGlvblxuICogIDIuIEdvaW5nIHRvIG9yIG1vdmluZyB3aXRoaW4gcmFuZ2Ugb2YgdGhlIHNlbGVjdGVkIHRhcmdldFxuICogIDMuIERvaW5nIHNvbWV0aGluZyBhdCB0aGUgdGFyZ2V0IGxvY2F0aW9uXG4gKiBcbiAqIFRoZSBhYnN0cmFjdCBOUEMgYWN0aW9uIHRha2VzIGNhcmUgb2YgdGhlIGZpcnN0IHR3byBwYXJ0cyAoc2VsZWN0aW5nIHRoZSB0YXJnZXQgYW5kIG1vdmluZyB0byB0aGUgdGFyZ2V0IGxvY2F0aW9uKS4gQWxsXG4gKiBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIE5QQ0FjdGlvbiB3aWxsIGhhdmUgdG8gaW1wbGVtZW50IHRoZSBhYnN0cmFjdCBtZXRob2QgcGVyZm9ybUFjdGlvbigpIHdoaWNoXG4gKiBnZXRzIGNhbGxlZCB3aGVuIHRoZSBOUEMgcmVhY2hlcyB0aGUgdGFyZ2V0IGxvY2F0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBOUENBY3Rpb24gZXh0ZW5kcyBHb2FwQWN0aW9uIHtcblxuICAgIHByb3RlY3RlZCBwYXJlbnQ6IE5QQ0JlaGF2aW9yO1xuICAgIHByb3RlY3RlZCBhY3RvcjogTlBDQWN0b3I7XG5cbiAgICAvLyBUaGUgdGFyZ2V0aW5nIHN0cmF0ZWd5IHVzZWQgZm9yIHRoaXMgR290b0FjdGlvbiAtIGRldGVybWluZXMgaG93IHRoZSB0YXJnZXQgaXMgc2VsZWN0ZWQgYmFzaWNhbGx5XG4gICAgcHJvdGVjdGVkIF90YXJnZXRGaW5kZXI6IEZpbmRlcjxUYXJnZXRhYmxlRW50aXR5PjtcbiAgICAvLyBUaGUgdGFyZ2V0cyBvciBUYXJnZXRhYmxlIGVudGl0aWVzIFxuICAgIHByb3RlY3RlZCBfdGFyZ2V0czogVGFyZ2V0YWJsZUVudGl0eVtdO1xuICAgIC8vIFRoZSB0YXJnZXQgd2UgYXJlIGdvaW5nIHRvIHNldCB0aGUgYWN0b3IgdG8gdGFyZ2V0XG4gICAgcHJvdGVjdGVkIF90YXJnZXQ6IFRhcmdldGFibGVFbnRpdHkgfCBudWxsO1xuICAgIC8vIFRoZSBwYXRoIGZyb20gdGhlIE5QQyB0byB0aGUgdGFyZ2V0XG4gICAgcHJvdGVjdGVkIF9wYXRoOiBOYXZpZ2F0aW9uUGF0aCB8IG51bGw7XG5cblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwYXJlbnQ6IE5QQ0JlaGF2aW9yLCBhY3RvcjogTlBDQWN0b3IpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBhY3Rvcik7XG4gICAgICAgIHRoaXMudGFyZ2V0RmluZGVyID0gbmV3IEJhc2ljRmluZGVyKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIFxuXG4gICAgcHVibGljIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICAvLyBTZWxlY3QgdGhlIHRhcmdldCBsb2NhdGlvbiB3aGVyZSB0aGUgTlBDIHNob3VsZCBwZXJmb3JtIHRoZSBhY3Rpb25cbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5hY3Rvci5pbnZlbnRvcnkpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMudGFyZ2V0RmluZGVyLmZpbmQodGhpcy50YXJnZXRzKTtcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgYSB0YXJnZXQsIHNldCB0aGUgTlBDcyB0YXJnZXQgdG8gdGhlIHRhcmdldCBhbmQgZmluZCBhIHBhdGggdG8gdGhlIHRhcmdldFxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBhY3RvcnMgY3VycmVudCB0YXJnZXQgdG8gYmUgdGhlIHRhcmdldCBmb3IgdGhpcyBhY3Rpb25cblxuICAgICAgICAgICAgdGhpcy5hY3Rvci5zZXRUYXJnZXQodGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgcGF0aCBmcm9tIHRoZSBhY3RvciB0byB0aGUgdGFyZ2V0XG4gICAgICAgICAgICB0aGlzLnBhdGggPSB0aGlzLmFjdG9yLmdldFBhdGgodGhpcy5hY3Rvci5wb3NpdGlvbiwgdGhpcy50YXJnZXQucG9zaXRpb24pO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucGF0aC5kaXN0YW5jZSgpKTtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5kaXN0YW5jZSgpID4gNTApIHtcbiAgICAgICAgICAgIHRoaXMub25FbnRlcihudWxsKTtcbiAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uRW50ZXIobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0RvbmUoKSkge1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtQWN0aW9uKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0b3IubW92ZU9uUGF0aCgxLCB0aGlzLnBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFic3RyYWN0IHBlcmZvcm1BY3Rpb24odGFyZ2V0OiBUYXJnZXRhYmxlRW50aXR5KTogdm9pZCA7XG5cbiAgICBwdWJsaWMgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgICAgICAvLyBDbGVhciB0aGUgYWN0b3IncyBjdXJyZW50IHRhcmdldFxuICAgICAgICB0aGlzLmFjdG9yLmNsZWFyVGFyZ2V0KCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCBhbmQgdGhlIHBhdGggaW4gdGhlIGFjdGlvblxuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcHVibGljIHNhZmVFeGl0KCkge1xuICAgICAgICB0aGlzLmFjdG9yLmNsZWFyVGFyZ2V0KCk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBldmVudCBjYXVnaHQgaW4gTlBDQWN0aW9uISBFdmVudCB0eXBlOiAke2V2ZW50LnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHRhcmdldEZpbmRlcigpOiBGaW5kZXI8VGFyZ2V0YWJsZUVudGl0eT4geyByZXR1cm4gdGhpcy5fdGFyZ2V0RmluZGVyOyB9XG4gICAgcHVibGljIHNldCB0YXJnZXRGaW5kZXIoZmluZGVyOiBGaW5kZXI8VGFyZ2V0YWJsZUVudGl0eT4pIHsgdGhpcy5fdGFyZ2V0RmluZGVyID0gZmluZGVyOyB9XG5cbiAgICBwdWJsaWMgZ2V0IHRhcmdldHMoKTogQXJyYXk8VGFyZ2V0YWJsZUVudGl0eT4geyByZXR1cm4gdGhpcy5fdGFyZ2V0czsgfVxuICAgIHB1YmxpYyBzZXQgdGFyZ2V0cyh0YXJnZXRzOiBBcnJheTxUYXJnZXRhYmxlRW50aXR5PikgeyB0aGlzLl90YXJnZXRzID0gdGFyZ2V0czsgfVxuXG4gICAgcHVibGljIGdldCB0YXJnZXQoKTogVGFyZ2V0YWJsZUVudGl0eSB8IG51bGwgeyByZXR1cm4gdGhpcy5fdGFyZ2V0OyB9XG4gICAgcHJvdGVjdGVkIHNldCB0YXJnZXQodGFyZ2V0OiBUYXJnZXRhYmxlRW50aXR5IHwgbnVsbCkgeyB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7IH1cblxuICAgIHByb3RlY3RlZCBzZXQgcGF0aChwYXRoOiBOYXZpZ2F0aW9uUGF0aCB8IG51bGwpIHsgdGhpcy5fcGF0aCA9IHBhdGg7IH1cbiAgICBwcm90ZWN0ZWQgZ2V0IHBhdGgoKTogTmF2aWdhdGlvblBhdGggfCBudWxsIHsgcmV0dXJuIHRoaXMuX3BhdGg7IH1cbn1cbiIsImltcG9ydCBTdGF0ZU1hY2hpbmVHb2FwQUkgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0FJL0dvYXAvU3RhdGVNYWNoaW5lR29hcEFJXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xuaW1wb3J0IE5QQ0FjdG9yIGZyb20gXCIuLi8uLi9BY3RvcnMvTlBDQWN0b3JcIjtcbmltcG9ydCB7IEJhdHRsZXJFdmVudHMsIEl0ZW1FdmVudCB9IGZyb20gXCIuLi8uLi9Qcm9qZWN0RXZlbnRzXCI7XG5pbXBvcnQgTlBDQWN0aW9uIGZyb20gXCIuL05QQ0FjdGlvbnMvTlBDQWN0aW9uXCI7XG5pbXBvcnQgeyBIdWRFdmVudCB9IGZyb20gXCIuLi8uLi9Qcm9qZWN0RXZlbnRzXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYmVoYXZpb3IgZm9yIGFuIE5QQy4gRWFjaCBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAqIE5QQ0JlaGF2aW9yIGNsYXNzIHNob3VsZCBkZWZpbmUgc29tZSBuZXcgYmVoYXZpb3IgZm9yIGFuIE5QQ0FjdG9yLiBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgTlBDQmVoYXZpb3IgZXh0ZW5kcyBTdGF0ZU1hY2hpbmVHb2FwQUk8TlBDQWN0aW9uPiAge1xuXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIG93bmVyOiBOUENBY3RvcjtcblxuICAgIHB1YmxpYyBpbml0aWFsaXplQUkob3duZXI6IE5QQ0FjdG9yLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoSXRlbUV2ZW50LkxBU0VSR1VOX0ZJUkVEKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoQmF0dGxlckV2ZW50cy5NT05TVEVSX0FUVEFDSyk7XG4gICAgfVxuXG4gICAgcHVibGljIGFjdGl2YXRlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XG5cbiAgICBwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgZ2FtZSBldmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEl0ZW1FdmVudC5MQVNFUkdVTl9GSVJFRDoge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2F0Y2hpbmcgYW5kIGhhbmRsaW5nIGxhc2VyZ3VuIGZpcmVkIGV2ZW50ISEhXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTGFzZXJndW5GaXJlZChldmVudC5kYXRhLmdldChcImFjdG9ySWRcIiksIGV2ZW50LmRhdGEuZ2V0KFwidG9cIiksIGV2ZW50LmRhdGEuZ2V0KFwiZnJvbVwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJhdHRsZXJFdmVudHMuTU9OU1RFUl9BVFRBQ0s6IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1PTlNURVIgQVRUQUNLXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHN1cGVyLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYW5kbGVMYXNlcmd1bkZpcmVkKGFjdG9ySWQ6IG51bWJlciwgdG86IFZlYzIsIGZyb206IFZlYzIpOiB2b2lkIHtcbiAgICAgICAgaWYgKGFjdG9ySWQgIT09IHRoaXMub3duZXIuaWQpIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIuaGVhbHRoIC09IHRoaXMub3duZXIuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaW50ZXJzZWN0U2VnbWVudCh0bywgZnJvbSkgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbn0iLCJpbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgTlBDQWN0b3IgZnJvbSBcIi4uLy4uLy4uL0FjdG9ycy9OUENBY3RvclwiO1xuaW1wb3J0IEJhc2ljRmluZGVyIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9TZWFyY2hpbmcvQmFzaWNGaW5kZXJcIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvVGFyZ2V0aW5nL1RhcmdldGFibGVFbnRpdHlcIjtcbmltcG9ydCBOUENCZWhhdmlvciBmcm9tIFwiLi4vTlBDQmVoYXZpb3JcIjtcbmltcG9ydCBCYXR0bGVyIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9CYXR0bGVTeXN0ZW0vQmF0dGxlclwiO1xuaW1wb3J0IHsgQmF0dGxlckFjdGl2ZUZpbHRlciwgRW5lbXlGaWx0ZXIsIFJhbmdlRmlsdGVyIH0gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9IVzRGaWx0ZXJzXCI7XG5pbXBvcnQgeyBUYXJnZXRFeGlzdHMgfSBmcm9tIFwiLi4vTlBDU3RhdHVzZXMvVGFyZ2V0RXhpc3RzXCI7XG5pbXBvcnQgRmFsc2VTdGF0dXMgZnJvbSBcIi4uL05QQ1N0YXR1c2VzL0ZhbHNlU3RhdHVzXCI7XG5pbXBvcnQgQXR0YWNrRW5lbXkgZnJvbSBcIi4uL05QQ0FjdGlvbnMvQXR0YWNrRW5lbXlcIjtcbmltcG9ydCB7IENsb3Nlc3RQb3NpdGlvbmVkIH0gZnJvbSBcIi4uLy4uLy4uL0dhbWVTeXN0ZW1zL1NlYXJjaGluZy9IVzRSZWR1Y2Vyc1wiO1xuaW1wb3J0IElkbGUgZnJvbSBcIi4uL05QQ0FjdGlvbnMvR290b0FjdGlvblwiO1xuaW1wb3J0IEdvYXBBY3Rpb24gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0FJL0dvYXAvR29hcEFjdGlvblwiO1xuaW1wb3J0IEdvYXBTdGF0ZSBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvQUkvR29hcC9Hb2FwU3RhdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpbWVCZWhhdmlvciBleHRlbmRzIE5QQ0JlaGF2aW9yIHtcbiAgICBwcm90ZWN0ZWQgdGFyZ2V0OiBUYXJnZXRhYmxlRW50aXR5O1xuICAgIHByb3RlY3RlZCByYW5nZTogbnVtYmVyO1xuXG4gICAgcHVibGljIGluaXRpYWxpemVBSShvd25lcjogTlBDQWN0b3IsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZUFJKG93bmVyLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgICAgICB0aGlzLnJhbmdlID0gb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU3RhdHVzZXMoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQWN0aW9ucygpO1xuICAgICAgICB0aGlzLmdvYWwgPSBTbGltZVN0YXR1c2VzLkdPQUw7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVTdGF0dXNlcygpOiB2b2lkIHtcbiAgICAgICAgbGV0IHNjZW5lID0gdGhpcy5vd25lci5nZXRTY2VuZSgpO1xuXG4gICAgICAgIGxldCBlbmVteUJhdHRsZXJGaW5kZXIgPSBuZXcgQmFzaWNGaW5kZXI8QmF0dGxlcj4obnVsbCwgQmF0dGxlckFjdGl2ZUZpbHRlcigpLCBFbmVteUZpbHRlcih0aGlzLm93bmVyKSwgUmFuZ2VGaWx0ZXIodGhpcy50YXJnZXQsIDAsIHRoaXMucmFuZ2UqdGhpcy5yYW5nZSkpO1xuICAgICAgICBsZXQgZW5lbXlBdEd1YXJkUG9zaXRpb24gPSBuZXcgVGFyZ2V0RXhpc3RzKHNjZW5lLmdldEJhdHRsZXJzKCksIGVuZW15QmF0dGxlckZpbmRlcik7XG4gICAgICAgIHRoaXMuYWRkU3RhdHVzKFNsaW1lU3RhdHVzZXMuRU5FTVlfSU5fR1VBUkRfUE9TSVRJT04sIGVuZW15QXRHdWFyZFBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmFkZFN0YXR1cyhTbGltZVN0YXR1c2VzLkdPQUwsIG5ldyBGYWxzZVN0YXR1cygpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaW5pdGlhbGl6ZUFjdGlvbnMoKTogdm9pZCB7XG4gICAgICAgIGxldCBzY2VuZSA9IHRoaXMub3duZXIuZ2V0U2NlbmUoKTtcblxuICAgICAgICBsZXQgYXR0YWNrRW5lbXkgPSBuZXcgQXR0YWNrRW5lbXkodGhpcywgdGhpcy5vd25lcik7XG4gICAgICAgIGF0dGFja0VuZW15LnRhcmdldHMgPSBzY2VuZS5nZXRCYXR0bGVycygpO1xuICAgICAgICBhdHRhY2tFbmVteS50YXJnZXRGaW5kZXIgPSBuZXcgQmFzaWNGaW5kZXI8QmF0dGxlcj4oQ2xvc2VzdFBvc2l0aW9uZWQodGhpcy5vd25lciksIEJhdHRsZXJBY3RpdmVGaWx0ZXIoKSwgRW5lbXlGaWx0ZXIodGhpcy5vd25lciksIFJhbmdlRmlsdGVyKHRoaXMudGFyZ2V0LCAwLCB0aGlzLnJhbmdlKnRoaXMucmFuZ2UpKTtcbiAgICAgICAgYXR0YWNrRW5lbXkuYWRkUHJlY29uZGl0aW9uKFNsaW1lU3RhdHVzZXMuRU5FTVlfSU5fR1VBUkRfUE9TSVRJT04pO1xuICAgICAgICBhdHRhY2tFbmVteS5hZGRFZmZlY3QoU2xpbWVTdGF0dXNlcy5HT0FMKTtcbiAgICAgICAgYXR0YWNrRW5lbXkuY29zdCA9IDE7XG4gICAgICAgIHRoaXMuYWRkU3RhdGUoU2xpbWVBY3Rpb25zLkFUVEFDSywgYXR0YWNrRW5lbXkpO1xuXG4gICAgICAgIGxldCBzbGltZSA9IG5ldyBJZGxlKHRoaXMsIHRoaXMub3duZXIpO1xuICAgICAgICBzbGltZS50YXJnZXRzID0gW3RoaXMudGFyZ2V0XTtcbiAgICAgICAgc2xpbWUudGFyZ2V0RmluZGVyID0gbmV3IEJhc2ljRmluZGVyKCk7XG4gICAgICAgIHNsaW1lLmFkZEVmZmVjdChTbGltZVN0YXR1c2VzLkdPQUwpO1xuICAgICAgICBzbGltZS5jb3N0ID0gMTAwMDtcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShTbGltZUFjdGlvbnMuR1VBUkQsIHNsaW1lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgYWRkU3RhdGUoc3RhdGVOYW1lOiBzdHJpbmcsIHN0YXRlOiBHb2FwQWN0aW9uKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLmFkZFN0YXRlKHN0YXRlTmFtZSwgc3RhdGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBhZGRTdGF0dXMoc3RhdHVzTmFtZTogc3RyaW5nLCBzdGF0dXM6IEdvYXBTdGF0ZSk6IHZvaWQge1xuICAgICAgICBzdXBlci5hZGRTdGF0dXMoc3RhdHVzTmFtZSwgc3RhdHVzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHN1cGVyLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuICAgIH1cbn1cblxuY29uc3QgU2xpbWVTdGF0dXNlcyA9IHtcbiAgICBFTkVNWV9JTl9HVUFSRF9QT1NJVElPTjogXCJlbmVteS1hdC1ndWFyZC1wb3NpdGlvblwiLFxuICAgIEdPQUw6IFwiZ29hbFwiXG59XG5cbmNvbnN0IFNsaW1lQWN0aW9ucyA9IHtcbiAgICBJRExFOiBcImlkbGVcIixcbiAgICBBVFRBQ0s6IFwiYXR0YWNrXCIsXG4gICAgR1VBUkQ6IFwiZ3VhcmRcIlxufSBhcyBjb25zdDtcbiIsImltcG9ydCBHb2FwU3RhdGUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0FJL0dvYXAvR29hcFN0YXRlXCI7XG5pbXBvcnQgQWN0b3IgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhbHNlU3RhdHVzIGV4dGVuZHMgR29hcFN0YXRlIHtcbiAgICBwdWJsaWMgaXNTYXRpc2ZpZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IFxuICAgIFxufSIsImltcG9ydCBHb2FwU3RhdGUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0FJL0dvYXAvR29hcFN0YXRlXCI7XG5pbXBvcnQgRmluZGVyIGZyb20gXCIuLi8uLi8uLi9HYW1lU3lzdGVtcy9TZWFyY2hpbmcvRmluZGVyXCI7XG5cbmV4cG9ydCBjbGFzcyBUYXJnZXRFeGlzdHM8VD4gZXh0ZW5kcyBHb2FwU3RhdGUge1xuXG4gICAgcHJvdGVjdGVkIHRhcmdldHM6IFJlYWRvbmx5PFRbXT47XG4gICAgcHJvdGVjdGVkIGZpbmRlcjogRmluZGVyPFQ+O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHRhcmdldHM6IFJlYWRvbmx5PFRbXT4sIGZpbmRlcjogRmluZGVyPFQ+KSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5maW5kZXIgPSBmaW5kZXI7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IHRhcmdldHM7XG4gICAgfVxuXG4gICAgcHVibGljIGlzU2F0aXNmaWVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kZXIuZmluZCh0aGlzLnRhcmdldHMpICE9PSBudWxsO1xuICAgIH1cblxufSIsImltcG9ydCBTdGF0ZU1hY2hpbmVBSSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvQUkvU3RhdGVNYWNoaW5lQUlcIjtcbmltcG9ydCBBSSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IFBsYXllckFjdG9yIGZyb20gXCIuLi8uLi9BY3RvcnMvUGxheWVyQWN0b3JcIjtcbmltcG9ydCBJbnZlbnRvcnkgZnJvbSBcIi4uLy4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSW52ZW50b3J5XCI7XG5pbXBvcnQgSXRlbSBmcm9tIFwiLi4vLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtXCI7XG5pbXBvcnQgUGxheWVyQ29udHJvbGxlciBmcm9tIFwiLi9QbGF5ZXJDb250cm9sbGVyXCI7XG5pbXBvcnQgeyBJZGxlLCBTaGllbGRpbmcsIE1vdmluZywgRGVhZCwgUGxheWVyU3RhdGVUeXBlLCBBdHRhY2tpbmcgfSBmcm9tIFwiLi9QbGF5ZXJTdGF0ZXMvUGxheWVyU3RhdGVcIjtcbmltcG9ydCB7IEJhdHRsZXJFdmVudHMgfSBmcm9tIFwiLi4vLi4vUHJvamVjdEV2ZW50c1wiO1xuaW1wb3J0IFRpbWVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcbmltcG9ydCB7IFBsYXllclN0YXRzQXJyYXkgfSBmcm9tIFwiLi4vLi4vUGxheWVyU3RhdHNBcnJheVwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvVXRpbHMvTWF0aFV0aWxzXCI7XG4vKipcbiAqIFRoZSBBSSB0aGF0IGNvbnRyb2xzIHRoZSBwbGF5ZXIuIFRoZSBwbGF5ZXJzIEFJIGhhcyBiZWVuIGNvbmZpZ3VyZWQgYXMgYSBGaW5pdGUgU3RhdGUgTWFjaGluZSAoRlNNKVxuICogd2l0aCA0IHN0YXRlczsgSWRsZSwgTW92aW5nLCBzaGllbGRpbmcsIGFuZCBEZWFkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXJBSSBleHRlbmRzIFN0YXRlTWFjaGluZUFJIGltcGxlbWVudHMgQUkge1xuXG4gICAgLyoqIFRoZSBHYW1lTm9kZSB0aGF0IG93bnMgdGhpcyBBSSAqL1xuICAgIHB1YmxpYyBvd25lcjogUGxheWVyQWN0b3I7XG4gICAgLyoqIEEgc2V0IG9mIGNvbnRyb2xzIGZvciB0aGUgcGxheWVyICovXG4gICAgcHVibGljIGNvbnRyb2xsZXI6IFBsYXllckNvbnRyb2xsZXI7XG4gICAgLyoqIFRoZSBpbnZlbnRvcnkgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcGxheWVyICovXG4gICAgcHVibGljIGludmVudG9yeTogSW52ZW50b3J5O1xuICAgIC8qKiBUaGUgcGxheWVycyBoZWxkIGl0ZW0gKi9cbiAgICBwdWJsaWMgaXRlbTogSXRlbSB8IG51bGw7XG4gXG4gICAgLy8gaGl0IFxuICAgIHByaXZhdGUgaW52aW5jaWJsZVRpbWU6IFRpbWVyO1xuICAgIHByaXZhdGUgaXNJbnZpbmNpYmxlID0gZmFsc2U7XG4gICAgLy9zdGF0cyBvZiBBSVxuICAgIHByaXZhdGUgY3VycmVudFN0YXRWYWx1ZSA9IDEwO1xuICAgIHByaXZhdGUgc3RhdE5hbWVzID0gUGxheWVyU3RhdHNBcnJheTtcbiAgICBwcml2YXRlIG1pblN0YXRWYWx1ZSA9IDA7XG4gICAgcHJpdmF0ZSBtYXhTdGF0VmFsdWUgPSAxMDtcbiAgICBwcml2YXRlIGN1cnJlbnRTdGF0ID0ge307XG4gICAgcHVibGljIGluaXRpYWxpemVBSShvd25lcjogUGxheWVyQWN0b3IsIG9wdHM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgUGxheWVyQ29udHJvbGxlcihvd25lcik7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBwbGF5ZXJzIHN0YXRlcyB0byBpdCdzIFN0YXRlTWFjaGluZVxuICAgICAgICB0aGlzLmFkZFN0YXRlKFBsYXllclN0YXRlVHlwZS5JRExFLCBuZXcgSWRsZSh0aGlzLCB0aGlzLm93bmVyKSk7XG4gICAgICAgIHRoaXMuYWRkU3RhdGUoUGxheWVyU3RhdGVUeXBlLk1PVklORywgbmV3IE1vdmluZyh0aGlzLCB0aGlzLm93bmVyKSk7XG4gICAgICAgIHRoaXMuYWRkU3RhdGUoUGxheWVyU3RhdGVUeXBlLlNISUVMRElORywgbmV3IFNoaWVsZGluZyh0aGlzLCB0aGlzLm93bmVyKSk7XG4gICAgICAgIHRoaXMuYWRkU3RhdGUoUGxheWVyU3RhdGVUeXBlLkFUVEFDS0lORywgbmV3IEF0dGFja2luZyh0aGlzLCB0aGlzLm93bmVyKSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGxheWVycyBzdGF0ZSB0byBJZGxlXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShQbGF5ZXJTdGF0ZVR5cGUuSURMRSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEJhdHRsZXJFdmVudHMuUFJJTkNFX0RFQUQpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShCYXR0bGVyRXZlbnRzLlBSSU5DRV9ISVQpO1xuICAgICAgICB0aGlzLmludmluY2libGVUaW1lID0gbmV3IFRpbWVyKDEwMDAsIHRoaXMuaGFuZGxlaW52aW5jaWJsZVRpbWVFbmQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZShudWxsKVxuICAgIH1cblxuICAgIHB1YmxpYyBhY3RpdmF0ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLnN0YXROYW1lcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdFtuYW1lXSA9IHRoaXMuY3VycmVudFN0YXRWYWx1ZTsgLy8gU2V0IGRlZmF1bHQgdmFsdWUgZm9yIGVhY2ggc3RhdFxuICAgICAgICAgICAgaWYobmFtZSAhPT0nY3VycmVudEhlYWx0aCcpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRbbmFtZV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICB3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBwbGF5ZXIgaXMgb3V0IG9mIGhwIC0gcGxheSB0aGUgZGVhdGggYW5pbWF0aW9uXG4gICAgICAgICB0aGlzLmN1cnJlbnRTdGF0WydjdXJyZW50U2hpZWxkJ10gPSBNYXRoVXRpbHMuY2xhbXAoXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0WydjdXJyZW50U2hpZWxkJ10gICsgZGVsdGFUKjMsXG4gICAgICAgICAgICB0aGlzLm1pblN0YXRWYWx1ZSxcbiAgICAgICAgICAgIHRoaXMubWF4U3RhdFZhbHVlLFxuICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7IH1cblxuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBCYXR0bGVyRXZlbnRzLlBSSU5DRV9ISVQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByaW5jZUhpdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBCYXR0bGVyRXZlbnRzLlBSSU5DRV9ERUFEOiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkZWFkXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPIERPIHBsYXkgaGl0IGFuaW1hdGlvblxuICAgIHByb3RlY3RlZCBoYW5kbGVQcmluY2VIaXQoKSB7XG4gICAgICBcbiAgICAgICAgaWYgKCF0aGlzLmlzSW52aW5jaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5pc0ludmluY2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pbnZpbmNpYmxlVGltZS5zdGFydCgpO1xuICAgICAgICAgICAgaWYgKCB0aGlzLmN1cnJlbnRTdGF0W1wiY3VycmVudEhlYWx0aFwiXSA8PSB0aGlzLm1pblN0YXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQmF0dGxlckV2ZW50cy5QUklOQ0VfREVBRCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVpbnZpbmNpYmxlVGltZUVuZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5pc0ludmluY2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gVE8gRE9cbiAgICAgICAgLy8gUGxheSBJZGxlIGFuaW1hdGlvblxuICAgIH07XG5cblxufSIsImltcG9ydCBTdGF0ZU1hY2hpbmVBSSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvQUkvU3RhdGVNYWNoaW5lQUlcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5cbi8qKlxuICogU3RyaW5ncyB1c2VkIGluIHRoZSBrZXkgYmluZGluZyBmb3IgdGhlIHBsYXllclxuICovXG5leHBvcnQgZW51bSBQbGF5ZXJJbnB1dCB7XG4gICAgTU9WRV9VUCA9IFwiTU9WRV9VUFwiLFxuICAgIE1PVkVfRE9XTiA9IFwiTU9WRV9ET1dOXCIsXG4gICAgTU9WRV9MRUZUID0gXCJNT1ZFX0xFRlRcIixcbiAgICBNT1ZFX1JJR0hUID0gXCJNT1ZFX1JJR0hUXCIsXG4gICAgQVRUQUNLSU5HID0gXCJBVFRBQ0tJTkdcIixcbiAgICBTSElFTERJTkcgPSBcIlNISUVMRElOR1wiLFxuICAgIFVMVElNQVRFID0gXCJVTFRJTUFURVwiLFxuICAgIFBJQ0tVUF9JVEVNID0gXCJQSUNLVVBfSVRFTVwiLFxuICAgIERST1BfSVRFTSA9IFwiRFJPUF9JVEVNXCIsXG4gICBcbn1cbmV4cG9ydCBlbnVtIFVzZUl0ZW1JbnB1dCB7XG4gICAgVVNFX0lURU0xID0gXCJVU0VfSVRFTTFcIixcbiAgICBVU0VfSVRFTTIgPSBcIlVTRV9JVEVNMlwiLFxuICAgIFVTRV9JVEVNMyA9IFwiVVNFX0lURU0zXCIsXG4gICAgVVNFX0lURU00ID0gXCJVU0VfSVRFTTRcIixcbiAgICBVU0VfSVRFTTUgPSBcIlVTRV9JVEVNNVwiLFxuICB9XG5leHBvcnQgY29uc3QgUGxheWVyQW5pbWF0aW9ucyA9IHtcbiAgICBJRExFIDogXCJJRExFXCIsXG4gICAgQVRUQUNLSU5HOiBcIkFUVEFDS0lOR1wiLFxuICAgIE1PVklORyA6IFwiTU9WSU5HXCIsXG4gICAgU0hJRUxESU5HOiBcIlNISUVMRElOR1wiLFxuICAgIERZSU5HOiBcIkRZSU5HXCIsXG4gICAgREVBRDogXCJERUFEXCIsXG4gICAgSElUOiBcIkhJVFwiXG59IGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBNb25zdGVyQW5pbWF0aW9ucyA9IHtcbiAgICBJRExFOiBcIklETEVcIixcbiAgICBBVFRBQ0tJTkc6IFwiQVRUQUNLSU5HXCIsXG4gICAgTU9WSU5HOiBcIk1PVklOR1wiLFxuICAgIERZSU5HOiBcIkRZSU5HOlwiLFxuICAgIERFQUQ6IFwiREVBRFwiLFxuICAgIEhJVDogXCJISVRcIlxufVxuXG4vKipcbiAqIFRoZSBQbGF5ZXJDb250cm9sbGVyIGNsYXNzIGhhbmRsZXMgcHJvY2Vzc2luZyB0aGUgaW5wdXQgcmVjaWV2ZWQgZnJvbSB0aGUgdXNlciBhbmQgZXhwb3NlcyAgXG4gKiBhIHNldCBvZiBtZXRob2RzIHRvIG1ha2UgZGVhbGluZyB3aXRoIHRoZSB1c2VyIGlucHV0IGEgYml0IHNpbXBsZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYXllckNvbnRyb2xsZXJ7XG5cbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoYXQgb3ducyB0aGUgQUkgKi9cbiAgICBwcm90ZWN0ZWQgb3duZXI6IEFuaW1hdGVkU3ByaXRlO1xuXG4gICAgY29uc3RydWN0b3Iob3duZXI6IEFuaW1hdGVkU3ByaXRlKSB7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkaXJlY3Rpb24gdGhlIHBsYXllciBzaG91bGQgbW92ZSBiYXNlZCBvbiBpbnB1dCBmcm9tIHRoZSBrZXlib2FyZC4gXG4gICAgICogQHJldHVybnMgYSBWZWMyIGluZGljYXRpbmcgdGhlIGRpcmVjdGlvbiB0aGUgcGxheWVyIHNob3VsZCBtb3ZlLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1vdmVEaXIoKTogVmVjMiB7IFxuICAgICAgICBsZXQgZGlyOiBWZWMyID0gVmVjMi5aRVJPO1xuICAgICAgICBkaXIueSA9IChJbnB1dC5pc1ByZXNzZWQoUGxheWVySW5wdXQuTU9WRV9VUCkgPyAtMSA6IDApICsgKElucHV0LmlzUHJlc3NlZChQbGF5ZXJJbnB1dC5NT1ZFX0RPV04pID8gMSA6IDApO1xuXHRcdGRpci54ID0gKElucHV0LmlzUHJlc3NlZChQbGF5ZXJJbnB1dC5NT1ZFX0xFRlQpID8gLTEgOiAwKSArIChJbnB1dC5pc1ByZXNzZWQoUGxheWVySW5wdXQuTU9WRV9SSUdIVCkgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiBkaXIubm9ybWFsaXplKCk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEdldHMgdGhlIGRpcmVjdGlvbiB0aGUgcGxheWVyIHNob3VsZCBiZSBmYWNpbmcgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgICAqIG1vdXNlIGFyb3VuZCB0aGUgcGxheWVyXG4gICAgICogQHJldHVybiBhIFZlYzIgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb24gdGhlIHBsYXllciBzaG91bGQgZmFjZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGZhY2VEaXIoKTogVmVjMiB7IHJldHVybiB0aGlzLm93bmVyLnBvc2l0aW9uLmRpclRvKElucHV0LmdldEdsb2JhbE1vdXNlUG9zaXRpb24oKSk7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBwbGF5ZXJzIHNwcml0ZSBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIHRoZSBwbGF5ZXJcbiAgICAgKiBzaG91bGQgYmUgZmFjaW5nLlxuICAgICAqIEByZXR1cm4gYSBudW1iZXIgcmVwcmVzZW50aW5nIGhvdyBtdWNoIHRoZSBwbGF5ZXIgc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJvdGF0aW9uKCk6IG51bWJlciB7IHJldHVybiBWZWMyLlVQLmFuZ2xlVG9DQ1codGhpcy5mYWNlRGlyKTsgfVxuXG4gICAgLyoqIFxuICAgICAqIENoZWNrcyBpZiB0aGUgcGxheWVyIGlzIGF0dGVtcHRpbmcgdG8gdXNlIGEgaGVsZCBpdGVtIG9yIG5vdC5cbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHBsYXllciBpcyBhdHRlbXB0aW5nIHRvIHVzZSBhIGhlbGQgaXRlbTsgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgcHVibGljIGdldCB1c2VJdGVtKCk6IGJvb2xlYW4geyByZXR1cm4gSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKCk7IH1cblxuICAgIC8qKiBcbiAgICAgKiBDaGVja3MgaWYgdGhlIHBsYXllciBpcyBhdHRlbXB0aW5nIHRvIHBpY2sgdXAgYW4gaXRlbSBvciBub3QuXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBwbGF5ZXIgaXMgYXR0ZW1wdGluZyB0byBwaWNrIHVwIGFuIGl0ZW07IGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBpY2tpbmdVcCgpOiBib29sZWFuIHsgcmV0dXJuIElucHV0LmlzSnVzdFByZXNzZWQoUGxheWVySW5wdXQuUElDS1VQX0lURU0pOyB9XG5cbiAgICBwdWJsaWMgZ2V0IGF0dGFja2luZygpOiBib29sZWFuIHsgcmV0dXJuIElucHV0LmlzSnVzdFByZXNzZWQoUGxheWVySW5wdXQuQVRUQUNLSU5HKTsgfVxuXG4gICAgcHVibGljIGdldCBzaGllbGRpbmcoKTogYm9vbGVhbiB7IHJldHVybiBJbnB1dC5pc0p1c3RQcmVzc2VkKFBsYXllcklucHV0LlNISUVMRElORyk7IH1cblxuICAgIHB1YmxpYyBnZXQgdWx0aW1hdGUoKTogYm9vbGVhbiB7IHJldHVybiBJbnB1dC5pc0p1c3RQcmVzc2VkKFBsYXllcklucHV0LlVMVElNQVRFKTsgfVxuXG4gICAgLyoqIFxuICAgICAqIENoZWNrcyBpZiB0aGUgcGxheWVyIGlzIGF0dGVtcHRpbmcgdG8gZHJvcCB0aGVpciBoZWxkIGl0ZW0gb3Igbm90LlxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgcGxheWVyIGlzIGF0dGVtcHRpbmcgdG8gZHJvcCB0aGVpciBoZWxkIGl0ZW07IGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGRyb3BwaW5nKCk6IGJvb2xlYW4geyByZXR1cm4gSW5wdXQuaXNKdXN0UHJlc3NlZChQbGF5ZXJJbnB1dC5EUk9QX0lURU0pOyB9XG5cblxufSIsImltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XG5pbXBvcnQgeyBQbGF5ZXJBbmltYXRpb25zIH0gZnJvbSBcIi4uL1BsYXllckNvbnRyb2xsZXJcIjtcbmltcG9ydCBQbGF5ZXJTdGF0ZSwgeyBQbGF5ZXJTdGF0ZVR5cGUgfSBmcm9tIFwiLi9QbGF5ZXJTdGF0ZVwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dGFja2luZyBleHRlbmRzIFBsYXllclN0YXRlIHtcblxuICAgIHByb3RlY3RlZCB0aW1lcjogVGltZXI7XG4gICAgXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudC5vd25lci5hbmltYXRpb24ucGxheShQbGF5ZXJBbmltYXRpb25zLkFUVEFDS0lORywgZmFsc2UpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQub3duZXIuYW5pbWF0aW9uLmlzUGxheWluZyhQbGF5ZXJBbmltYXRpb25zLkFUVEFDS0lORykpIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoUGxheWVyU3RhdGVUeXBlLklETEUpO1xuICAgICAgICB9ICBcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHN1cGVyLmhhbmRsZUlucHV0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHsgXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59IiwiaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgUGxheWVyRXZlbnRzIH0gZnJvbSBcIi4uLy4uLy4uL1Byb2plY3RFdmVudHNcIjtcbmltcG9ydCBQbGF5ZXJTdGF0ZSBmcm9tIFwiLi9QbGF5ZXJTdGF0ZVwiO1xuXG4vKipcbiAqIFRoZSBEZWFkIHN0YXRlIGZvciB0aGUgUGxheWVyQUkuIFdoaWxlIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwiRGVhZFwiIHN0YXRlLCB0aGUgcGxheWVyIGRvZXMgbm90XG4gKiBnZXQgdXBkYXRlZCBhbmQgYWxsIGluY29taW5nIGV2ZW50cyB0byB0aGUgUGxheWVyQUkgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYWQgZXh0ZW5kcyBQbGF5ZXJTdGF0ZSB7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBQbGF5ZXJBSSBlbnRlcnMgdGhlIGRlYWQgc3RhdGUsIGFuIGV2ZW50IGlzIGZpcmVkIHRvIGFsZXJ0IHRoZSBzeXN0ZW1cbiAgICAgKiB0aGF0IHRoZSBwbGF5ZXIgaXMgb2ZmaWNpYWxseSBkZWFkLlxuICAgICAqL1xuICAgIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICAvL3RoaXMuZW1pdHRlci5maXJlRXZlbnQoUGxheWVyRXZlbnRzLlBMQVlFUl9LSUxMRUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnB1dCBoYW5kbGVyIGZvciB0aGUgZGVhZCBzdGF0ZSBpZ25vcmVzIGFsbCBpbmNvbWluZyBldmVudHMgdG8gdGhlIHBsYXllci4gXG4gICAgICogQHBhcmFtIGV2ZW50IFxuICAgICAqL1xuICAgIGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHsgfVxuXG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byB0aGUgaGFuZGxlSW5wdXQgbWV0aG9kLCB3aGlsZSBpbiB0aGUgZGVhZCBzdGF0ZSwgdGhlIFBsYXllckFJIGRvZXNuJ3RcbiAgICAgKiBnZXQgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0gZGVsdGFUIFxuICAgICAqL1xuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQgeyB9XG5cbiAgICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7IHJldHVybiB7fSB9XG5cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IFBsYXllckFuaW1hdGlvblR5cGUsIFBsYXllclN0YXRlVHlwZSB9IGZyb20gXCIuL1BsYXllclN0YXRlXCI7XG5pbXBvcnQgeyBQbGF5ZXJBbmltYXRpb25zIH0gZnJvbSBcIi4uL1BsYXllckNvbnRyb2xsZXJcIjtcbmltcG9ydCBQbGF5ZXJTdGF0ZSBmcm9tIFwiLi9QbGF5ZXJTdGF0ZVwiO1xuaW1wb3J0IHsgTWVzc2FnZUJveEV2ZW50cyB9IGZyb20gXCIuLi8uLi8uLi9Qcm9qZWN0RXZlbnRzXCI7XG5pbXBvcnQgeyBQbGF5ZXJJbnB1dCB9IGZyb20gXCIuLi9QbGF5ZXJDb250cm9sbGVyXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZGxlIGV4dGVuZHMgUGxheWVyU3RhdGUge1xuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudC5vd25lci5hbmltYXRpb24ucGxheUlmTm90QWxyZWFkeShQbGF5ZXJBbmltYXRpb25zLklETEUsIHRydWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmNvbnRyb2xsZXIuc2hpZWxkaW5nICkge1xuICAgICAgICAgICAgaWYodGhpcy5wYXJlbnQub3duZXIuX2FpW1wiY3VycmVudFN0YXRcIl1bXCJjdXJyZW50U2hpZWxkXCJdID09IHRoaXMucGFyZW50Lm93bmVyLl9haVtcIm1heFN0YXRWYWx1ZVwiXSlcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkKFBsYXllclN0YXRlVHlwZS5TSElFTERJTkcpXG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoTWVzc2FnZUJveEV2ZW50cy5TSE9XLHttZXNzYWdlOk1lc3NhZ2VCb3hFdmVudHMuU0tJTExfT05fQ0R9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucGFyZW50LmNvbnRyb2xsZXIudWx0aW1hdGUpe1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChQbGF5ZXJJbnB1dC5VTFRJTUFURSlcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuY29udHJvbGxlci5hdHRhY2tpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoUGxheWVyU3RhdGVUeXBlLkFUVEFDS0lORyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudC5jb250cm9sbGVyLm1vdmVEaXIuZXF1YWxzKFZlYzIuWkVSTykpIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoUGxheWVyU3RhdGVUeXBlLk1PVklORyk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7IFxuICAgICAgICByZXR1cm4ge307IFxuICAgIH1cbiAgICBcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IFBsYXllckFuaW1hdGlvbnMgfSBmcm9tIFwiLi4vUGxheWVyQ29udHJvbGxlclwiO1xuaW1wb3J0IHsgUGxheWVyQW5pbWF0aW9uVHlwZSwgUGxheWVyU3RhdGVUeXBlIH0gZnJvbSBcIi4vUGxheWVyU3RhdGVcIjtcbmltcG9ydCBQbGF5ZXJTdGF0ZSBmcm9tIFwiLi9QbGF5ZXJTdGF0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3ZpbmcgZXh0ZW5kcyBQbGF5ZXJTdGF0ZSB7XG4gICAgXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLnBhcmVudC5vd25lci5hbmltYXRpb24ucGxheUlmTm90QWxyZWFkeShQbGF5ZXJBbmltYXRpb25zLk1PVklORywgdHJ1ZSk7XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQgeyBcbiAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBzdXBlci5oYW5kbGVJbnB1dChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQuY29udHJvbGxlci5zaGllbGRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoUGxheWVyU3RhdGVUeXBlLlNISUVMRElORyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmNvbnRyb2xsZXIuYXR0YWNraW5nKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkKFBsYXllclN0YXRlVHlwZS5BVFRBQ0tJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5jb250cm9sbGVyLm1vdmVEaXIuZXF1YWxzKFZlYzIuWkVSTykpIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoUGxheWVyU3RhdGVUeXBlLklETEUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHsgcmV0dXJuIHt9OyB9XG59IiwiaW1wb3J0IFN0YXRlIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IEJhdHRsZXJFdmVudHMsIEh1ZEV2ZW50LCBJdGVtRXZlbnQgfSBmcm9tIFwiLi4vLi4vLi4vUHJvamVjdEV2ZW50c1wiXG5pbXBvcnQgSXRlbSBmcm9tIFwiLi4vLi4vLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtXCI7XG5pbXBvcnQgUGxheWVyQUkgZnJvbSBcIi4uL1BsYXllckFJXCI7XG5cblxuZXhwb3J0IGVudW0gUGxheWVyQW5pbWF0aW9uVHlwZSB7XG4gICAgSURMRSA9IFwiSURMRVwiLFxuICAgIE1PVklORyA9IFwiTU9WSU5HXCIsXG4gICAgQVRUQUNLSU5HID0gXCJBVFRBQ0tJTkdcIixcbiAgICBTSElFTERJTkcgPSBcIlNISUVMRElOR1wiXG59XG5cblxuZXhwb3J0IGVudW0gUGxheWVyU3RhdGVUeXBlIHtcbiAgICBJRExFID0gXCJJRExFXCIsXG4gICAgQVRUQUNLSU5HID0gXCJBVFRBQ0tJTkdcIixcbiAgICBNT1ZJTkcgPSBcIk1PVklOR1wiLFxuICAgIFNISUVMRElORyA9IFwiU0hJRUxESU5HXCJcbn1cblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUGxheWVyU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG5cbiAgICBwcm90ZWN0ZWQgcGFyZW50OiBQbGF5ZXJBSTtcbiAgICBwcm90ZWN0ZWQgb3duZXI6IFBsYXllckFjdG9yO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHBhcmVudDogUGxheWVyQUksIG93bmVyOiBQbGF5ZXJBY3Rvcikge1xuICAgICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4geyByZXR1cm4ge307IH1cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgKHRoaXMucGFyZW50Lm93bmVyLmFuaW1hdGlvbi5pc1BsYXlpbmcoUGxheWVyQW5pbWF0aW9ucy5JRExFKSkge1xuICAgICAgICAvLyAgICAgdGhpcy5wYXJlbnQub3duZXIucm90YXRpb24gPSAwO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIEFkanVzdCB0aGUgYW5nbGUgdGhlIHBsYXllciBpcyBmYWNpbmcgXG4gICAgICAgIC8vIHRoaXMucGFyZW50Lm93bmVyLnJvdGF0aW9uID0gdGhpcy5wYXJlbnQuY29udHJvbGxlci5yb3RhdGlvbjtcbiAgICAgICAgbGV0IHByaW5jZURpcmVjdGlvbiA9IHRoaXMucGFyZW50LmNvbnRyb2xsZXIubW92ZURpcjtcbiAgICAgICAgLy9jaGFuZ2UgZGlyZWN0aW9uIG9mIHRoZSBwcmluY2VcbiAgICAgICAgaWYgKHByaW5jZURpcmVjdGlvbi54ID09IDApIHtcbiAgICAgICAgICAgIGlmIChwcmluY2VEaXJlY3Rpb24ueSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5vd25lci5yb3RhdGlvbiA9IDMuMTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpbmNlRGlyZWN0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQub3duZXIucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmluY2VEaXJlY3Rpb24ueSA9PSAwKSB7XG4gICAgICAgICAgICBpZiAocHJpbmNlRGlyZWN0aW9uLnggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQub3duZXIucm90YXRpb24gPSA0Ljc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByaW5jZURpcmVjdGlvbi54IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lm93bmVyLnJvdGF0aW9uID0gMS41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmluY2VEaXJlY3Rpb24ueCA8IDApIHtcbiAgICAgICAgICAgIGlmIChwcmluY2VEaXJlY3Rpb24ueSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5vd25lci5yb3RhdGlvbiA9IDAuNzU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpbmNlRGlyZWN0aW9uLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQub3duZXIucm90YXRpb24gPSAyLjI1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmluY2VEaXJlY3Rpb24ueCA+IDApIHtcbiAgICAgICAgICAgIGlmIChwcmluY2VEaXJlY3Rpb24ueSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5vd25lci5yb3RhdGlvbiA9IDUuMjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpbmNlRGlyZWN0aW9uLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQub3duZXIucm90YXRpb24gPSAzLjc1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgcGxheWVyXG4gICAgICAgIHRoaXMucGFyZW50Lm93bmVyLm1vdmUodGhpcy5wYXJlbnQuY29udHJvbGxlci5tb3ZlRGlyKTtcblxuICAgICAgICAvLyBpZiAodGhpcy5wYXJlbnQuY29udHJvbGxlci5hdHRhY2tpbmcpIHtcblxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmICh0aGlzLnBhcmVudC5jb250cm9sbGVyLnNoaWVsZGluZykge1xuXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBIYW5kbGUgdGhlIHBsYXllciB0cnlpbmcgdG8gcGljayB1cCBhbiBpdGVtXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5jb250cm9sbGVyLnBpY2tpbmdVcCkge1xuICAgICAgICAgICAgLy8gUmVxdWVzdCBhbiBpdGVtIGZyb20gdGhlIHNjZW5lXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEl0ZW1FdmVudC5JVEVNX1JFUVVFU1QsIHtub2RlOiB0aGlzLm93bmVyLCBpbnZlbnRvcnk6IHRoaXMub3duZXIuaW52ZW50b3J5fSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgdGhlIHBsYXllciB0cnlpbmcgdG8gZHJvcCBhbiBpdGVtXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5jb250cm9sbGVyLmRyb3BwaW5nKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5jb250cm9sbGVyLnVzZUl0ZW0pIHtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBldmVudCBvZiB0eXBlICR7ZXZlbnQudHlwZX0gY2F1Z2h0IGluIFBsYXllclN0YXRlIWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmltcG9ydCBJZGxlIGZyb20gXCIuL0lkbGVcIjtcbmltcG9ydCBTaGllbGRpbmcgZnJvbSBcIi4vU2hpZWxkaW5nXCI7XG5pbXBvcnQgTW92aW5nIGZyb20gXCIuL01vdmluZ1wiO1xuaW1wb3J0IEF0dGFja2luZyBmcm9tIFwiLi9BdHRhY2tpbmdcIjtcbmltcG9ydCBEZWFkIGZyb20gXCIuL0RlYWRcIjtcbmltcG9ydCBQbGF5ZXJBY3RvciBmcm9tIFwiLi4vLi4vLi4vQWN0b3JzL1BsYXllckFjdG9yXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCB7IFBsYXllckFuaW1hdGlvbnMgfSBmcm9tIFwiLi4vUGxheWVyQ29udHJvbGxlclwiO1xuZXhwb3J0IHsgSWRsZSwgU2hpZWxkaW5nLCBNb3ZpbmcsIERlYWQsIEF0dGFja2luZ30gIiwiaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IFRpbWVyIGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcbmltcG9ydCBQbGF5ZXJBY3RvciBmcm9tIFwiLi4vLi4vLi4vQWN0b3JzL1BsYXllckFjdG9yXCI7XG5pbXBvcnQgUGxheWVyQUkgZnJvbSBcIi4uL1BsYXllckFJXCI7XG5pbXBvcnQgeyBQbGF5ZXJBbmltYXRpb25zIH0gZnJvbSBcIi4uL1BsYXllckNvbnRyb2xsZXJcIjtcbmltcG9ydCBQbGF5ZXJTdGF0ZSwgeyBQbGF5ZXJTdGF0ZVR5cGUgfSBmcm9tIFwiLi9QbGF5ZXJTdGF0ZVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hpZWxkaW5nIGV4dGVuZHMgUGxheWVyU3RhdGUge1xuXG4gICAgcHJvdGVjdGVkIHRpbWVyOiBUaW1lcjtcbiAgICBcbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgICAgIHRoaXMucGFyZW50Lm93bmVyLmFuaW1hdGlvbi5wbGF5KFBsYXllckFuaW1hdGlvbnMuU0hJRUxESU5HLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucGFyZW50Lm93bmVyLl9haVtcImN1cnJlbnRTdGF0XCJdW1wiY3VycmVudFNoaWVsZFwiXSA9IDA7XG4gICAgICAgXG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudC5vd25lci5hbmltYXRpb24uaXNQbGF5aW5nKFBsYXllckFuaW1hdGlvbnMuU0hJRUxESU5HKSkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChQbGF5ZXJTdGF0ZVR5cGUuSURMRSk7XG4gICAgICAgIH0gIFxuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4geyBcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn0iLCJleHBvcnQgY29uc3QgQUNUSU9OVFlQRSA9IHtcbiAgICBQSUNLOiBcIlBJQ0tcIixcbiAgICBVU0U6IFwiVVNFXCIsXG59IiwiaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcbmltcG9ydCB7IEJhdHRsZXJFdmVudHMsIEh1ZEV2ZW50IH0gZnJvbSBcIi4uL1Byb2plY3RFdmVudHNcIjtcbmltcG9ydCBJbnZlbnRvcnkgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSW52ZW50b3J5XCI7XG5pbXBvcnQgSFc0U2NlbmUgZnJvbSBcIi4uL1NjZW5lcy9BYnN0cmFjdFNjZW5lXCI7XG5pbXBvcnQgQmFzaWNUYXJnZXRhYmxlIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvQmFzaWNUYXJnZXRhYmxlXCI7XG5pbXBvcnQgQmFzaWNUYXJnZXRpbmcgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9CYXNpY1RhcmdldGluZ1wiO1xuXG5pbXBvcnQgQmF0dGxlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQmF0dGxlU3lzdGVtL0JhdHRsZXJcIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvVGFyZ2V0aW5nL1RhcmdldGFibGVFbnRpdHlcIjtcbmltcG9ydCB7IFRhcmdldGluZ0VudGl0eSB9IGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvVGFyZ2V0aW5nRW50aXR5XCI7XG5pbXBvcnQgQmFzaWNCYXR0bGVyIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9CYXR0bGVTeXN0ZW0vQmFzaWNCYXR0bGVyXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5QQ0FjdG9yIGV4dGVuZHMgQW5pbWF0ZWRTcHJpdGUgaW1wbGVtZW50cyBCYXR0bGVyLCBUYXJnZXRpbmdFbnRpdHkge1xuXG4gICAgLyoqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSBzY2VuZSB0byBiZSB0aGUgSFc0IHNjZW5lICovXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBIVzRTY2VuZVxuXG4gICAgLy8gQW4gc2hpZWxkaW5nIHRpbWVyIGZvciBvdXIgTlBDc1xuICAgIHByb3RlY3RlZCBzaGllbGRpbmdUaW1lcjogVGltZXI7XG5cbiAgICAvLyBUaGUga2V5IG9mIHRoZSBOYXZtZXNoIHRvIHVzZSB0byBidWlsZCBwYXRocyBmb3IgdGhpcyBOUENBY3RvclxuICAgIHByb3RlY3RlZCBfbmF2a2V5OiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgTlBDcyBiYXR0bGVyIG9iamVjdFxuICAgIHByb3RlY3RlZCBfYmF0dGxlcjogQmF0dGxlcjtcblxuICAgIHByb3RlY3RlZCBfdGFyZ2V0aW5nOiBUYXJnZXRpbmdFbnRpdHlcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihzaGVldDogU3ByaXRlc2hlZXQpIHtcbiAgICAgICAgc3VwZXIoc2hlZXQpO1xuICAgICAgICB0aGlzLl9uYXZrZXkgPSBcIm5hdmtleVwiO1xuICAgICAgICB0aGlzLl9iYXR0bGVyID0gbmV3IEJhc2ljQmF0dGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0aW5nID0gbmV3IEJhc2ljVGFyZ2V0aW5nKHRoaXMpO1xuICAgICAgICB0aGlzLnNoaWVsZGluZ1RpbWVyID0gbmV3IFRpbWVyKDEwMDApO1xuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwidXNlLWhwYWNrXCIpO1xuICAgIH1cblxuICAgIC8qKiBUaGUgVGFyZ2V0aW5nRW50aXR5IGludGVyZmFjZSAqL1xuXG4gICAgcHVibGljIGNsZWFyVGFyZ2V0KCk6IHZvaWQgeyB0aGlzLl90YXJnZXRpbmcuY2xlYXJUYXJnZXQoKTsgfVxuICAgIHB1YmxpYyBzZXRUYXJnZXQodGFyZ2V0YWJsZTogVGFyZ2V0YWJsZUVudGl0eSk6IHZvaWQgeyB0aGlzLl90YXJnZXRpbmcuc2V0VGFyZ2V0KHRhcmdldGFibGUpOyB9XG4gICAgcHVibGljIGhhc1RhcmdldCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3RhcmdldGluZy5oYXNUYXJnZXQoKTsgfVxuICAgIHB1YmxpYyBnZXRUYXJnZXQoKTogVGFyZ2V0YWJsZUVudGl0eSB7IHJldHVybiB0aGlzLl90YXJnZXRpbmcuZ2V0VGFyZ2V0KCk7IH1cbiAgICBcbiAgICAvKiogVGhlIFRhcmdldGFibGVFbnRpdHkgaW50ZXJmYWNlICovXG5cbiAgICBwdWJsaWMgZ2V0VGFyZ2V0aW5nKCk6IFRhcmdldGluZ0VudGl0eVtdIHsgcmV0dXJuIHRoaXMuX2JhdHRsZXIuZ2V0VGFyZ2V0aW5nKCk7IH1cbiAgICBwdWJsaWMgYWRkVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7IHRoaXMuX2JhdHRsZXIuYWRkVGFyZ2V0aW5nKHRhcmdldGluZyk7IH1cbiAgICBwdWJsaWMgcmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7IHRoaXMuX2JhdHRsZXIucmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZyk7IH1cblxuICAgIGF0VGFyZ2V0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0aW5nLmdldFRhcmdldCgpLnBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLnBvc2l0aW9uKSA8IDYyNTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGJhdHRsZXJBY3RpdmUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLmJhdHRsZXIuYmF0dGxlckFjdGl2ZTsgfVxuICAgIHB1YmxpYyBzZXQgYmF0dGxlckFjdGl2ZSh2YWx1ZTogYm9vbGVhbikgeyBcbiAgICAgICAgdGhpcy5iYXR0bGVyLmJhdHRsZXJBY3RpdmUgPSB2YWx1ZTsgXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmFpQWN0aXZlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBiYXR0bGVHcm91cCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5iYXR0bGVyLmJhdHRsZUdyb3VwOyB9XG4gICAgcHVibGljIHNldCBiYXR0bGVHcm91cChiYXR0bGVHcm91cDogbnVtYmVyKSB7IHRoaXMuYmF0dGxlci5iYXR0bGVHcm91cCA9IGJhdHRsZUdyb3VwOyB9XG5cbiAgICBwdWJsaWMgZ2V0IG1heEhlYWx0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5iYXR0bGVyLm1heEhlYWx0aCB9XG4gICAgcHVibGljIHNldCBtYXhIZWFsdGgobWF4SGVhbHRoOiBudW1iZXIpIHsgXG4gICAgICAgIHRoaXMuYmF0dGxlci5tYXhIZWFsdGggPSBtYXhIZWFsdGg7IFxuICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEh1ZEV2ZW50LkhFQUxUSF9DSEFOR0UsIHtpZDogdGhpcy5pZCwgY3VyaHA6IHRoaXMuaGVhbHRoLCBtYXhocDogdGhpcy5tYXhIZWFsdGh9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGhlYWx0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5iYXR0bGVyLmhlYWx0aDsgfVxuICAgIHB1YmxpYyBzZXQgaGVhbHRoKGhlYWx0aDogbnVtYmVyKSB7IFxuICAgICAgICB0aGlzLmJhdHRsZXIuaGVhbHRoID0gaGVhbHRoOyBcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoIDw9IDAgJiYgdGhpcy5iYXR0bGVyQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEJhdHRsZXJFdmVudHMuTU9OU1RFUl9ERUFELCB7aWQ6IHRoaXMuaWR9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc3BlZWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuYmF0dGxlci5zcGVlZDsgfVxuICAgIHB1YmxpYyBzZXQgc3BlZWQoc3BlZWQ6IG51bWJlcikgeyB0aGlzLmJhdHRsZXIuc3BlZWQgPSBzcGVlZDsgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHNldFNjZW5lKHNjZW5lOiBIVzRTY2VuZSk6IHZvaWQgeyB0aGlzLnNjZW5lID0gc2NlbmU7IH1cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0U2NlbmUoKTogSFc0U2NlbmUgeyByZXR1cm4gdGhpcy5zY2VuZTsgfVxuXG4gICAgcHVibGljIGdldCBuYXZrZXkoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX25hdmtleTsgfVxuICAgIHB1YmxpYyBzZXQgbmF2a2V5KG5hdmtleTogc3RyaW5nKSB7IHRoaXMuX25hdmtleSA9IG5hdmtleTsgfVxuXG4gICAgZ2V0UGF0aCh0bzogVmVjMiwgZnJvbTogVmVjMik6IE5hdmlnYXRpb25QYXRoIHsgXG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lLmdldE5hdmlnYXRpb25NYW5hZ2VyKCkuZ2V0UGF0aCh0aGlzLm5hdmtleSwgdG8sIGZyb20pO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgaW52ZW50b3J5KCk6IEludmVudG9yeSB7IHJldHVybiB0aGlzLmJhdHRsZXIuaW52ZW50b3J5OyB9XG5cbiAgICAvKiogUHJvdGVjdGVkIGdldHRlcnMgZm9yIHRoZSBkaWZmZXJlbnQgY29tcG9uZW50cyAqL1xuXG4gICAgcHJvdGVjdGVkIGdldCBiYXR0bGVyKCk6IEJhdHRsZXIgeyByZXR1cm4gdGhpcy5fYmF0dGxlcjsgfVxuICAgIHByb3RlY3RlZCBnZXQgdGFyZ2V0aW5nKCk6IFRhcmdldGluZ0VudGl0eSB7IHJldHVybiB0aGlzLl90YXJnZXRpbmc7IH1cbn0iLCJpbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgeyBCYXR0bGVyRXZlbnRzLCBJdGVtRXZlbnQgfSBmcm9tIFwiLi4vUHJvamVjdEV2ZW50c1wiO1xuaW1wb3J0IEJhc2ljQmF0dGxlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQmF0dGxlU3lzdGVtL0Jhc2ljQmF0dGxlclwiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXR0bGVyXCI7XG5pbXBvcnQgSW52ZW50b3J5IGZyb20gXCIuLi9HYW1lU3lzdGVtcy9JdGVtU3lzdGVtL0ludmVudG9yeVwiO1xuaW1wb3J0IEhXNEl0ZW0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSXRlbVwiO1xuaW1wb3J0IEJhc2ljVGFyZ2V0YWJsZSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvVGFyZ2V0aW5nL0Jhc2ljVGFyZ2V0YWJsZVwiO1xuaW1wb3J0IHsgVGFyZ2V0YWJsZUVudGl0eSB9IGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvVGFyZ2V0YWJsZUVudGl0eVwiO1xuaW1wb3J0IHsgVGFyZ2V0aW5nRW50aXR5IH0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL1RhcmdldGluZy9UYXJnZXRpbmdFbnRpdHlcIjtcbmltcG9ydCBIVzRTY2VuZSBmcm9tIFwiLi4vU2NlbmVzL0Fic3RyYWN0U2NlbmVcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXJBY3RvciBleHRlbmRzIEFuaW1hdGVkU3ByaXRlIGltcGxlbWVudHMgQmF0dGxlciB7XG5cbiAgICAvKiogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHNjZW5lIHRvIGJlIHRoZSBIVzQgc2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmU6IEhXNFNjZW5lXG5cbiAgICAvKiogR2l2ZSB0aGUgcGxheWVyIGEgYmF0dGxlciBjb21wb29uZW50ICovXG4gICAgcHJvdGVjdGVkIGJhdHRsZXI6IEJhdHRsZXI7XG4gICAgcHJvdGVjdGVkIHRhcmdldGFibGU6IFRhcmdldGFibGVFbnRpdHk7XG5cbiAgICBwcm90ZWN0ZWQgaGVsZEl0ZW06IEhXNEl0ZW07XG5cbiAgICBjb25zdHJ1Y3RvcihzaGVldDogU3ByaXRlc2hlZXQpIHtcbiAgICAgICAgc3VwZXIoc2hlZXQpO1xuICAgICAgICB0aGlzLmJhdHRsZXIgPSBuZXcgQmFzaWNCYXR0bGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnRhcmdldGFibGUgPSBuZXcgQmFzaWNUYXJnZXRhYmxlKHRoaXMpO1xuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEl0ZW1FdmVudC5MQVNFUkdVTl9GSVJFRClcbiAgICB9XG5cbiAgICBnZXQgYmF0dGxlckFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5iYXR0bGVyQWN0aXZlO1xuICAgIH1cbiAgICBzZXQgYmF0dGxlckFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmJhdHRsZXIuYmF0dGxlckFjdGl2ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgXG4gICAgcHVibGljIGdldFRhcmdldGluZygpOiBUYXJnZXRpbmdFbnRpdHlbXSB7IHJldHVybiB0aGlzLnRhcmdldGFibGUuZ2V0VGFyZ2V0aW5nKCk7IH1cbiAgICBwdWJsaWMgYWRkVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7IHRoaXMudGFyZ2V0YWJsZS5hZGRUYXJnZXRpbmcodGFyZ2V0aW5nKTsgfVxuICAgIHB1YmxpYyByZW1vdmVUYXJnZXRpbmcodGFyZ2V0aW5nOiBUYXJnZXRpbmdFbnRpdHkpOiB2b2lkIHsgdGhpcy50YXJnZXRhYmxlLnJlbW92ZVRhcmdldGluZyh0YXJnZXRpbmcpOyB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0U2NlbmUoc2NlbmU6IEhXNFNjZW5lKTogdm9pZCB7IHRoaXMuc2NlbmUgPSBzY2VuZTsgfVxuICAgIHB1YmxpYyBvdmVycmlkZSBnZXRTY2VuZSgpOiBIVzRTY2VuZSB7IHJldHVybiB0aGlzLnNjZW5lOyB9XG5cbiAgICBnZXQgYmF0dGxlR3JvdXAoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5iYXR0bGVHcm91cDtcbiAgICB9XG4gICAgc2V0IGJhdHRsZUdyb3VwKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5iYXR0bGVyLmJhdHRsZUdyb3VwID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBtYXhIZWFsdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5tYXhIZWFsdGg7XG4gICAgfVxuICAgIHNldCBtYXhIZWFsdGgodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLmJhdHRsZXIubWF4SGVhbHRoID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBoZWFsdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5oZWFsdGg7XG4gICAgfVxuICAgIHNldCBoZWFsdGgodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLmJhdHRsZXIuaGVhbHRoID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmhlYWx0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEJhdHRsZXJFdmVudHMuTU9OU1RFUl9ERUFELCB7aWQ6IHRoaXMuaWR9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3BlZWQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5zcGVlZDtcbiAgICB9XG4gICAgc2V0IHNwZWVkKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5iYXR0bGVyLnNwZWVkID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBpbnZlbnRvcnkoKTogSW52ZW50b3J5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0dGxlci5pbnZlbnRvcnk7XG4gICAgfVxufSIsIi8qKlxuICogQSBzZXQgb2YgY29udHJvbHMgZm9yIHRoZSBIVzQga2V5YmluZGluZ1xuICovXG5leHBvcnQgY29uc3QgSFczQ29udHJvbHMgPSB7XG4gICAgQVRUQUNLSU5HOiBcIkFUVEFDS0lOR1wiLCBcbiAgICBTSElFTERJTkc6IFwiU0hFSUxESU5HXCJcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IGxlbmd0aCA9IDY7XG5mdW5jdGlvbiBjcmVhdGVJdGVtQnV0dG9uQXJyYXkgKCl7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAxO2k8bGVuZ3RoO2krKyl7XG4gICAgICAgIGFycmF5LnB1c2goaS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxuZXhwb3J0IGNvbnN0IEl0ZW1CdXR0b25BcnJheT1jcmVhdGVJdGVtQnV0dG9uQXJyYXkoKTsiLCJleHBvcnQgZW51bSBNYWluTWVudUJ1dHRvbkV2ZW50IHtcbiAgICBSZXN0YXJ0PVwiUmVzdGFydFwiLFxuICAgIFNlbGVjdF9sZXZlbHM9XCJTZWxlY3QgbGV2ZWxzXCIsXG4gICAgQ29udHJvbHMgPSBcIkNvbnRyb2xzXCIsXG4gICAgSGVscCA9IFwiSGVscFwiLFxuICAgIENIRUFUID0gXCJDSEVBVFwiLFxuICAgIEV4aXQ9XCJFeGl0XCIsXG4gICBcbn1cblxuZXhwb3J0IGVudW0gU2VsZWN0TWVudUJ1dHRvbkV2ZW50IHtcbiAgICBMRVZFTF8xID0gXCJJTlRST1wiLFxuICAgIExFVkVMXzIgPSBcIlJFR1VMQVJcIixcbiAgICBMRVZFTF8zID0gXCJTUEVFRCBSVU5cIixcbiAgICBMRVZFTF80ID0gXCJUUkVBU1VSRSBIVU5URVJcIixcbiAgICBMRVZFTF81ID0gXCJDUklOR0VcIixcbiAgICBMRVZFTF82ID0gXCJGSU5BTCBCT1NTXCIsXG4gICAgXG59XG5leHBvcnQgZW51bSBQYXVzZUJ1dHRvbkV2ZW50IHtcbiAgICBQQVVTRSA9IFwiUEFVU0VcIixcbn1cbmV4cG9ydCBlbnVtIFN0YXJ0TWVudUJ1dHRvbkV2ZW50IHtcbiAgICBTVEFSVF9HQU1FPVwiU3RhcnQgR2FtZVwiLFxufVxuXG5leHBvcnQgZW51bSBCYWNrQnV0dG9uRXZlbnQge1xuICAgIEJBQ0s9XCJCQUNLXCIsXG59XG5cblxuXG4iLCJleHBvcnQgZW51bSBHYW1lSXRlbXMge1xuICAgIExBTlRFUk5TID0gXCJsYW50ZXJuXCIsXG4gICAgRE9PUiA9IFwiZG9vclwiLFxuICAgIEhFQUxUSF9QQUNLUyA9IFwiaGVhbHRoUGFja3NcIixcbiAgICBJTlZFTlRPUllTTE9UID0gXCJpbnZlbnRvcnlTbG90XCIsXG4gICAgUEhBU0lOR1BPVElPTj1cInBoYXNpbmdQb3Rpb25cIlxuICB9XG5mdW5jdGlvbiBjcmVhdGVHYW1lSXRlbXNBcnJheSgpe1xuICBsZXQgR2FtZUl0ZW1zQXJyYXkgPSBbXVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhHYW1lSXRlbXMpKSB7XG4gICAgR2FtZUl0ZW1zQXJyYXkucHVzaChHYW1lSXRlbXNba2V5XSk7XG4gIH1cbiAgcmV0dXJuIEdhbWVJdGVtc0FycmF5O1xufVxuZXhwb3J0IGNvbnN0IEdhbWVJdGVtc0FycmF5ID0gY3JlYXRlR2FtZUl0ZW1zQXJyYXkoKTtcbiIsIi8vIGJhc2VMYXllciAoYmFzZSBsYXllciwgd2hlcmUgdGlsZW1hcCwgaXRlbSwgcGxheWVyLCBsZXZlbCBlbmQgbG9jYXRlcylcblxuLy8gZm9nIG9mICB3YXIgbGF5ZXIgKG1ha2UgdGhlIHNjcmVlbiBibGFjayApXG5cbi8vIGNvbnRhaW5lciBsYXllciAoY29udGFpbmVyIGZvciBuZXh0IGxheWVyLCB0byBzZXJ2ZSBhcyBhIGJhY2tncm91bmQgZm9yIHRoZSBhY3R1YWwgbWVudSAgKVxuIFxuLy8gUEFVU0VfTUVOVSBsYXllciAoZGlzcGxheSB0aGUgcGF1c2UgbWVudSBzZWxlY3Rpb24gKVxuXG4vLyBURVhUX01FTlUgbGF5ZXIoZGlzcGxheSBoZWxwIGFuZCBjb250cm9scylcblxuLy8gVUkgbGF5ZXIoZGlzcGxheSB0aGUgcGxheWVyIGFuZCBnYW1lIHN0YXR1cyApXG5cblxuZXhwb3J0IGVudW0gR2FtZUxheWVycyB7XG4gICAgQkVGT1JFX0JBU0UgPSBcIkJFRk9SRV9CQVNFXCIsXG4gICAgQkFTRSA9IFwiQkFTRVwiLFxuICAgIEZPR19PRl9XQVIgPSBcIkZPR19PRl9XQVJcIixcbiAgICBQQVVTRV9NRU5VX0NPTlRBSU5FUiA9IFwiUEFVU0VfTUVOVV9DT05UQUlORVJcIixcbiAgICBQQVVTRV9NRU5VID0gXCJQQVVTRV9NRU5VXCIsXG4gICAgQ09OVFJPTF9URVhUX01FTlVfQ09OVEFJTkVSID0gXCJDT05UUk9MX1RFWFRfTUVOVV9DT05UQUlORVJcIixcbiAgICBDT05UUk9MX1RFWFRfTUVOVSA9IFwiQ09OVFJPTF9URVhUX01FTlVcIixcbiAgICBIRUxQX1RFWFRfTUVOVV9DT05UQUlORVIgPSBcIkhFTFBfVEVYVF9NRU5VX0NPTlRBSU5FUlwiLFxuICAgIEhFTFBfVEVYVF9NRU5VID0gXCJIRUxQX1RFWFRfTUVOVVwiLFxuICAgIFVJID0gXCJVSVwiLFxufSAiLCJpbXBvcnQgUG9zaXRpb25lZCBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvUG9zaXRpb25lZFwiO1xuaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBJbnZlbnRvcnkgZnJvbSBcIi4uL0l0ZW1TeXN0ZW0vSW52ZW50b3J5XCI7XG5pbXBvcnQgQmFzaWNUYXJnZXRhYmxlIGZyb20gXCIuLi9UYXJnZXRpbmcvQmFzaWNUYXJnZXRhYmxlXCI7XG5pbXBvcnQgeyBUYXJnZXRhYmxlRW50aXR5IH0gZnJvbSBcIi4uL1RhcmdldGluZy9UYXJnZXRhYmxlRW50aXR5XCI7XG5pbXBvcnQgeyBUYXJnZXRpbmdFbnRpdHkgfSBmcm9tIFwiLi4vVGFyZ2V0aW5nL1RhcmdldGluZ0VudGl0eVwiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4vQmF0dGxlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY0JhdHRsZXIgaW1wbGVtZW50cyBCYXR0bGVyIHtcblxuICAgIHByb3RlY3RlZCBfb3duZXI6IFVuaXF1ZSAmIFBvc2l0aW9uZWQ7XG4gICAgcHJvdGVjdGVkIF90YXJnZXRhYmxlOiBUYXJnZXRhYmxlRW50aXR5O1xuICAgIHByb3RlY3RlZCBfaW52ZW50b3J5OiBJbnZlbnRvcnk7XG5cbiAgICBwcm90ZWN0ZWQgX21heEhlYWx0aDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfaGVhbHRoOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9iYXR0bGVHcm91cDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfc3BlZWQ6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2FjdGl2ZTogYm9vbGVhbjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihvd25lcjogVW5pcXVlICYgUG9zaXRpb25lZCkge1xuICAgICAgICB0aGlzLl9vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLl90YXJnZXRhYmxlID0gbmV3IEJhc2ljVGFyZ2V0YWJsZShvd25lcik7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5ID0gbmV3IEludmVudG9yeSgpO1xuXG4gICAgICAgIHRoaXMubWF4SGVhbHRoID0gMDtcbiAgICAgICAgdGhpcy5oZWFsdGggPSAwO1xuICAgICAgICB0aGlzLmJhdHRsZUdyb3VwID0gMDtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDA7XG4gICAgICAgIHRoaXMuYmF0dGxlckFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX293bmVyLmlkOyB9XG5cbiAgICBwdWJsaWMgZ2V0IHBvc2l0aW9uKCk6IFZlYzIgeyByZXR1cm4gdGhpcy5fdGFyZ2V0YWJsZS5wb3NpdGlvbjsgfVxuICAgIHB1YmxpYyBzZXQgcG9zaXRpb24ocG9zaXRpb246IFZlYzIpIHsgdGhpcy5fdGFyZ2V0YWJsZS5wb3NpdGlvbiA9IHBvc2l0aW9uOyB9XG5cbiAgICBwdWJsaWMgZ2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRhYmxlLnJlbGF0aXZlUG9zaXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBiYXR0bGVHcm91cCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fYmF0dGxlR3JvdXA7IH1cbiAgICBwdWJsaWMgc2V0IGJhdHRsZUdyb3VwKGJhdHRsZUdyb3VwOiBudW1iZXIpIHsgdGhpcy5fYmF0dGxlR3JvdXAgPSBiYXR0bGVHcm91cDsgfVxuXG4gICAgcHVibGljIGdldCBtYXhIZWFsdGgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX21heEhlYWx0aCB9XG4gICAgcHVibGljIHNldCBtYXhIZWFsdGgobWF4SGVhbHRoOiBudW1iZXIpIHsgdGhpcy5fbWF4SGVhbHRoID0gbWF4SGVhbHRoOyB9XG5cbiAgICBwdWJsaWMgZ2V0IGhlYWx0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faGVhbHRoOyB9XG4gICAgcHVibGljIHNldCBoZWFsdGgoaGVhbHRoOiBudW1iZXIpIHsgdGhpcy5faGVhbHRoID0gaGVhbHRoOyB9XG5cbiAgICBwdWJsaWMgZ2V0IHNwZWVkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9zcGVlZDsgfVxuICAgIHB1YmxpYyBzZXQgc3BlZWQoc3BlZWQ6IG51bWJlcikgeyB0aGlzLl9zcGVlZCA9IHNwZWVkOyB9XG5cbiAgICBwdWJsaWMgZ2V0IGludmVudG9yeSgpOiBJbnZlbnRvcnkgeyByZXR1cm4gdGhpcy5faW52ZW50b3J5OyB9XG4gICAgcHJvdGVjdGVkIHNldCBpbnZlbnRvcnkoaW52ZW50b3J5OiBJbnZlbnRvcnkpIHsgdGhpcy5faW52ZW50b3J5ID0gaW52ZW50b3J5OyB9XG5cbiAgICBwdWJsaWMgZ2V0IGJhdHRsZXJBY3RpdmUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9hY3RpdmU7IH1cbiAgICBwdWJsaWMgc2V0IGJhdHRsZXJBY3RpdmUodmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fYWN0aXZlID0gdmFsdWU7IH1cbiAgICBcbiAgICBwdWJsaWMgZ2V0VGFyZ2V0aW5nKCk6IFRhcmdldGluZ0VudGl0eVtdIHsgcmV0dXJuIHRoaXMuX3RhcmdldGFibGUuZ2V0VGFyZ2V0aW5nKCk7IH1cbiAgICBwdWJsaWMgYWRkVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7IHRoaXMuX3RhcmdldGFibGUuYWRkVGFyZ2V0aW5nKHRhcmdldGluZyk7IH1cbiAgICBwdWJsaWMgcmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7IHRoaXMuX3RhcmdldGFibGUucmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZyk7IH1cbn0iLCJpbXBvcnQgVW5pcXVlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IEl0ZW0gZnJvbSBcIi4vSXRlbVwiO1xuaW1wb3J0IEhlYWx0aHBhY2sgZnJvbSBcIi4vSXRlbXMvSGVhbHRocGFja1wiO1xuXG4vKipcbiAqIEFuIGludmVudG9yeSBpcyBhIGNvbGxlY3Rpb24gb2YgaXRlbXMuIEFsbCBpdGVtcyBpbiB0aGUgaW52ZW50b3J5IG11c3QgYmUgcmVnaXN0ZXJlZCB3aXRoXG4gKiB0aGUgSW52ZW50b3J5cyBJdGVtTWFuYWdlciBjbGFzcy4gXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmVudG9yeSBpbXBsZW1lbnRzIFVuaXF1ZSB7XG5cbiAgICAvKiogVGhlIGlkIG51bWJlciBvZiB0aGUgbmV4dCBpbnZlbnRvcnkgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBORVhUX0lEOiBudW1iZXIgPSAwO1xuXG4gICAgLyoqIFRoZSBpZCBvZiB0aGlzIGludmVudG9yeSAqL1xuICAgIHByb3RlY3RlZCBfX2lkOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGNvbGxlY3Rpb24gb2YgaXRlbXMgaW4gdGhlIGludmVudG9yeSAqL1xuICAgIHByb3RlY3RlZCBfaW52ZW50b3J5OiBNYXA8bnVtYmVyLCBJdGVtPjtcblxuICAgIC8qKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSAqL1xuICAgIHByb3RlY3RlZCBfZGlydHk6IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRoaXMgaW52ZW50b3J5IGNhbiBob2xkICovXG4gICAgcHJvdGVjdGVkIF9jYXBhY2l0eTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhpcyBpbnZlbnRvcnkgKi9cbiAgICBwcm90ZWN0ZWQgX3NpemU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgZXZlbnQgdG8gZmlyZSB3aGVuIHRoaXMgaW52ZW50b3J5IGNoYW5nZXMgKi9cbiAgICBwcm90ZWN0ZWQgX29uQ2hhbmdlOiBzdHJpbmcgfCBudWxsO1xuXG4gICAgLyoqIEFuIGVtaXR0ZXIgdXNlZCB0byBlbWl0IGV2ZW50cyB3aGVuIHRoaXMgaW52ZW50b3J5IGNoYW5nZXMgKi9cbiAgICBwcm90ZWN0ZWQgX2VtaXR0ZXI6IEVtaXR0ZXI7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoY2FwYWNpdHk6IG51bWJlciA9IDEwKSB7XG4gICAgICAgIHRoaXMuX19pZCA9IEludmVudG9yeS5ORVhUX0lEIFxuICAgICAgICBJbnZlbnRvcnkuTkVYVF9JRCArPSAxO1xuXG4gICAgICAgIHRoaXMuaW52ZW50b3J5ID0gbmV3IE1hcDxudW1iZXIsIEl0ZW0+KCk7XG4gICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgcHVibGljIGdldCBpZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fX2lkOyB9XG5cbiAgICBwdWJsaWMgZ2V0IGRpcnR5KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fZGlydHk7IH1cbiAgICBwcm90ZWN0ZWQgc2V0IGRpcnR5KGRpcnR5OiBib29sZWFuKSB7IHRoaXMuX2RpcnR5ID0gZGlydHk7IH1cblxuICAgIHB1YmxpYyBnZXQgc2l6ZSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fc2l6ZTsgfVxuICAgIHByb3RlY3RlZCBzZXQgc2l6ZShzaXplOiBudW1iZXIpIHsgdGhpcy5fc2l6ZSA9IHNpemU7IH1cblxuICAgIHB1YmxpYyBnZXQgY2FwYWNpdHkoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2NhcGFjaXR5OyB9XG4gICAgcHJvdGVjdGVkIHNldCBjYXBhY2l0eShjYXBhY2l0eTogbnVtYmVyKSB7IHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7IH1cblxuICAgIHB1YmxpYyBnZXQgb25DaGFuZ2UoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX29uQ2hhbmdlOyB9XG4gICAgcHVibGljIHNldCBvbkNoYW5nZShvbkNoYW5nZTogc3RyaW5nKSB7IHRoaXMuX29uQ2hhbmdlID0gb25DaGFuZ2U7IH1cblxuICAgIHByb3RlY3RlZCBnZXQgaW52ZW50b3J5KCk6IE1hcDxudW1iZXIsIEl0ZW0+IHsgcmV0dXJuIHRoaXMuX2ludmVudG9yeTsgfVxuICAgIHByb3RlY3RlZCBzZXQgaW52ZW50b3J5KGludmVudG9yeTogTWFwPG51bWJlciwgSXRlbT4pIHsgdGhpcy5faW52ZW50b3J5ID0gaW52ZW50b3J5OyB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGVtaXR0ZXIoKTogRW1pdHRlciB7IHJldHVybiB0aGlzLl9lbWl0dGVyOyB9XG4gICAgcHJvdGVjdGVkIHNldCBlbWl0dGVyKGVtaXR0ZXI6IEVtaXR0ZXIpIHsgdGhpcy5fZW1pdHRlciA9IGVtaXR0ZXI7IH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gaXRlbSBmcm9tIHRoaXMgaW52ZW50b3J5IGJ5IGlkLlxuICAgICAqIEBwYXJhbSBpZCB0aGUgaWQgb2YgdGhlIGl0ZW0gdG8gZ2V0XG4gICAgICogQHJldHVybnMgdGhlIGl0ZW0gaWYgaXQgZXhpc3RzOyBudWxsIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQoaWQ6IG51bWJlcik6IEl0ZW0gfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmludmVudG9yeS5nZXQoaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGlzIGludmVudG9yeVxuICAgICAqIEBwYXJhbSBpdGVtIGFkZHMgYW4gaXRlbSB0byB0aGUgaW52ZW50b3J5IHdpdGggdGhlIGtleSBvZiB0aGUgaXRlbXMgb3duZXJcbiAgICAgKiBAcmV0dXJucyBpZiB0aGUgSXRlbSB3YXMgc3VjY2Vzc2Z1bGx5IGFkZGVkIHRvIHRoZSBpbnZlbnRvcnk7IG51bGwgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgcHVibGljIGFkZChpdGVtOiBJdGVtKTogSXRlbSB8IG51bGwgeyBcbiAgICAgICAgaWYgKHRoaXMuaGFzKGl0ZW0uaWQpIHx8IHRoaXMuc2l6ZSA+PSB0aGlzLmNhcGFjaXR5IHx8IGl0ZW0uaW52ZW50b3J5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludmVudG9yeS5zZXQoaXRlbS5pZCwgaXRlbSk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSAxO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICBpdGVtLmludmVudG9yeSA9IHRoaXM7XG4gICAgICAgIGl0ZW0udmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhbiBpdGVtIHdpdGggdGhlIGdpdmVuIGlkIG51bWJlciBleGlzdHMgaW4gdGhpcyBpbnZlbnRvcnkuXG4gICAgICogQHBhcmFtIGlkIHRoZSBpZCBvZiB0aGUgaXRlbSBpbiB0aGUgaW52ZW50b3J5XG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaXRlbSB3aXRoIHRoZSBpZCBleGlzdHM7IGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHB1YmxpYyBoYXMoaWQ6IG51bWJlcik6IGJvb2xlYW4geyBcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZW50b3J5LmhhcyhpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgaXRlbSB3aXRoIHRoZSBnaXZlbiBpZCBudW1iZXIgZnJvbSB0aGlzIGludmVudG9yeVxuICAgICAqIEBwYXJhbSBpZCB0aGUgaWQgb2YgdGhlIGl0ZW1cbiAgICAgKiBAcmV0dXJucyB0aGUgaXRlbSB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZShpZDogbnVtYmVyKTogSXRlbSB8IG51bGwgeyBcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpdGVtOiBJdGVtID0gdGhpcy5nZXQoaWQpO1xuICAgICAgICB0aGlzLmludmVudG9yeS5kZWxldGUoaWQpO1xuICAgICAgICB0aGlzLnNpemUgLT0gMTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWVcblxuICAgICAgICBpdGVtLmludmVudG9yeSA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgcHVibGljIGl0ZW1zKCk6IEl0ZXJhYmxlSXRlcmF0b3I8SXRlbT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZlbnRvcnkudmFsdWVzKClcbiAgICB9XG5cbiAgICBwdWJsaWMgZmluZChmdW5jOiAoaXRlbTogSXRlbSkgPT4gYm9vbGVhbik6IEl0ZW0gfCBudWxsIHtcbiAgICAgICAgbGV0IGl0ZW0gPSBBcnJheS5mcm9tKHRoaXMuaW52ZW50b3J5LnZhbHVlcygpKS5maW5kKGZ1bmMpO1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGl0ZW07XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFuKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25DaGFuZ2UsIHsgaWQ6IHRoaXMuaWQsIGludmVudG9yeTogdGhpcyB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgVW5pcXVlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IEJhc2ljVGFyZ2V0YWJsZSBmcm9tIFwiLi4vVGFyZ2V0aW5nL0Jhc2ljVGFyZ2V0YWJsZVwiO1xuaW1wb3J0IEJhc2ljVGFyZ2V0aW5nIGZyb20gXCIuLi9UYXJnZXRpbmcvQmFzaWNUYXJnZXRpbmdcIjtcblxuaW1wb3J0IEhXNFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZXMvQWJzdHJhY3RTY2VuZVwiO1xuaW1wb3J0IEludmVudG9yeSBmcm9tIFwiLi9JbnZlbnRvcnlcIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi4vVGFyZ2V0aW5nL1RhcmdldGFibGVFbnRpdHlcIjtcbmltcG9ydCB7IFRhcmdldGluZ0VudGl0eSB9IGZyb20gXCIuLi9UYXJnZXRpbmcvVGFyZ2V0aW5nRW50aXR5XCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgSXRlbSBpbXBsZW1lbnRzIFVuaXF1ZSwgVGFyZ2V0YWJsZUVudGl0eSB7XG5cbiAgICBwcm90ZWN0ZWQgc3ByaXRlOiBTcHJpdGU7XG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG4gICAgcHJvdGVjdGVkIF9pbnZlbnRvcnk6IEludmVudG9yeSB8IG51bGw7XG4gICAgcHJvdGVjdGVkIF90YXJnZXRhYmxlOiBUYXJnZXRhYmxlRW50aXR5O1xuICAgIHByb3RlY3RlZCBpdGVtTmFtZTpzdHJpbmc7XG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHNwcml0ZTogU3ByaXRlKXsgXG4gICAgICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gICAgICAgIHRoaXMuX2ludmVudG9yeSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RhcmdldGFibGUgPSBuZXcgQmFzaWNUYXJnZXRhYmxlKHRoaXMuc3ByaXRlKTtcbiAgICB9XG5cbiAgICBnZXRUYXJnZXRpbmcoKTogVGFyZ2V0aW5nRW50aXR5W10geyBcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldGFibGUuZ2V0VGFyZ2V0aW5nKCk7IFxuICAgIH1cbiAgICBhZGRUYXJnZXRpbmcodGFyZ2V0aW5nOiBUYXJnZXRpbmdFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0YWJsZS5hZGRUYXJnZXRpbmcodGFyZ2V0aW5nKTtcbiAgICB9XG4gICAgcmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZzogVGFyZ2V0aW5nRW50aXR5KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RhcmdldGFibGUucmVtb3ZlVGFyZ2V0aW5nKHRhcmdldGluZyk7XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBnZXQgcmVsYXRpdmVQb3NpdGlvbigpOiBWZWMyIHsgcmV0dXJuIHRoaXMuc3ByaXRlLnJlbGF0aXZlUG9zaXRpb247IH1cblxuICAgIHB1YmxpYyBnZXQgaWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuc3ByaXRlLmlkOyB9XG4gICAgcHVibGljIGdldCBuYW1lKCk6c3RyaW5nIHtyZXR1cm4gdGhpcy5pdGVtTmFtZX07XG4gICAgcHVibGljIHNldCBuYW1lKG5hbWU6c3RyaW5nKXsgdGhpcy5pdGVtTmFtZSA9IG5hbWV9XG4gICAgcHVibGljIGdldCBwb3NpdGlvbigpOiBWZWMyIHsgcmV0dXJuIHRoaXMuc3ByaXRlLnBvc2l0aW9uOyB9XG5cbiAgICBwdWJsaWMgZ2V0IHZpc2libGUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLnNwcml0ZS52aXNpYmxlOyB9XG4gICAgcHVibGljIHNldCB2aXNpYmxlKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuc3ByaXRlLnZpc2libGUgPSB2YWx1ZTsgfVxuXG4gICAgcHVibGljIGdldCBpbnZlbnRvcnkoKTogSW52ZW50b3J5IHwgbnVsbCB7IHJldHVybiB0aGlzLl9pbnZlbnRvcnk7IH1cbiAgICBwdWJsaWMgc2V0IGludmVudG9yeSh2YWx1ZTogSW52ZW50b3J5IHwgbnVsbCkgeyB0aGlzLl9pbnZlbnRvcnkgPSB2YWx1ZTsgfVxuXG59IiwiaW1wb3J0IEFBQkIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZU5vZGUsIHsgVHdlZW5hYmxlUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNcIjtcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xuaW1wb3J0IExpbmUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgeyBFYXNlRnVuY3Rpb25UeXBlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcbmltcG9ydCBIVzRTY2VuZSBmcm9tIFwiLi4vLi4vLi4vU2NlbmVzL0Fic3RyYWN0U2NlbmVcIjtcbmltcG9ydCBJdGVtIGZyb20gXCIuLi9JdGVtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhc2VyR3VuIGV4dGVuZHMgSXRlbSB7XG5cbiAgICBwdWJsaWMgZGFtYWdlOiBudW1iZXI7XG5cbiAgICBwcm90ZWN0ZWQgX2xhc2VyOiBMaW5lXG4gICAgcHJvdGVjdGVkIF9kaXJlY3Rpb246IFZlYzI7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3Ioc3ByaXRlOiBTcHJpdGUsIGxhc2VyOiBMaW5lKSB7XG4gICAgICAgIHN1cGVyKHNwcml0ZSk7XG4gICAgICAgIHRoaXMuX2xhc2VyID0gbGFzZXI7XG4gICAgICAgIHRoaXMuX2xhc2VyLnN0YXJ0LmNvcHkoVmVjMi5aRVJPX1NUQVRJQyk7XG4gICAgICAgIHRoaXMuX2xhc2VyLmVuZC5jb3B5KFZlYzIuWkVST19TVEFUSUMpO1xuICAgICAgICB0aGlzLl9sYXNlci5jb2xvciA9IENvbG9yLkdSRUVOO1xuICAgICAgICB0aGlzLl9sYXNlci50d2VlbnMuYWRkKFwiZmFkZVwiLCB7XG4gICAgICAgICAgICBzdGFydERlbGF5OiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogMSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLk9VVF9TSU5FXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uRW5kOiBcIkxhc2VyIGZhZGVkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFZlYzIuWkVSTztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZShzcHJpdGU6IFNwcml0ZSwgbGFzZXI6IExpbmUpOiBMYXNlckd1biB7XG4gICAgICAgIHJldHVybiBuZXcgTGFzZXJHdW4oc3ByaXRlLCBsYXNlcik7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBkaXJlY3Rpb24oKTogVmVjMiB7IHJldHVybiB0aGlzLl9kaXJlY3Rpb247IH1cbiAgICBwdWJsaWMgZ2V0IGxhc2VyU3RhcnQoKTogVmVjMiB7IHJldHVybiB0aGlzLl9sYXNlci5zdGFydDsgfVxuICAgIHB1YmxpYyBnZXQgbGFzZXJFbmQoKTogVmVjMiB7IHJldHVybiB0aGlzLl9sYXNlci5lbmQ7IH1cblxuICAgIHB1YmxpYyBwbGF5U2hvb3RBbmltYXRpb24oKTogdm9pZCB7IHRoaXMuX2xhc2VyLnR3ZWVucy5wbGF5KFwiZmFkZVwiKTsgfVxuICAgIFxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljRmluZGVyPFQ+IHtcblxuICAgIHByb3RlY3RlZCByZWR1Y2VyOiAodDE6IFQsIHQyOiBUKSA9PiBUIHwgbnVsbDtcbiAgICBwcm90ZWN0ZWQgZmlsdGVyczogKCh0OiBUKSA9PiBib29sZWFuKVtdO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHJlZHVjZXI6ICh0MTogVCwgdDI6IFQpID0+IFQgPSBudWxsLCAuLi5maWx0ZXJzOiAoKHQ6IFQpID0+IGJvb2xlYW4pW10pIHtcbiAgICAgICAgdGhpcy5yZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB9XG5cbiAgICBwdWJsaWMgZmluZCh0YXJnZXRzOiBSZWFkb25seTxUW10+KTogVCB8IG51bGwge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSB0YXJnZXRzLmZpbHRlcih0YXJnZXQgPT4gdGhpcy5maWx0ZXJzLmV2ZXJ5KGZpbHRlciA9PiBmaWx0ZXIodGFyZ2V0KSkpO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQubGVuZ3RoID09PSAwID8gbnVsbCA6IHRoaXMucmVkdWNlciA9PT0gbnVsbCA/IGZpbHRlcmVkWzBdIDogZmlsdGVyZWQucmVkdWNlKHRoaXMucmVkdWNlcik7XG4gICAgfVxuXG59IiwiaW1wb3J0IFBvc2l0aW9uZWQgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1Bvc2l0aW9uZWRcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4uL0JhdHRsZVN5c3RlbS9CYXR0bGVyXCI7XG5pbXBvcnQgSXRlbSBmcm9tIFwiLi4vSXRlbVN5c3RlbS9JdGVtXCI7XG5pbXBvcnQgeyBUYXJnZXRhYmxlRW50aXR5IH0gZnJvbSBcIi4uL1RhcmdldGluZy9UYXJnZXRhYmxlRW50aXR5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBCYXR0bGVyQWN0aXZlRmlsdGVyKCk6IChiOiBCYXR0bGVyKSA9PiBib29sZWFuIHtcbiAgICByZXR1cm4gKGI6IEJhdHRsZXIpID0+IGIuYmF0dGxlckFjdGl2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEJhdHRsZXJIZWFsdGhGaWx0ZXIobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogKGI6IEJhdHRsZXIpID0+IGJvb2xlYW4ge1xuICAgIHJldHVybiAoYjogQmF0dGxlcikgPT4geyByZXR1cm4gTWF0aFV0aWxzLmJldHdlZW4obWluLCBtYXgsIGIuaGVhbHRoLCB0cnVlKTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQmF0dGxlckdyb3VwRmlsdGVyKGdyb3VwczogbnVtYmVyW10sIHdoaXRlbGlzdDogYm9vbGVhbiA9IHRydWUpOiAoYjogQmF0dGxlcikgPT4gYm9vbGVhbiB7XG4gICAgcmV0dXJuIHdoaXRlbGlzdCA/IChiOiBCYXR0bGVyKSA9PiB7IHJldHVybiBncm91cHMuaW5jbHVkZXMoYi5iYXR0bGVHcm91cCk7IH0gOiAoYjogQmF0dGxlcikgPT4geyByZXR1cm4gIWdyb3Vwcy5pbmNsdWRlcyhiLmJhdHRsZUdyb3VwKTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQWxseUZpbHRlcihiYXR0bGVyOiBCYXR0bGVyKTogKG90aGVyOiBCYXR0bGVyKSA9PiBib29sZWFuIHtcbiAgICByZXR1cm4gKG90aGVyOiBCYXR0bGVyKSA9PiB7IHJldHVybiBiYXR0bGVyLmJhdHRsZUdyb3VwID09PSBvdGhlci5iYXR0bGVHcm91cDsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRW5lbXlGaWx0ZXIoYmF0dGxlcjogQmF0dGxlcik6IChvdGhlcjogQmF0dGxlcikgPT4gYm9vbGVhbiB7XG4gICAgcmV0dXJuIChvdGhlcjogQmF0dGxlcikgPT4geyByZXR1cm4gYmF0dGxlci5iYXR0bGVHcm91cCAhPT0gb3RoZXIuYmF0dGxlR3JvdXA7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJhbmdlRmlsdGVyKHBvc2l0aW9uZWQ6IFBvc2l0aW9uZWQsIG1pbkRpc3RTcTogbnVtYmVyLCBtYXhEaXN0U3E6IG51bWJlcik6ICh0OiBUYXJnZXRhYmxlRW50aXR5KSA9PiBib29sZWFuIHtcbiAgICByZXR1cm4gKHQ6IFRhcmdldGFibGVFbnRpdHkpID0+IHsgXG4gICAgICAgIGxldCBkaXN0U3EgPSB0LnBvc2l0aW9uLmRpc3RhbmNlU3FUbyhwb3NpdGlvbmVkLnBvc2l0aW9uKVxuICAgICAgICByZXR1cm4gZGlzdFNxID4gbWluRGlzdFNxICYmIGRpc3RTcSA8IG1heERpc3RTcTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJdGVtRmlsdGVyKGNvbnN0cjogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gSXRlbSk6IChpOiBJdGVtKSA9PiBib29sZWFuIHtcbiAgICByZXR1cm4gKGk6IEl0ZW0pID0+IHsgcmV0dXJuIGkuY29uc3RydWN0b3IgPT09IGNvbnN0cjsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gVmlzaWJsZUl0ZW1GaWx0ZXIoKTogKGk6IEl0ZW0pID0+IGJvb2xlYW4ge1xuICAgIHJldHVybiAoaTogSXRlbSkgPT4gaS52aXNpYmxlO1xufSIsImltcG9ydCBQb3NpdGlvbmVkIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Qb3NpdGlvbmVkXCI7XG5pbXBvcnQgQmF0dGxlciBmcm9tIFwiLi4vQmF0dGxlU3lzdGVtL0JhdHRsZXJcIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi4vVGFyZ2V0aW5nL1RhcmdldGFibGVFbnRpdHlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIENsb3Nlc3RQb3NpdGlvbmVkPFAgZXh0ZW5kcyBQb3NpdGlvbmVkPihwb3NpdGlvbmVkOiBQb3NpdGlvbmVkKTogKHAxOiBQLCBwMjogUCkgPT4gUCB7XG4gICAgcmV0dXJuIChwMTogUCwgcDI6IFApOiBQID0+IHsgXG4gICAgICAgIHJldHVybiBwMS5wb3NpdGlvbi5kaXN0YW5jZVNxVG8ocG9zaXRpb25lZC5wb3NpdGlvbikgPCBwMi5wb3NpdGlvbi5kaXN0YW5jZVNxVG8ocG9zaXRpb25lZC5wb3NpdGlvbikgPyBwMSA6IHAyO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExvd2VzdEhlYWx0aEJhdHRsZXIoYjE6IEJhdHRsZXIsIGIyOiBCYXR0bGVyKTogQmF0dGxlciB7XG4gICAgcmV0dXJuIGIxLmhlYWx0aCA8IGIyLmhlYWx0aCA/IGIxIDogYjJcbn0iLCJpbXBvcnQgUG9zaXRpb25lZCBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvUG9zaXRpb25lZFwiO1xuaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFRhcmdldGFibGVFbnRpdHkgfSBmcm9tIFwiLi9UYXJnZXRhYmxlRW50aXR5XCI7XG5pbXBvcnQgeyBUYXJnZXRpbmdFbnRpdHkgfSBmcm9tIFwiLi9UYXJnZXRpbmdFbnRpdHlcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1RhcmdldGFibGUgaW1wbGVtZW50cyBUYXJnZXRhYmxlRW50aXR5IHtcbiAgICBwcm90ZWN0ZWQgb3duZXI6IFBvc2l0aW9uZWQ7XG5cbiAgICBwcm90ZWN0ZWQgdGFyZ2V0aW5nOiBNYXA8bnVtYmVyLCBUYXJnZXRpbmdFbnRpdHk+O1xuXG4gICAgY29uc3RydWN0b3Iob3duZXI6IFBvc2l0aW9uZWQpIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLnRhcmdldGluZyA9IG5ldyBNYXA8bnVtYmVyLCBUYXJnZXRpbmdFbnRpdHk+KCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFRhcmdldGluZygpOiBUYXJnZXRpbmdFbnRpdHlbXSB7IFxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRhcmdldGluZy52YWx1ZXMoKSk7IFxuICAgIH1cblxuICAgIHB1YmxpYyBhZGRUYXJnZXRpbmcodGFyZ2V0aW5nOiBUYXJnZXRpbmdFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YXJnZXRpbmcuc2V0KHRhcmdldGluZy5pZCwgdGFyZ2V0aW5nKTtcbiAgICB9XG4gICAgXG4gICAgcHVibGljIHJlbW92ZVRhcmdldGluZyh0YXJnZXRpbmc6IFRhcmdldGluZ0VudGl0eSk6IHZvaWQge1xuICAgICAgICB0aGlzLnRhcmdldGluZy5kZWxldGUodGFyZ2V0aW5nLmlkKTtcbiAgICB9XG5cbiAgICBnZXQgcG9zaXRpb24oKTogVmVjMiB7IHJldHVybiB0aGlzLm93bmVyLnBvc2l0aW9uOyB9XG4gICAgZ2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7IHJldHVybiB0aGlzLm93bmVyLnJlbGF0aXZlUG9zaXRpb247IH1cblxufSIsImltcG9ydCBVbmlxdWUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xuaW1wb3J0IHsgVGFyZ2V0YWJsZUVudGl0eSB9IGZyb20gXCIuL1RhcmdldGFibGVFbnRpdHlcIjtcbmltcG9ydCB7IFRhcmdldGluZ0VudGl0eSB9IGZyb20gXCIuL1RhcmdldGluZ0VudGl0eVwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljVGFyZ2V0aW5nIGltcGxlbWVudHMgVGFyZ2V0aW5nRW50aXR5IHtcblxuICAgIHByb3RlY3RlZCBvd25lcjogVW5pcXVlO1xuICAgIHByb3RlY3RlZCBfdGFyZ2V0OiBUYXJnZXRhYmxlRW50aXR5IHwgbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKG93bmVyOiBVbmlxdWUpIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xlYXJUYXJnZXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlVGFyZ2V0aW5nKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgfVxuICAgIHNldFRhcmdldCh0YXJnZXRhYmxlOiBUYXJnZXRhYmxlRW50aXR5KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlVGFyZ2V0aW5nKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0YWJsZTtcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkVGFyZ2V0aW5nKHRoaXMpO1xuICAgIH1cbiAgICBnZXRUYXJnZXQoKTogVGFyZ2V0YWJsZUVudGl0eSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IG5vdCBzZXQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgICB9XG5cbiAgICBoYXNUYXJnZXQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLm93bmVyLmlkOyB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHRhcmdldCgpOiBUYXJnZXRhYmxlRW50aXR5IHwgbnVsbCB7IHJldHVybiB0aGlzLl90YXJnZXQ7IH1cbiAgICBwcm90ZWN0ZWQgc2V0IHRhcmdldCh0YXJnZXQ6IFRhcmdldGFibGVFbnRpdHkgfCBudWxsKSB7IHRoaXMuX3RhcmdldCA9IHRhcmdldDsgfVxufSIsImltcG9ydCBQb3NpdGlvbmVkIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Qb3NpdGlvbmVkXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcblxuLyoqXG4gKiBBIHdyYXBwZXIgY2xhc3MgYXJvdW5kIGEgVmVjMiBpbXBsZW1lbnRpbmcgdGhlIFBvc2l0aW9uZWQgaW50ZXJmYWNlLiBUaGUgcG9pbnRcbiAqIG9mIHRoaXMgY2xhc3MgaXMgdG8gbGV0IHlvdSB1c2UgYW4gYXJiaXRyYXJ5IHBvc2l0aW9uIGFzIGEgVGFyZ2V0YWJsZUVudGl0eS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb24gaW1wbGVtZW50cyBQb3NpdGlvbmVkIHtcblxuICAgIHByaXZhdGUgX3Bvc2l0aW9uOiBWZWMyO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV3IFZlYzIoeCwgeSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBwb3NpdGlvbigpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICAgIH1cblxuICAgIHJlbGF0aXZlUG9zaXRpb246IFZlYzI7XG4gICAgXG59IiwiZXhwb3J0IGVudW0gTWVudVN0YXRlIHtcbiAgICBISURERU4gPSBcIkhJRERFTlwiLFxuICAgIFNIT1dOID0gXCJTSE9XTlwiLFxuICAgIENPTlRST0xfVEVYVF9NRU5VX1NIT1dOID0gXCJDT05UUk9MX1RFWFRfTUVOVV9TSE9XTlwiLFxuICAgIEhFTFBfVEVYVF9NRU5VX1NIT1dOID0gXCJIRUxQX1RFWFRfTUVOVV9TSE9XTlwiLFxufSIsImltcG9ydCBTdGFjayBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0NvbGxlY3Rpb25zL1N0YWNrXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcbmltcG9ydCBOYXZQYXRoU3RyYXQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL1N0cmF0ZWdpZXMvTmF2aWdhdGlvblN0cmF0ZWd5XCI7XG5cbi8vIFRPRE8gQ29uc3RydWN0IGEgTmF2aWdhdGlvblBhdGggb2JqZWN0IHVzaW5nIEEqXG5cbmNsYXNzIE5vZGUge1xuICAgIGluZGV4OiBudW1iZXI7XG4gICAgcGFyZW50OiBOb2RlO1xuICAgIGc6IG51bWJlcjtcbiAgICBoOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihpbmRleDogbnVtYmVyLCBwYXJlbnQ/OiBOb2RlLCBnPzogbnVtYmVyLCBoPzogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICAgIHRoaXMuaCA9IGg7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBBc3RhclN0cmF0ZWd5IGNsYXNzIGlzIGFuIGV4dGVuc2lvbiBvZiB0aGUgYWJzdHJhY3QgTmF2UGF0aFN0cmF0ZWd5IGNsYXNzLiBGb3Igb3VyIG5hdmlnYXRpb24gc3lzdGVtLCB5b3UgY2FuXG4gKiBub3cgc3BlY2lmeSBhbmQgZGVmaW5lIHlvdXIgb3duIHBhdGhmaW5kaW5nIHN0cmF0ZWd5LiBPcmlnaW5hbGx5LCB0aGUgdHdvIG9wdGlvbnMgd2VyZSB0byB1c2UgRGppa3N0cmFzIG9yIGFcbiAqIGRpcmVjdCAocG9pbnQgQSAtPiBwb2ludCBCKSBzdHJhdGVneS4gVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSBob3cgdGhlIHBhdGhmaW5kaW5nIHdhcyBkb25lIHdhcyBieSBoYXJkLWNvZGluZyB0aGluZ3NcbiAqIGludG8gdGhlIGNsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBuYXZpZ2F0aW9uIHN5c3RlbS4gXG4gKiBcbiAqIC0gUGV0ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXN0YXJTdHJhdGVneSBleHRlbmRzIE5hdlBhdGhTdHJhdCB7XG4gICAgLyoqXG4gICAgICogQHNlZSBOYXZQYXRoU3RyYXQuYnVpbGRQYXRoKClcbiAgICAgKi9cbiAgICBwdWJsaWMgYnVpbGRQYXRoKHRvOiBWZWMyLCBmcm9tOiBWZWMyKTogTmF2aWdhdGlvblBhdGgge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLm1lc2guZ3JhcGguc25hcChmcm9tKTtcblx0XHRsZXQgZW5kID0gdGhpcy5tZXNoLmdyYXBoLnNuYXAodG8pO1xuXHRcdGxldCBwYXRoU3RhY2sgPSBuZXcgU3RhY2s8VmVjMj4odGhpcy5tZXNoLmdyYXBoLm51bVZlcnRpY2VzKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uUGF0aChwYXRoU3RhY2spOyBcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGF0aE5vZGUgPSB0aGlzLmVuZE5vZGUoc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgLy8gcGF0aFN0YWNrLnB1c2godG8uY2xvbmUoKSk7XG4gICAgICAgIHBhdGhTdGFjay5wdXNoKHRoaXMubWVzaC5ncmFwaC5wb3NpdGlvbnNbZW5kXSk7XG4gICAgICAgIHdoaWxlIChwYXRoTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXRoU3RhY2sucHVzaCh0aGlzLm1lc2guZ3JhcGgucG9zaXRpb25zW3BhdGhOb2RlLmluZGV4XSk7XG4gICAgICAgICAgICBwYXRoTm9kZSA9IHBhdGhOb2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXRoU3RhY2sucHVzaCh0aGlzLm1lc2guZ3JhcGgucG9zaXRpb25zW3N0YXJ0XSk7XG4gICAgICAgIGlmIChwYXRoU3RhY2suc2l6ZSgpID09IDEpIHtcbiAgICAgICAgICAgIGxldCBlbXB0eVN0YWNrID0gbmV3IFN0YWNrPFZlYzI+KDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uUGF0aChlbXB0eVN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5hdmlnYXRpb25QYXRoKHBhdGhTdGFjayk7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgZW5kTm9kZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IE5vZGUge1xuICAgICAgICBsZXQgc3RhcnRWZWMgPSB0aGlzLm1lc2guZ3JhcGgucG9zaXRpb25zW3N0YXJ0XTtcbiAgICAgICAgbGV0IGVuZFZlYyA9IHRoaXMubWVzaC5ncmFwaC5wb3NpdGlvbnNbZW5kXTtcbiAgICAgICAgbGV0IG9wZW5MaXN0OiBBcnJheTxOb2RlPiA9IG5ldyBBcnJheSgpO1xuICAgICAgICBsZXQgY2xvc2VkTGlzdDogQXJyYXk8Ym9vbGVhbj4gPSBuZXcgQXJyYXkodGhpcy5tZXNoLmdyYXBoLm51bVZlcnRpY2VzKTtcbiAgICAgICAgb3Blbkxpc3QucHVzaChuZXcgTm9kZShzdGFydCwgbnVsbCwgMCwgZW5kVmVjLmRpc3RhbmNlVG8oc3RhcnRWZWMpKSk7XG4gICAgICAgIGNsb3NlZExpc3Rbc3RhcnRdID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlIChvcGVuTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvL2ZpbmQgbm9kZSB3aXRoIGxvd2VzdCBmPWcraCB2YWx1ZVxuICAgICAgICAgICAgbGV0IGN1cnIgPSBvcGVuTGlzdC5yZWR1Y2UoKGEsIGIpID0+IGEuZyArIGEuaCA8IGIuZyArIGIuaCA/IGEgOiBiKTtcbiAgICAgICAgICAgIG9wZW5MaXN0LnNwbGljZShvcGVuTGlzdC5pbmRleE9mKGN1cnIpLCAxKTtcbiAgICAgICAgICAgIGlmIChjdXJyLmluZGV4ID09IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBlZGdlID0gdGhpcy5tZXNoLmdyYXBoLmdldEVkZ2VzKGN1cnIuaW5kZXgpO1xuICAgICAgICAgICAgd2hpbGUgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghY2xvc2VkTGlzdFtlZGdlLnldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGpOb2RlID0gbmV3IE5vZGUoZWRnZS55KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdGhpcy5tZXNoLmdyYXBoLnBvc2l0aW9uc1tlZGdlLnldO1xuICAgICAgICAgICAgICAgICAgICBhZGpOb2RlLmcgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKHRoaXMubWVzaC5ncmFwaC5wb3NpdGlvbnNbY3Vyci5pbmRleF0pICsgY3Vyci5nO1xuICAgICAgICAgICAgICAgICAgICBhZGpOb2RlLmggPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGVuZFZlYyk7XG4gICAgICAgICAgICAgICAgICAgIGFkak5vZGUucGFyZW50ID0gY3VycjtcblxuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC5wdXNoKGFkak5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZWRMaXN0W2VkZ2UueV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGdlID0gZWRnZS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59IiwiZXhwb3J0IGNvbnN0IFBsYXllclN0YXRzQXJyYXkgPSBbJ2N1cnJlbnRIZWFsdGgnLCdjdXJyZW50RW5lcmd5JywgJ2N1cnJlbnRTaGllbGQnXTtcbmV4cG9ydCBjb25zdCBQbGF5ZXJTdGF0c05hbWVBcnJheSA9IFsnSFAnLCdFTkVSR1knLCAnU0hJRUxEJ107XG5leHBvcnQgY29uc3QgUGxheWVyU3RhdHNDb2xvckFycmF5PVsnR1JFRU4nLCdDWUFOJywnT1JBTkdFJ107XG4iLCJleHBvcnQgZW51bSBCYXR0bGVyRXZlbnRzIHtcbiAgICBNT05TVEVSX0RFQUQgPSBcIk1PTlNURVJfREVBRFwiLFxuICAgIE1PTlNURVJfSElUPSBcIk1PTlNURVJfSElUXCIsXG4gICAgTU9OU1RFUl9BVFRBQ0sgPSBcIk1PTlNURVJfQVRUQUNLXCIsXG4gICAgUFJJTkNFX0hJVCA9IFwiUFJJTkNFX0hJVFwiLFxuICAgIFBSSU5DRV9ERUFEID0gXCJQUklOQ0VfREVBRFwiLFxuICAgIFBSSU5DRV9BVFRBQ0sgID0gXCJQUklOQ0VfQVRUQUNLXCJcbn1cblxuXG5leHBvcnQgZW51bSBQbGF5ZXJFdmVudHMge1xuICAgIExFVkVMX0VORD0gXCJMRVZFTF9FTkRcIixcbiAgICBQTEFZRVJfRU5URVJFRF9MRVZFTF9FTkQ9IFwiUExBWUVSX0VOVEVSRURfTEVWRUxfRU5EXCIsXG59IFxuXG5leHBvcnQgZW51bSBNZXNzYWdlQm94RXZlbnRzIHtcbiAgICBTSE9XPVwiU0hPV1wiLFxuICAgIEhJRERFTiA9IFwiSElEREVOXCIsXG4gICAgSU5WQUxJRF9BQ1RJT04gPSBcIllvdSBjYW4gbm90IHBlcmZvcm0gdGhhdCBhY3Rpb24uXCIsXG4gICAgSVRFTV9OT1RfRk9VTkQgPSBcIlRoYXQgaXRlbSBjYW5ub3QgYmUgZm91bmQgaW4geW91ciBpbnZlbnRvcnkuXCIsXG4gICAgU0tJTExfT05fQ0QgPSBcIlRoYXQgc2tpbGwgaXMgb24gY29vbGRvd24uXCIsXG4gICAgVVNFX0RPT1IgPSBcIlRoZSBkZXN0YWluYXRpb24gaGFzIGJlZW4gc2hvd25cIixcbiAgICBVU0VfTEFOVEVSTiA9IFwiVGhlIHZpc2libGUgYXJlYSBhcmUgaW5jcmVhc2VkXCIsXG4gICAgVVNFX0hFQUxUSF9QQUNLPSBcIkhlYWx0aCBwYWNrIGlzIHVzZWRcIixcbiAgICBVU0VfUEhBU0lOR19QT1RJT04gPSBcIlRoZSBjaGFyYWN0ZXIgaXMgYWJsZSB0byBwaGFzZSB0aHJvdWdoIHRoZSB3YWxsXCIsXG59XG5leHBvcnQgdHlwZSBBbGxHYW1lRXZlbnRUeXBlPSBCYXR0bGVyRXZlbnRzIHwgUGxheWVyRXZlbnRzIHwgTWVzc2FnZUJveEV2ZW50cztcblxuZXhwb3J0IGVudW0gSXRlbUV2ZW50IHtcbiAgICBJVEVNX1JFUVVFU1QgPSBcIklURU1fUkVRVUVTVFwiLFxuXG4gICAgTEFTRVJHVU5fRklSRUQgPSBcIkxBU0VSR1VOX0ZJUkVEXCIsXG5cbiAgICBXRUFQT05fVVNFRCA9IFwiV0VBUE9OX1VTRURcIixcbiAgICBDT05TVU1BQkxFX1VTRUQgPSBcIkNPTlNVTUFCTEVfVVNFRFwiLFxuICAgIElOVkVOVE9SWV9DSEFOR0VEID0gXCJJTlZFTlRPUllfQ0hBTkdFRFwiLFxufVxuXG5leHBvcnQgZW51bSBIdWRFdmVudCB7XG4gICAgSEVBTFRIX0NIQU5HRSA9IFwiSEVBTFRIX0NIQU5HRVwiLFxuICAgIFVTRV9IUEFDSyA9IFwiVVNFX0hQQUNLXCJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcbmltcG9ydCBnYW1lSXRlbXMgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0l0ZW1TeXN0ZW0vSXRlbXMvTGFzZXJHdW5zXCI7XG5pbXBvcnQgSGVhbHRocGFjayBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtcy9IZWFsdGhwYWNrXCI7XG5pbXBvcnQgQmF0dGxlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQmF0dGxlU3lzdGVtL0JhdHRsZXJcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgeyBCYWNrQnV0dG9uRXZlbnQgfSBmcm9tIFwiLi4vQ3VzdG9taXplZEJ1dHRvblwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IE1haW5NZW51IGZyb20gXCIuL01haW5NZW51U2NlbmVcIjtcbmltcG9ydCB7IGhlbHBUZXh0QXJyYXksIGNvbnRyb2xUZXh0QXJyYXkgfSBmcm9tIFwiLi4vVGV4dFwiO1xuaW1wb3J0IHsgUGxheWVyU3RhdHNBcnJheSwgUGxheWVyU3RhdHNDb2xvckFycmF5LCBQbGF5ZXJTdGF0c05hbWVBcnJheSB9IGZyb20gXCIuLi9QbGF5ZXJTdGF0c0FycmF5XCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVNYW5hZ2VyXCI7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xuaW1wb3J0IHsgUGxheWVyRXZlbnRzLCBCYXR0bGVyRXZlbnRzLCBNZXNzYWdlQm94RXZlbnRzLCBBbGxHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL1Byb2plY3RFdmVudHNcIjtcblxuaW1wb3J0IEFjdG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xuXG5cbi8vIHNjZW5lIGltcG9ydFxuLy8gaW1wb3J0IEludHJvTGV2ZWxTY2VuZSBmcm9tIFwiLi9JbnRyb0xldmVsU2NlbmVcIjtcbi8vIGltcG9ydCBTdGFydFNjZW5lIGZyb20gXCIuL1N0YXJ0U2NlbmVcIjtcbmltcG9ydCBTZWxlY3RMZXZlbE1lbnVTY2VuZSBmcm9tIFwiLi9TZWxlY3RMZXZlbE1lbnVTY2VuZVwiO1xuXG5pbXBvcnQgeyBUd2VlbmFibGVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgeyBFYXNlRnVuY3Rpb25UeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0lucHV0L0lucHV0XCI7XG5pbXBvcnQgUGxheWVyQWN0b3IgZnJvbSBcIi4uL0FjdG9ycy9QbGF5ZXJBY3RvclwiO1xuaW1wb3J0IExpbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcbmltcG9ydCBCdWJibGVTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJzL0J1YmJsZVNoYWRlclR5cGVcIjtcbmltcG9ydCBMYXNlclNoYWRlclR5cGUgZnJvbSBcIi4uL1NoYWRlcnMvTGFzZXJTaGFkZXJUeXBlXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IHsgTWFpbk1lbnVCdXR0b25FdmVudCwgUGF1c2VCdXR0b25FdmVudCB9IGZyb20gXCIuLi9DdXN0b21pemVkQnV0dG9uXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgUGxheWVyQUkgZnJvbSBcIi4uL0FJL1BsYXllci9QbGF5ZXJBSVwiO1xuaW1wb3J0IHsgR2FtZUl0ZW1zQXJyYXksIEdhbWVJdGVtcyB9IGZyb20gXCIuLi9HYW1lSXRlbXNBcnJheVwiO1xuaW1wb3J0IHsgUGxheWVySW5wdXQgfSBmcm9tIFwiLi4vQUkvUGxheWVyL1BsYXllckNvbnRyb2xsZXJcIjtcbmltcG9ydCBMYXNlckd1biBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvSXRlbVN5c3RlbS9JdGVtcy9MYXNlckd1bnNcIjtcbmltcG9ydCB7IEFDVElPTlRZUEUgfSBmcm9tIFwiLi4vQWN0aW9uVHlwZVwiO1xuaW1wb3J0IHsgR2FtZUxheWVycyB9IGZyb20gXCIuLi9HYW1lTGF5ZXJzXCI7XG5pbXBvcnQgeyBJdGVtQnV0dG9uQXJyYXkgYXMgSXRlbUJ1dHRvbktleUFycmF5IH0gZnJvbSBcIi4uL0NvbnRyb2xzXCI7XG5pbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XG5pbXBvcnQgTmF2bWVzaCBmcm9tIFwiLi4vLi4vV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaFwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgQXN0YXJTdHJhdGVneSBmcm9tIFwiLi4vUGF0aGZpbmRpbmcvQXN0YXJTdHJhdGVneVwiO1xuaW1wb3J0IE5QQ0FjdG9yIGZyb20gXCIuLi9BY3RvcnMvTlBDQWN0b3JcIjtcbmltcG9ydCB7IE1lbnVTdGF0ZSB9IGZyb20gXCIuLi9NZW51U3RhdGVcIjtcbmltcG9ydCBTbGltZUJlaGF2aW9yIGZyb20gXCIuLi9BSS9OUEMvTlBDQmVoYXZpb3IvU2xpbWVCZWhhdmlvclwiO1xuaW1wb3J0IEJhc2ljVGFyZ2V0YWJsZSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvVGFyZ2V0aW5nL0Jhc2ljVGFyZ2V0YWJsZVwiO1xuaW1wb3J0IFBvc2l0aW9uIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9UYXJnZXRpbmcvUG9zaXRpb25cIjtcblxuLy9cbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcbmNvbnN0IGVudW0gdHdlZW5zRWZmZWN0IHtcbiAgICBTTElERUlOID0gXCJzbGlkZUluXCIsXG4gICAgU0xJREVPVVQgPSBcInNsaWRlT3V0XCIsXG4gICAgRkFERUlOID0gXCJmYWRlSW5cIixcbiAgICBGQURFT1VUID0gXCJmYWRlT3V0XCIsXG59XG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBQcm9qZWN0U2NlbmUgZXh0ZW5kcyBTY2VuZSB7XG4gICAgcHJvdGVjdGVkIHdhbGxzOiBPcnRob2dvbmFsVGlsZW1hcDtcbiAgICBwcm90ZWN0ZWQgcGF0aDogTmF2aWdhdGlvblBhdGg7XG4gICAgLy9idXR0b24gZXZlbnRcbiAgICBwcm90ZWN0ZWQgUGF1c2VCdXR0b25FdmVudCA9IFBhdXNlQnV0dG9uRXZlbnQ7XG4gICAgcHJvdGVjdGVkIHdhbGxTaXplOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGVtcHR5U3RyaW5nID0gXCJcIjtcbiAgICBwcm90ZWN0ZWQgYWN0aW9uID0gXCJhY3Rpb25cIjtcbiAgICBwcm90ZWN0ZWQgYmFja2dyb3VuZEltYWdlOiBTcHJpdGU7XG4gICAgcHJvdGVjdGVkIEdhbWVMYXllcnMgPSBHYW1lTGF5ZXJzO1xuICAgIHByb3RlY3RlZCBiYWNrQnV0dG9uUG9zaXRpb24gPSBuZXcgVmVjMig1MCwgNTApO1xuXG4gICAgLy9tZXNzYWdlIGJveCB0byBkaXNwbGF5IGludmFsaWQgYWN0aW9uXG4gICAgLy8gbGV2ZWwgdHJhbnN0aW9uXG4gICAgcHJvdGVjdGVkIGxldmVsVHJhbnNpdGlvblRpbWVyOiBUaW1lcjtcbiAgICBwcm90ZWN0ZWQgbGV2ZWxUcmFuc2l0aW9uU2NyZWVuOiBSZWN0O1xuICAgIC8vTGV2ZWwgZW5kXG4gICAgcHJvdGVjdGVkIGNlbnRlcjogVmVjMjtcbiAgICBwcm90ZWN0ZWQgbGV2ZWxFbmRBcmVhOiBSZWN0O1xuICAgIHByb3RlY3RlZCBsZXZlbEVuZFRyYW5zaXRpb25MYWJlbDogTGFiZWw7XG4gICAgcHJvdGVjdGVkIG1lc3NhZ2VCb3hMYWJlbDogTGFiZWw7XG4gICAgcHJvdGVjdGVkIHBsYXllckluaXRQb3NpdGlvbiA9IG5ldyBWZWMyKDI2MCwgMjM1KTtcbiAgICAvLyBwcm90ZWN0ZWQgcGxheWVySW5pdFBvc2l0aW9uID0gbmV3IFZlYzIoMTAwLCA5MCk7XG4gICAgcHJvdGVjdGVkIGxldmVsRW5kUG9zaXRpb24gPSBuZXcgVmVjMigyNjAsIDQ5MCk7XG4gICAgcHJvdGVjdGVkIGxldmVsRW5kSGFsZlNpemUgPSBuZXcgVmVjMigyNSwgMjUpXG4gICAgcHJvdGVjdGVkIGxldmVsRW5kQ29sb3IgPSBuZXcgQ29sb3IoMjU1LCAwLCAwLCAwLjUpO1xuICAgIHByb3RlY3RlZCBsZXZlbEVuZFRpbWVyOiBUaW1lcjtcbiAgICBwcm90ZWN0ZWQgaXNMZXZlbEVuZEVuZXRlcmVkOiBib29sZWFuO1xuICAgIC8vcGxheWVyIFxuICAgIHByb3RlY3RlZCBwbGF5ZXI6IFBsYXllckFjdG9yO1xuICAgIHByb3RlY3RlZCBsYXNlckd1bnM6IEFycmF5PGdhbWVJdGVtcz47XG4gICAgcHJvdGVjdGVkIGRvb3I6IFNwcml0ZVxuICAgIHByb3RlY3RlZCBiYWNrZ3JvdW5kSW1hZ2VLZXk6IHN0cmluZztcbiAgICBwcm90ZWN0ZWQgcGxheWVyTWF4U3RhdFZhbHVlID0gMTA7XG5cbiAgICAvL3VsdGltYXRlXG4gICAgcHJvdGVjdGVkIHVsdGltYXRlV2F2ZTogU3ByaXRlO1xuICAgIHByb3RlY3RlZCB1bHRpbWF0ZVdhdmVLZXkgPSBcInVsdGltYXRlV2F2ZVwiO1xuICAgIHByb3RlY3RlZCB1bHRpbWF0ZVdhdmVEaXJlY3Rpb246IFZlYzI7XG4gICAgcHJvdGVjdGVkIHVsdGltYXRlV2F2ZUZpcmVkcG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcbiAgICBwcm90ZWN0ZWQgdWx0aW1hdGVXYXZlUGxheWVyRGlzdGFuY2UgPSA0MDtcbiAgICAvL3VpXG4gICAgcHJvdGVjdGVkIGluR2FtZUNvbnRyb2xUZXh0QmFja2dyb3VuZCA9IFwiaW5HYW1lQ29udHJvbFRleHRCYWNrZ3JvdW5kXCJcbiAgICBwcm90ZWN0ZWQgaW5HYW1lSGVscFRleHRCYWNrZ3JvdW5kID0gXCJpbkdhbWVIZWxwVGV4dEJhY2tncm91bmRcIlxuICAgIC8vIEhlYWx0aCBsYWJlbHNcbiAgICBwcm90ZWN0ZWQgUGxheWVyU3RhdFVJID0ge307XG4gICAgcHJvdGVjdGVkIG9uZVN0YXRVSSA9IHtcbiAgICAgICAgbGFiZWw6IExhYmVsLFxuICAgICAgICBiYXI6IExhYmVsLFxuICAgICAgICBiYXJCZzogTGFiZWwsXG4gICAgfVxuXG4gICAgLy9pdGVtcyB0byBnYW1lIFxuICAgIHByb3RlY3RlZCBnYW1lSXRlbXNBcnJheSA9IEdhbWVJdGVtc0FycmF5O1xuICAgIHByb3RlY3RlZCBnYW1lSXRlbXNNYXAgPSBuZXcgTWFwPHN0cmluZywgQXJyYXk8Z2FtZUl0ZW1zPj4oKTtcbiAgICBwcm90ZWN0ZWQgbGFzZXJHdW5zS2V5ID0gXCJsYXNlckd1bnNcIjtcbiAgICBwcm90ZWN0ZWQgbGFudGVyblNoYXBlOiBBQUJCO1xuICAgIHByb3RlY3RlZCBsYW50ZXJuRHVyYXRpb24gPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgaW52ZW50b3J5U2xvdHNNYXAgPSBuZXcgTWFwPG51bWJlciwgTWFwPFZlYzIsIEFycmF5PGdhbWVJdGVtcz4+PigpO1xuICAgIC8vIHByb3RlY3RlZCB0ZXN0ID0gbmV3IE1hcDxudW1iZXIsVmVjMj4oKVxuICAgIC8vdWkgZGlzcGxheVxuICAgIHByb3RlY3RlZCBjdXJyZW50UGxheWVyUG9zaXRpb25MYWJlbHM6IEFycmF5PExhYmVsPjtcblxuICAgIC8vYXVkaW8gYW5kIG11c2ljXG4gICAgcHJvdGVjdGVkIGxldmVsTXVzaWNLZXk6IHN0cmluZztcblxuICAgIHByb3RlY3RlZCBsYWJlbFNpemU6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgaXNQYXVzZU1lbnVIaWRkZW46IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIE1lbnVDdXJlbnRTdGF0ZTogTWVudVN0YXRlO1xuICAgIC8vIHJlbGF0aXZlIHBhdGggdG8gdGhlIGFzc2V0c1xuICAgIHByb3RlY3RlZCBwYXRoVG9JdGVtcyA9IGBzaGFkb3dNYXplX2Fzc2V0cy9kYXRhL2l0ZW1zL2A7XG4gICAgcHJvdGVjdGVkIHBhdGhUb1Nwcml0ZSA9IGBzaGFkb3dNYXplX2Fzc2V0cy9zcHJpdGVzL2A7XG5cbiAgICAvL0xpXG4gICAgcHJvdGVjdGVkIGJhdHRsZXJzOiAoQmF0dGxlciAmIEFjdG9yKVtdO1xuICAgIHByb3RlY3RlZCBvcHRpb246IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgcHJvdGVjdGVkIHZpc2libGVHcm91cDogKFBsYXllckFjdG9yIHwgTlBDQWN0b3IgfCBTcHJpdGUpW10gPSBbXTtcbiAgICBwdWJsaWMgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlciwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlciwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICBzdXBlcih2aWV3cG9ydCwgc2NlbmVNYW5hZ2VyLCByZW5kZXJpbmdNYW5hZ2VyLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLCBwaHlzaWNzOiB7XG4gICAgICAgICAgICAgICAgLy8gZ3JvdXBOYW1lczogW1BoeXNpY3NHcm91cHMuUExBWUVSXSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGFiZWxTaXplID0gMzI7XG4gICAgICAgIHRoaXMuaXNQYXVzZU1lbnVIaWRkZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLk1lbnVDdXJlbnRTdGF0ZSA9IE1lbnVTdGF0ZS5ISURERU47XG4gICAgICAgIHRoaXMub3B0aW9uID0ge1xuICAgICAgICAgICAgaXNBc3RhckNoZWNrZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNmb2dPZldhckNoZWNrZWQ6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuQnV0dG9uU2VsZWN0aW9uID0gTWFpbk1lbnVCdXR0b25FdmVudDtcbiAgICAgICAgLy8gZm9yIChjb25zdCBsYXllck5hbWUgb2YgdGhpcy5sYXllck5hbWVzKSB7XG4gICAgICAgIC8vICAgICB0aGlzW2xheWVyTmFtZV0gPSBsYXllck5hbWU7XG4gICAgICAgIC8vIH1cblxuICAgICAgICB0aGlzLmJhdHRsZXJzID0gbmV3IEFycmF5PEJhdHRsZXIgJiBBY3Rvcj4oKTtcbiAgICB9XG4gICAgcHVibGljIGluaXRTY2VuZShvcHRpb246IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgaWYgKG9wdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5vcHRpb24gPSBvcHRpb25cblxuICAgIH1cbiAgICBwcm90ZWN0ZWQgaW5pdExldmVsU2NlbmUoKSB7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5nZXRWaWV3cG9ydCgpLmdldENlbnRlcigpO1xuICAgICAgICB0aGlzLmluaXRTdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5sZXZlbFRyYW5zaXRpb25UaW1lciA9IG5ldyBUaW1lcig1MDApO1xuICAgICAgICB0aGlzLmxldmVsRW5kVGltZXIgPSBuZXcgVGltZXIoMTAwMClcbiAgICAgICAgdGhpcy5pc0xldmVsRW5kRW5ldGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0TGF5ZXJzKCk7XG5cbiAgICAgICAgdGhpcy5sZXZlbEVuZFRyYW5zaXRpb25MYWJlbCA9IHRoaXMuYWRkVHdlZW5MYWJlbCh0aGlzLmxldmVsRW5kVHJhbnNpdGlvbkxhYmVsLCBQbGF5ZXJFdmVudHMuTEVWRUxfRU5ELCB0d2VlbnNFZmZlY3QuU0xJREVJTik7XG4gICAgICAgIHRoaXMubWVzc2FnZUJveExhYmVsID0gdGhpcy5hZGRUd2VlbkxhYmVsKHRoaXMubWVzc2FnZUJveExhYmVsLCBNZXNzYWdlQm94RXZlbnRzLkhJRERFTiwgdHdlZW5zRWZmZWN0LlNMSURFSU4pO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgbG9hZEdhbWVJdGVtcyhrZXk6IHN0cmluZykge1xuICAgICAgICB0aGlzLmxvYWQub2JqZWN0KGtleSwgYCR7dGhpcy5wYXRoVG9JdGVtc30ke2tleX0uanNvbmApO1xuICAgICAgICB0aGlzLmxvYWQuaW1hZ2Uoa2V5LCBgJHt0aGlzLnBhdGhUb1Nwcml0ZX0ke2tleX0ucG5nYCk7XG4gICAgfVxuICAgIHByb3RlY3RlZCBsb2FkVWx0aW1hdGVXYXZlKCkge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy51bHRpbWF0ZVdhdmVLZXk7XG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShrZXksIGAke3RoaXMucGF0aFRvU3ByaXRlfSR7a2V5fS5wbmdgKTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGluaXRVbHRpbWF0ZVdhdmUoKSB7XG4gICAgICAgIHRoaXMudWx0aW1hdGVXYXZlID0gdGhpcy5hZGQuc3ByaXRlKHRoaXMudWx0aW1hdGVXYXZlS2V5LCB0aGlzLkdhbWVMYXllcnMuQkFTRSk7XG4gICAgICAgIHRoaXMudWx0aW1hdGVXYXZlLnZpc2libGUgPSBmYWxzZVxuICAgICAgICBjb25zdCBoYWxmU2l6ZSA9IHRoaXMucGxheWVyLnNpemVXaXRoWm9vbS5zY2FsZSgwLjI1KTtcbiAgICAgICAgdGhpcy51bHRpbWF0ZVdhdmUucG9zaXRpb24uc2V0KHRoaXMucGxheWVyLnBvc2l0aW9uLngsIHRoaXMucGxheWVyLnBvc2l0aW9uLnkpO1xuICAgICAgICB0aGlzLnVsdGltYXRlV2F2ZS5zZXRDb2xsaXNpb25TaGFwZShuZXcgQUFCQih0aGlzLnBsYXllci5wb3NpdGlvbiwgaGFsZlNpemUpKTtcbiAgICAgICAgdGhpcy52aXNpYmxlR3JvdXAucHVzaCh0aGlzLnVsdGltYXRlV2F2ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGxvYWRBbGxHYW1lSXRlbXMoKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLmdhbWVJdGVtc0FycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRHYW1lSXRlbXMoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgaW5pdEludmVudG9yeVNsb3RzTWFwKCkge1xuICAgICAgICBjb25zdCBpbnZlbnRvcnlTbG90c1Bvc2l0aW9uID0gdGhpcy5sb2FkLmdldE9iamVjdChHYW1lSXRlbXMuSU5WRU5UT1JZU0xPVClcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbiBvZiBpbnZlbnRvcnlTbG90c1Bvc2l0aW9uLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwb3N0aW9uSXRlbXNNYXAgPSBuZXcgTWFwPFZlYzIsIEFycmF5PGdhbWVJdGVtcz4+KCk7XG4gICAgICAgICAgICBwb3N0aW9uSXRlbXNNYXAuc2V0KHBvc2l0aW9uLCBbXSk7XG4gICAgICAgICAgICB0aGlzLmludmVudG9yeVNsb3RzTWFwLnNldChpLCBwb3N0aW9uSXRlbXNNYXApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBpbml0QWxsR2FtZUl0ZW1zKCkge1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5nYW1lSXRlbXNBcnJheSkge1xuICAgICAgICAgICAgbGV0IGdhbWVJdGVtID0gdGhpcy5sb2FkLmdldE9iamVjdChrZXkpO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBuZXcgQXJyYXk8Z2FtZUl0ZW1zPihnYW1lSXRlbS5wb3NpdGlvbi5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzcHJpdGUsIGxpbmU7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJpbnZlbnRvcnlTbG90XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5hZGQuc3ByaXRlKGtleSwgdGhpcy5HYW1lTGF5ZXJzLkJFRk9SRV9CQVNFKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IDxMaW5lPnRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuTElORSwgdGhpcy5HYW1lTGF5ZXJzLkJFRk9SRV9CQVNFLCB7IHN0YXJ0OiBWZWMyLlpFUk8sIGVuZDogVmVjMi5aRVJPIH0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbnVtT2ZTbG90cyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgdGhpcy5HYW1lTGF5ZXJzLkJFRk9SRV9CQVNFLCB7IHBvc2l0aW9uOiBuZXcgVmVjMihnYW1lSXRlbS5wb3NpdGlvbltpXVswXSAtIDE3LCBnYW1lSXRlbS5wb3NpdGlvbltpXVsxXSksIHRleHQ6IGAke2kgKyAxfWAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG51bU9mU2xvdHMuZm9udFNpemUgPSAyNDtcbiAgICAgICAgICAgICAgICAgICAgbnVtT2ZTbG90cy5mb250ID0gXCJDb3VyaWVyXCI7XG4gICAgICAgICAgICAgICAgICAgIG51bU9mU2xvdHMudGV4dENvbG9yID0gQ29sb3IuQkxBQ0s7XG4gICAgICAgICAgICAgICAgICAgIC8vIG51bU9mU2xvdHMucG9zaXRpb24uc2V0KGdhbWVJdGVtLnBvc2l0aW9uW2ldWzBdLTEwMCwgZ2FtZUl0ZW0ucG9zaXRpb25baV1bMV0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcHJpdGUgPSB0aGlzLmFkZC5zcHJpdGUoa2V5LCB0aGlzLkdhbWVMYXllcnMuQkFTRSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSA8TGluZT50aGlzLmFkZC5ncmFwaGljKEdyYXBoaWNUeXBlLkxJTkUsIHRoaXMuR2FtZUxheWVycy5CQVNFLCB7IHN0YXJ0OiBWZWMyLlpFUk8sIGVuZDogVmVjMi5aRVJPIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IGdhbWVJdGVtcy5jcmVhdGUoc3ByaXRlLCBsaW5lKTtcbiAgICAgICAgICAgICAgICBpdGVtc1tpXS5wb3NpdGlvbi5zZXQoZ2FtZUl0ZW0ucG9zaXRpb25baV1bMF0sIGdhbWVJdGVtLnBvc2l0aW9uW2ldWzFdKTtcbiAgICAgICAgICAgICAgICBpdGVtc1tpXS5uYW1lID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nYW1lSXRlbXNNYXAuc2V0KGtleSwgaXRlbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1YmxpYyBzdGFydFNjZW5lKCk6IHZvaWQge1xuICAgICAgICBsZXQgdGlsZW1hcExheWVycyA9IHRoaXMuYWRkLnRpbGVtYXAoXCJsZXZlbFwiKTtcblxuICAgICAgICB0aGlzLndhbGxzID0gPE9ydGhvZ29uYWxUaWxlbWFwPnRpbGVtYXBMYXllcnNbMV0uZ2V0SXRlbXMoKVswXTtcbiAgICAgICAgdGhpcy53YWxsU2l6ZSA9IHRoaXMud2FsbHMuc2l6ZS54O1xuICAgICAgICAvLyBTZXQgdGhlIHZpZXdwb3J0IGJvdW5kcyB0byB0aGUgdGlsZW1hcFxuICAgICAgICBsZXQgdGlsZW1hcFNpemU6IFZlYzIgPSB0aGlzLndhbGxzLnNpemU7XG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Qm91bmRzKDAsIDAsIHRpbGVtYXBTaXplLngsIHRpbGVtYXBTaXplLnkpO1xuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldFpvb21MZXZlbCgyKTtcbiAgICAgICAgLy8gdGhpcy5pbml0TGF5ZXJzKCk7XG4gICAgICAgIHRoaXMuaW5pdExldmVsU2NlbmUoKTtcbiAgICAgICAgdGhpcy5pbml0UGxheWVyKCk7XG4gICAgICAgIGxldCBuYXZtZXNoID0gdGhpcy5pbml0aWFsaXplTmF2bWVzaChuZXcgUG9zaXRpb25HcmFwaCgpLCB0aGlzLndhbGxzKTtcbiAgICAgICAgbmF2bWVzaC5yZWdpc3RlclN0cmF0ZWd5KFwiYXN0YXJcIiwgbmV3IEFzdGFyU3RyYXRlZ3kobmF2bWVzaCkpO1xuICAgICAgICBuYXZtZXNoLnNldFN0cmF0ZWd5KFwiYXN0YXJcIik7XG4gICAgICAgIHRoaXMubmF2TWFuYWdlci5hZGROYXZpZ2FibGVFbnRpdHkoXCJuYXZtZXNoXCIsIG5hdm1lc2gpO1xuXG4gICAgICAgIHRoaXMuaW5pdEludmVudG9yeVNsb3RzTWFwKCk7XG4gICAgICAgIC8vIGNyZWF0ZSBzY3JlZW4gZmlyc3QgXG4gICAgICAgIGlmICghdGhpcy5vcHRpb24uaXNmb2dPZldhckNoZWNrZWQpXG4gICAgICAgICAgICAvLyB0aGlzLmluaXRGb2dPZldhcigpO1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCk7XG4gICAgICAgIHRoaXMuaW5pdFBhdXNlTWVudUxheWVyKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxldmVsRW5kcygpO1xuICAgICAgICB0aGlzLmluaXRBbGxHYW1lSXRlbXMoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbi5pc0FzdGFyQ2hlY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0UGxheWVyU3RhdFVJKCk7XG4gICAgICAgICAgICB0aGlzLmluaXROUENzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQsIHsga2V5OiB0aGlzLmxldmVsTXVzaWNLZXksIGxvb3A6IHRydWUsIGhvbGRSZWZlcmVuY2U6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGluaXROUENzKCk6IHZvaWQge1xuICAgICAgICBsZXQgbW9uc3RlciA9IHRoaXMubG9hZC5nZXRPYmplY3QoXCJtb25zdGVyXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vbnN0ZXIuc2xpbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBucGMgPSB0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShOUENBY3RvciwgXCJibGFja19wdWRkaW5nXCIsIHRoaXMuR2FtZUxheWVycy5CQVNFKTtcbiAgICAgICAgICAgIG5wYy5wb3NpdGlvbi5zZXQobW9uc3Rlci5zbGltZVtpXVswXSwgbW9uc3Rlci5zbGltZVtpXVsxXSk7XG4gICAgICAgICAgICBucGMuYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDcsIDcpKSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgbnBjLnNjYWxlID0gbmV3IFZlYzIoMC4xNSwgMC4xNSk7XG4gICAgICAgICAgICBucGMubmF2a2V5ID0gXCJuYXZtZXNoXCI7XG4gICAgICAgICAgICBucGMuYWRkQUkoU2xpbWVCZWhhdmlvciwgeyB0YXJnZXQ6IG5ldyBCYXNpY1RhcmdldGFibGUobmV3IFBvc2l0aW9uKG5wYy5wb3NpdGlvbi54LCBucGMucG9zaXRpb24ueSkpLCByYW5nZTogMTAwIH0pO1xuICAgICAgICAgICAgbnBjLmFuaW1hdGlvbi5wbGF5KFwiSURMRVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYmF0dGxlcnMucHVzaChucGMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9uc3Rlci50cm9sbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5wYyA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKE5QQ0FjdG9yLCBcInRyb2xsXCIsIHRoaXMuR2FtZUxheWVycy5CQVNFKTtcbiAgICAgICAgICAgIG5wYy5wb3NpdGlvbi5zZXQobW9uc3Rlci50cm9sbFtpXVswXSwgbW9uc3Rlci50cm9sbFtpXVsxXSk7XG4gICAgICAgICAgICBucGMuYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDcsIDcpKSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgbnBjLnNjYWxlID0gbmV3IFZlYzIoMS41LCAxLjUpO1xuICAgICAgICAgICAgY29uc3QgaGFsZlNpemUgPSB0aGlzLnBsYXllci5zaXplV2l0aFpvb20uc2NhbGUoMC4xKTtcbiAgICAgICAgICAgIG5wYy5zZXRDb2xsaXNpb25TaGFwZShuZXcgQUFCQihucGMucG9zaXRpb24sIGhhbGZTaXplKSk7XG4gICAgICAgICAgICBucGMubmF2a2V5ID0gXCJuYXZtZXNoXCI7XG4gICAgICAgICAgICBucGMuYWRkQUkoU2xpbWVCZWhhdmlvciwgeyB0YXJnZXQ6IG5ldyBCYXNpY1RhcmdldGFibGUobmV3IFBvc2l0aW9uKG5wYy5wb3NpdGlvbi54LCBucGMucG9zaXRpb24ueSkpLCByYW5nZTogMTAwIH0pO1xuICAgICAgICAgICAgbnBjLmFuaW1hdGlvbi5wbGF5KFwiSURMRVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYmF0dGxlcnMucHVzaChucGMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGxvYWRTY2VuZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2FkQWxsR2FtZUl0ZW1zKCk7XG4gICAgICAgIC8vIHRoaXMubG9hZEdhbWVJdGVtcyh0aGlzLmxhc2VyR3Vuc0tleSk7XG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcInByaW5jZVwiLCBcInNoYWRvd01hemVfYXNzZXRzL3Nwcml0ZXNoZWV0cy9wcmluY2UuanNvblwiKTtcblxuXG4gICAgICAgIC8vIExvYWQgdGhlIHRpbGVtYXBcbiAgICAgICAgdGhpcy5sb2FkLnRpbGVtYXAoXCJsZXZlbFwiLCBcInNoYWRvd01hemVfYXNzZXRzL3RpbGVtYXBzL2Z1dHVyZUxldmVsLmpzb25cIik7XG5cbiAgICB9XG4gICAgcHJvdGVjdGVkIGJ1aWxkTGFudGVyblNoYXBlKHBvc2l0aW9uOiBWZWMyKSB7XG4gICAgICAgIGNvbnN0IGxpZ2h0RGlzdGFuY2UgPSAxICogdGhpcy5sYWJlbFNpemU7XG4gICAgICAgIGNvbnN0IGNlbnRlclRvRWRnZSA9IG5ldyBWZWMyKGxpZ2h0RGlzdGFuY2UsIGxpZ2h0RGlzdGFuY2UpO1xuICAgICAgICB0aGlzLmxhbnRlcm5TaGFwZSA9IG5ldyBBQUJCKHBvc2l0aW9uLCBjZW50ZXJUb0VkZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5sYW50ZXJuU2hhcGU7XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgaW5pdFN1YnNjcmliZSgpIHtcblxuICAgICAgICB0aGlzLmluaXRHYW1lRXZlbnRTdWJzY3JpYmUoW1xuICAgICAgICAgICAgLi4uT2JqZWN0LnZhbHVlcyhCYXR0bGVyRXZlbnRzKSxcbiAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXMoUGxheWVyRXZlbnRzKSxcbiAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXMoTWVzc2FnZUJveEV2ZW50cyksXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShQbGF5ZXJJbnB1dC5VTFRJTUFURSk7XG4gICAgICAgIHRoaXMuaW5pdEdhbWVJdGVtRXZlbnRTdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaW5pdEdhbWVFdmVudFN1YnNjcmliZShnYW1lRXZlbnRzOiBBbGxHYW1lRXZlbnRUeXBlW10pIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBnYW1lRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGluaXRHYW1lSXRlbUV2ZW50U3Vic2NyaWJlKCkge1xuICAgICAgICBmb3IgKGxldCBnYW1lSXRlbUtleSBvZiBHYW1lSXRlbXNBcnJheSkge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoZ2FtZUl0ZW1LZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGluaXRQbGF5ZXJTdGF0VUkoKTogdm9pZCB7XG4gICAgICAgIC8vIFVJTGF5ZXIgc3R1ZmZcbiAgICAgICAgLy8gdGhpcy5hZGRVSUxheWVyKEdBTUVMYXllcnMuVUlsYXllcik7XG4gICAgICAgIC8vIEhQIExhYmVsXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ID0gdGhpcy5wbGF5ZXIuX2FpW1wiY3VycmVudFN0YXRcIl07XG4gICAgICAgIGxldCB5T2Zmc2V0ID0gMTA7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBuZXdUZXh0OiBzdHJpbmc7XG4gICAgICAgIGZvciAoY29uc3Qgc3RhdCBvZiBPYmplY3Qua2V5cyhjdXJyZW50U3RhdCkpIHtcbiAgICAgICAgICAgIGxldCBzdGF0VUkgPSB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGwsXG4gICAgICAgICAgICAgICAgYmFyOiBudWxsLFxuICAgICAgICAgICAgICAgIGJhckJnOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChQbGF5ZXJTdGF0c05hbWVBcnJheVtpbmRleF0gPT0gJ0hQJykge1xuICAgICAgICAgICAgICAgIG5ld1RleHQgPSBQbGF5ZXJTdGF0c05hbWVBcnJheVtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdUZXh0ID0gXCIgICAgXCIgKyBQbGF5ZXJTdGF0c05hbWVBcnJheVtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2JhclxuICAgICAgICAgICAgc3RhdFVJLmxhYmVsID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBHYW1lTGF5ZXJzLkJBU0UsIHsgcG9zaXRpb246IG5ldyBWZWMyKDEwLCB5T2Zmc2V0KSwgdGV4dDogbmV3VGV4dCB9KTtcbiAgICAgICAgICAgIHN0YXRVSS5sYWJlbC5zaXplLnNldCgzMDAsIDMwKTtcbiAgICAgICAgICAgIHN0YXRVSS5sYWJlbC5mb250U2l6ZSA9IDI0O1xuICAgICAgICAgICAgc3RhdFVJLmxhYmVsLmZvbnQgPSBcIkNvdXJpZXJcIjtcblxuICAgICAgICAgICAgLy9iYWNrZ3JvdW5kXG4gICAgICAgICAgICBzdGF0VUkuYmFyID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBHYW1lTGF5ZXJzLkJBU0UsIHsgcG9zaXRpb246IG5ldyBWZWMyKDc1LCB5T2Zmc2V0KSwgdGV4dDogXCJcIiB9KTtcbiAgICAgICAgICAgIHN0YXRVSS5iYXIuc2l6ZSA9IG5ldyBWZWMyKDMwMCwgMjUpO1xuICAgICAgICAgICAgc3RhdFVJLmJhci5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvcltQbGF5ZXJTdGF0c0NvbG9yQXJyYXlbaW5kZXhdXTtcblxuICAgICAgICAgICAgLy9ib3JkZXJcbiAgICAgICAgICAgIHN0YXRVSS5iYXJCZyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgR2FtZUxheWVycy5CQVNFLCB7IHBvc2l0aW9uOiBuZXcgVmVjMig3NSwgeU9mZnNldCksIHRleHQ6IFwiXCIgfSk7XG4gICAgICAgICAgICBzdGF0VUkuYmFyQmcuc2l6ZSA9IG5ldyBWZWMyKDMwMCwgMjUpO1xuICAgICAgICAgICAgc3RhdFVJLmJhckJnLmJvcmRlckNvbG9yID0gQ29sb3IuQkxBQ0s7XG4gICAgICAgICAgICB5T2Zmc2V0ICs9IDIwXG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgdGhpcy5QbGF5ZXJTdGF0VUlbc3RhdF0gPSBzdGF0VUk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBsYXllclN0YXRDaGFuZ2Uoc3RhdClcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHByb3RlY3RlZCBhZGRMYWJlbChvcHRpb246IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICAgICAgY29uc3QgbmV3VGV4dExhYmVsID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBvcHRpb24ubGF5ZXJOYW1lIHx8IHRoaXMuR2FtZUxheWVycy5CQVNFLCBvcHRpb24pO1xuICAgICAgICBpZiAob3B0aW9uLnNpemUpXG4gICAgICAgICAgICBuZXdUZXh0TGFiZWwuc2l6ZS5zZXQob3B0aW9uLnNpemUueCwgb3B0aW9uLnNpemUueSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5ld1RleHRMYWJlbC5zaXplLnNldCgzMDAsIDEwMCk7XG4gICAgICAgIG5ld1RleHRMYWJlbC5ib3JkZXJXaWR0aCA9IDI7XG4gICAgICAgIG5ld1RleHRMYWJlbC5zZXRUZXh0Q29sb3Iob3B0aW9uLnRleHRDb2xvciB8fCBDb2xvci5XSElURSlcbiAgICAgICAgbmV3VGV4dExhYmVsLnNldEZvbnQob3B0aW9uLmZvbnQgfHwgXCJBcmlhbFwiKTtcbiAgICAgICAgbmV3VGV4dExhYmVsLnNldEZvbnRTaXplKG9wdGlvbi5mb250U2l6ZSB8fCAyOCk7XG4gICAgICAgIG5ld1RleHRMYWJlbC5zZXRCYWNrZ3JvdW5kQ29sb3Iob3B0aW9uLmJhY2tncm91bmRDb2xvciB8fCBDb2xvci5CTEFDSylcbiAgICAgICAgaWYgKG9wdGlvbi5hbGlnbilcbiAgICAgICAgICAgIG5ld1RleHRMYWJlbC5zZXRIQWxpZ24ob3B0aW9uLmFsaWduKVxuICAgICAgICByZXR1cm4gbmV3VGV4dExhYmVsO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgaGFuZGxlRW50ZXJlZExldmVsRW5kKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuaXNMZXZlbEVuZEVuZXRlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzTGV2ZWxFbmRFbmV0ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmxldmVsRW5kVHJhbnNpdGlvbkxhYmVsLnR3ZWVucy5wbGF5KHR3ZWVuc0VmZmVjdC5TTElERUlOKTtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHByb3RlY3RlZCBpbml0aWFsaXplTGV2ZWxFbmRzKCkge1xuICAgICAgICB0aGlzLmxldmVsRW5kQXJlYSA9IDxSZWN0PnRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuUkVDVCwgdGhpcy5HYW1lTGF5ZXJzLkJBU0UsIHsgcG9zaXRpb246IHRoaXMubGV2ZWxFbmRQb3NpdGlvbiwgc2l6ZTogdGhpcy5sZXZlbEVuZEhhbGZTaXplIH0pO1xuICAgICAgICB0aGlzLmxldmVsRW5kQXJlYS5hZGRQaHlzaWNzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIC8vIHRoaXMubGV2ZWxFbmRBcmVhLnNldFRyaWdnZXIoUGh5c2ljc0dyb3Vwcy5QTEFZRVIsIFBsYXllckV2ZW50cy5QTEFZRVJfRU5URVJFRF9MRVZFTF9FTkQsIG51bGwpO1xuICAgICAgICAvLyB0aGlzLmxldmVsRW5kQXJlYS5zZXRUcmlnZ2VyKEhXM1BoeXNpY3NHcm91cHMuUExBWUVSLCBIVzNFdmVudHMuUExBWUVSX0VOVEVSRURfTEVWRUxfRU5ELCBudWxsKTtcbiAgICAgICAgdGhpcy5sZXZlbEVuZEFyZWEuY29sb3IgPSB0aGlzLmxldmVsRW5kQ29sb3I7XG5cbiAgICB9XG4gICAgcHJvdGVjdGVkIGFkZFR3ZWVuTGFiZWwobGFiZWw6IExhYmVsLCBvbkVuZEV2ZW50OiBzdHJpbmcsIGVmZmVjdDogc3RyaW5nKTogTGFiZWwge1xuICAgICAgICBpZiAoZWZmZWN0ID09IHR3ZWVuc0VmZmVjdC5TTElERUlOKSB7XG4gICAgICAgICAgICBsYWJlbCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgR2FtZUxheWVycy5VSSwgeyBwb3NpdGlvbjogbmV3IFZlYzIoLTUwMCwgOTYpLCB0ZXh0OiBcIkxldmVsIENvbXBsZXRlXCIgfSk7XG4gICAgICAgICAgICBsYWJlbC50d2VlbnMuYWRkKHR3ZWVuc0VmZmVjdC5TTElERUlOLCB7XG4gICAgICAgICAgICAgICAgc3RhcnREZWxheTogMCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAwMCxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzLnBvc1gsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogMjcwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzZTogRWFzZUZ1bmN0aW9uVHlwZS5PVVRfU0lORVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBvbkVuZDogb25FbmRFdmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFiZWwudHdlZW5zLmFkZCh0d2VlbnNFZmZlY3QuU0xJREVPVVQsIHtcbiAgICAgICAgICAgICAgICBzdGFydERlbGF5OiAxMDAwLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFR3ZWVuYWJsZVByb3BlcnRpZXMucG9zWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAyNzAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IDEwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLk9VVF9TSU5FXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICAgICAgLy8gb25FbmQ6IG9uRW5kRXZlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhYmVsLnNpemUuc2V0KDEyMDAsIDYwKTtcbiAgICAgICAgICAgIGxhYmVsLmJvcmRlclJhZGl1cyA9IDA7XG4gICAgICAgICAgICBsYWJlbC5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMzQsIDMyLCA1Mik7XG4gICAgICAgICAgICBsYWJlbC50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcbiAgICAgICAgICAgIGxhYmVsLmZvbnRTaXplID0gNDg7XG4gICAgICAgICAgICBsYWJlbC5mb250ID0gXCJQaXhlbFNpbXBsZVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIEdhbWVMYXllcnMuVUksIHsgcG9zaXRpb246IG5ldyBWZWMyKDMwMCwgMjAwKSwgdGV4dDogXCJcIiB9KTtcbiAgICAgICAgICAgIGxhYmVsLmFscGhhID0gMTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGFiZWwudHdlZW5zLmFkZCh0d2VlbnNFZmZlY3QuRkFERUlOLCB7XG4gICAgICAgICAgICAgICAgc3RhcnREZWxheTogMCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAwMCxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLklOX09VVF9RVUFEXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIG9uRW5kOiBvbkVuZEV2ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYWJlbC50d2VlbnMuYWRkKHR3ZWVuc0VmZmVjdC5GQURFT1VULCB7XG4gICAgICAgICAgICAgICAgc3RhcnREZWxheTogMCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAwMCxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLklOX09VVF9RVUFEXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgYWRkQnV0dG9ucyhvcHRpb246IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICAgICAgY29uc3QgbmV3QnV0dG9uID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgb3B0aW9uLmxheWVyTmFtZSB8fCB0aGlzLkdhbWVMYXllcnMuQkFTRSwgb3B0aW9uKTtcbiAgICAgICAgbmV3QnV0dG9uLnNpemUuc2V0KDUwLCA1MCk7XG4gICAgICAgIGlmIChvcHRpb24uc2l6ZSkgbmV3QnV0dG9uLnNpemUuc2V0KG9wdGlvbi5zaXplLngsIG9wdGlvbi5zaXplLnkpO1xuICAgICAgICBuZXdCdXR0b24uc2V0Qm9yZGVyV2lkdGgob3B0aW9uLmJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgICBuZXdCdXR0b24uc2V0Qm9yZGVyQ29sb3Iob3B0aW9uLkJvcmRlckNvbG9yIHx8IENvbG9yLlRSQU5TUEFSRU5UKTtcbiAgICAgICAgbmV3QnV0dG9uLnNldEJhY2tncm91bmRDb2xvcihvcHRpb24uYmFja2dyb3VuZENvbG9yIHx8IENvbG9yLkJMQUNLKVxuICAgICAgICBuZXdCdXR0b24uc2V0VGV4dENvbG9yKG9wdGlvbi50ZXh0Q29sb3IgfHwgQ29sb3IuV0hJVEUpXG4gICAgICAgIG5ld0J1dHRvbi5vbkNsaWNrRXZlbnRJZCA9IG9wdGlvbi5idXR0b25OYW1lO1xuICAgICAgICBuZXdCdXR0b24uc2V0Rm9udFNpemUoNTApO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShvcHRpb24uYnV0dG9uTmFtZSk7XG4gICAgICAgIHJldHVybiBuZXdCdXR0b247XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFkZEJhY2tCdXRvbihwb3NpdGlvbjogVmVjMikge1xuICAgICAgICBjb25zdCBsZWZ0QXJyb3cgPSAnXFx1MjE5MCc7XG4gICAgICAgIGxldCBidXR0b25PcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIocG9zaXRpb24ueCwgcG9zaXRpb24ueSksXG4gICAgICAgICAgICB0ZXh0OiBsZWZ0QXJyb3csXG4gICAgICAgICAgICBidXR0b25OYW1lOiBCYWNrQnV0dG9uRXZlbnQuQkFDSyxcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEJ1dHRvbnMoYnV0dG9uT3B0aW9uKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpIHtcblxuICAgICAgICB3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xuICAgICAgICAgICAgY29uc3QgZ2FtZUV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChnYW1lRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiZXNjYXBlXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KFBhdXNlQnV0dG9uRXZlbnQuUEFVU0UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJsZUdyb3VwKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbi5pc0FzdGFyQ2hlY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIubW92ZU9uUGF0aCgxLCB0aGlzLnBhdGgpXG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoLmlzRG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFbnRlcmVkTGV2ZWxFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUGxheWVyU3RhdENoYW5nZShcImN1cnJlbnRTaGllbGRcIik7XG4gICAgICAgICAgICB0aGlzLmlzUGxheWVyQXRJdGVtcygpO1xuICAgICAgICAgICAgdGhpcy5pc1BsYXllckF0dGFja2luZygpO1xuICAgICAgICAgICAgdGhpcy5pc1BsYXllclVzZUl0ZW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNQbGF5ZXJBdExldmVsRW5kKCk7XG4gICAgfVxuICAgIHByb3RlY3RlZCB1cGRhdGVWaXNpYmxlR3JvdXAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnBhcmVudExhYmVscyh0aGlzLnBsYXllcik7XG4gICAgICAgIGlmICh0aGlzLnVsdGltYXRlV2F2ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMudWx0aW1hdGVXYXZlLnBvc2l0aW9uLmRpc3RhbmNlVG8odGhpcy5wbGF5ZXIucG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMudWx0aW1hdGVXYXZlLmNvbGxpc2lvblNoYXBlLm92ZXJsYXBzKHRoaXMucGxheWVyLmNvbGxpc2lvblNoYXBlKVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gdGhpcy51bHRpbWF0ZVdhdmVQbGF5ZXJEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy51bHRpbWF0ZVdhdmUuY3VycmVudFRyYW5zcGFyZW50TGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudWx0aW1hdGVXYXZlLmN1cnJlbnRUcmFuc3BhcmVudExhYmVscyA9IHRoaXMuaW5pdFRyYW5zcGFyZW50TGFiZWxCeVBvc2l0aW9uKHRoaXMudWx0aW1hdGVXYXZlLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5wYXJlbnRMYWJlbHModGhpcy51bHRpbWF0ZVdhdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVVbHRpbWF0ZVdhdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgaXNVbHRpbWF0ZUxlZnRQbGF5ZXIoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBsYWJsZXMgPSB0aGlzLmdldExhYmVsc0J5UG9zaXRpb24odGhpcy51bHRpbWF0ZVdhdmUucG9zaXRpb24pO1xuXG4gICAgICAgIGxhYmxlcyA9IGxhYmxlcy5maWx0ZXIobGFiZWwgPT4gbGFiZWwuYmFja2dyb3VuZENvbG9yID09IENvbG9yLkZPR19PRl9XQVJfVFJBTlNQQVJFTlQpXG4gICAgICAgIHJldHVybiBsYWJsZXMubGVuZ3RoID09IDA7XG4gICAgfVxuICAgIHByb3RlY3RlZCB1cGRhdGVVbHRpbWF0ZVdhdmUoKSB7XG4gICAgICAgIGxldCBvbGRQb3NpdGlvbiA9IHRoaXMudWx0aW1hdGVXYXZlLnBvc2l0aW9uO1xuICAgICAgICBsZXQgdHJhdmVsbGluZ0RpcmVjdGlvblZlYyA9IHRoaXMudWx0aW1hdGVXYXZlRGlyZWN0aW9uO1xuICAgICAgICAvLyB0aGlzLnVsdGltYXRlV2F2ZS5jdXJyZW50VHJhbnNwYXJlbnRMYWJlbHMgPSB0aGlzLmluaXRUcmFuc3BhcmVudExhYmVsQnlQb3NpdGlvbih0aGlzLnVsdGltYXRlV2F2ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgY29uc3QgcmF0aW8gPSA4O1xuICAgICAgICB0aGlzLnVsdGltYXRlV2F2ZS5wb3NpdGlvbi5zZXQob2xkUG9zaXRpb24ueCArIHRyYXZlbGxpbmdEaXJlY3Rpb25WZWMueCAvIHJhdGlvLCBvbGRQb3NpdGlvbi55ICsgdHJhdmVsbGluZ0RpcmVjdGlvblZlYy55IC8gcmF0aW8pO1xuICAgICAgICBpZiAodGhpcy5oYXNWZWNPdXRPZkJvdW5kKHRoaXMudWx0aW1hdGVXYXZlLnBvc2l0aW9uLngpIHx8XG4gICAgICAgICAgICB0aGlzLmhhc1ZlY091dE9mQm91bmQodGhpcy51bHRpbWF0ZVdhdmUucG9zaXRpb24ueSkpIHtcbiAgICAgICAgICAgIHRoaXMudWx0aW1hdGVXYXZlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudWx0aW1hdGVXYXZlLmN1cnJlbnRUcmFuc3BhcmVudExhYmVscy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5wYXJlbnRMYWJsZXNDb2xvcihsYWJlbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy51bHRpbWF0ZVdhdmUuY3VycmVudFRyYW5zcGFyZW50TGFiZWxzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tVbHRpbWF0ZU1vbnN0ZXJzQ29sbGlzaW9uKCk7XG4gICAgfVxuICAgIHByb3RlY3RlZCBjaGVja1VsdGltYXRlTW9uc3RlcnNDb2xsaXNpb24oKSB7XG4gICAgICAgIHRoaXMuYmF0dGxlcnMuZm9yRWFjaChiYXR0bGVyID0+IHtcbiAgICAgICAgICAgIGlmIChiYXR0bGVyLmJhdHRsZXJBY3RpdmUgJiYgIShiYXR0bGVyID09IHRoaXMucGxheWVyKSkge1xuICAgICAgICAgICAgICAgIGlmIChiYXR0bGVyLnBvc2l0aW9uLmRpc3RhbmNlVG8odGhpcy51bHRpbWF0ZVdhdmUucG9zaXRpb24pIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChCYXR0bGVyRXZlbnRzLk1PTlNURVJfREVBRCwgeyBpZDogYmF0dGxlci5pZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgaGFzVmVjT3V0T2ZCb3VuZCh4OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHggPCAtMTUgfHwgeCA+IDU0MCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgaXNQbGF5ZXJVc2VJdGVtKCkge1xuICAgICAgICBJdGVtQnV0dG9uS2V5QXJyYXkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKElucHV0LmlzS2V5SnVzdFByZXNzZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uSXRlbU1hcCA9IHRoaXMuaW52ZW50b3J5U2xvdHNNYXAuZ2V0KHBhcnNlSW50KGtleSkpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHBvc2l0aW9uSXRlbU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYW1lSXRlbSA9IHZhbHVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChnYW1lSXRlbS5uYW1lLCB7IGFjdGlvbjogQUNUSU9OVFlQRS5VU0UsIGdhbWVJdGVtOiBnYW1lSXRlbSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoTWVzc2FnZUJveEV2ZW50cy5TSE9XLCB7IG1lc3NhZ2U6IE1lc3NhZ2VCb3hFdmVudHMuSVRFTV9OT1RfRk9VTkQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gICAgcHVibGljIGlzUGxheWVyQXRMZXZlbEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGV2ZWxFbmRQb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5wbGF5ZXIucG9zaXRpb24pIDwgMTApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0xldmVsRW5kRW5ldGVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChQbGF5ZXJFdmVudHMuUExBWUVSX0VOVEVSRURfTEVWRUxfRU5EKVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLmdldCh0aGlzLmFjdGlvbikgPT0gQUNUSU9OVFlQRS5QSUNLKVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQaWNrR2FtZUl0ZW1zRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5nZXQodGhpcy5hY3Rpb24pID09IEFDVElPTlRZUEUuVVNFKVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVVc2VHYW1lSXRlbXNFdmVudChldmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQmF0dGxlckV2ZW50cyhldmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5HYW1lTWVzc2FnZUJveChldmVudCk7XG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVJbkdhbWVNZXNzYWdlQm94KGV2ZW50OiBHYW1lRXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VCb3hFdmVudHMuU0hPVzpcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VCb3hMYWJlbC50ZXh0ID0gZXZlbnQuZGF0YS5nZXQoXCJtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUJveExhYmVsLnR3ZWVucy5wbGF5KHR3ZWVuc0VmZmVjdC5TTElERUlOKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZUJveEV2ZW50cy5ISURERU46XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGYWRlcyBvdXRcIilcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VCb3hMYWJlbC50d2VlbnMucGxheSh0d2VlbnNFZmZlY3QuU0xJREVPVVQpO1xuXG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZUJhdHRsZXJFdmVudHMoZXZlbnQ6IEdhbWVFdmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQmF0dGxlckV2ZW50cy5NT05TVEVSX0RFQUQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJhdHRsZXJLaWxsZWQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsYXllci5fYWlbXCJjdXJyZW50U3RhdFwiXVtcImN1cnJlbnRFbmVyZ3lcIl0gPCB0aGlzLnBsYXllck1heFN0YXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXllci5fYWlbXCJjdXJyZW50U3RhdFwiXVtcImN1cnJlbnRFbmVyZ3lcIl0rKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQbGF5ZXJTdGF0Q2hhbmdlKFwiY3VycmVudEVuZXJneVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQmF0dGxlckV2ZW50cy5QUklOQ0VfSElUOiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBsYXllci5fYWlbXCJpc0ludmluY2libGVcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIuX2FpW1wiY3VycmVudFN0YXRcIl1bXCJjdXJyZW50SGVhbHRoXCJdLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGxheWVyU3RhdENoYW5nZShcImN1cnJlbnRIZWFsdGhcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBCYXR0bGVyRXZlbnRzLlBSSU5DRV9ERUFEOiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3BvcnQuc2V0Wm9vbUxldmVsKDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKFNlbGVjdExldmVsTWVudVNjZW5lLCB0aGlzLm9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSwgMjAwMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUGxheWVySW5wdXQuVUxUSU1BVEU6IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudWx0aW1hdGVXYXZlLnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRmlyZVVsdGltYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZUZpcmVVbHRpbWF0ZSgpIHtcbiAgICAgICAgdGhpcy51bHRpbWF0ZVdhdmUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGxldCBmYWNlRGlyZWN0aW9uVmVjID0gdGhpcy5nZXRGYWNlRGlyZWN0aW9uVmVjKCk7XG4gICAgICAgIHRoaXMudWx0aW1hdGVXYXZlLnBvc2l0aW9uLnNldChmYWNlRGlyZWN0aW9uVmVjLngsIGZhY2VEaXJlY3Rpb25WZWMueSk7XG4gICAgICAgIHRoaXMudWx0aW1hdGVXYXZlRGlyZWN0aW9uID0gZmFjZURpcmVjdGlvblZlYy5zdWIodGhpcy5wbGF5ZXIucG9zaXRpb24pO1xuICAgICAgICAvLyB0aGlzLnVsdGltYXRlV2F2ZS5jdXJyZW50VHJhbnNwYXJlbnRMYWJlbHMgPSB0aGlzLmluaXRUcmFuc3BhcmVudExhYmVsQnlQb3NpdGlvbih0aGlzLnVsdGltYXRlV2F2ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy51bHRpbWF0ZVdhdmUucm90YXRpb24gPSB0aGlzLnBsYXllci5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy51bHRpbWF0ZVdhdmVGaXJlZHBvc2l0aW9uLnggPSB0aGlzLnBsYXllci5wb3NpdGlvbi54O1xuICAgICAgICB0aGlzLnVsdGltYXRlV2F2ZUZpcmVkcG9zaXRpb24ueSA9IHRoaXMucGxheWVyLnBvc2l0aW9uLnk7XG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVCYXR0bGVyS2lsbGVkKGV2ZW50OiBHYW1lRXZlbnQpIHtcbiAgICAgICAgbGV0IGlkOiBudW1iZXIgPSBldmVudC5kYXRhLmdldChcImlkXCIpO1xuICAgICAgICBsZXQgYmF0dGxlciA9IHRoaXMuYmF0dGxlcnMuZmluZChiID0+IGIuaWQgPT09IGlkKTtcbiAgICAgICAgaWYgKGJhdHRsZXIpIHtcbiAgICAgICAgICAgIGJhdHRsZXIuYmF0dGxlckFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVVc2VHYW1lSXRlbXNFdmVudChldmVudDogR2FtZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuUmVtb3ZlSXRlbUZyb21JbnZlbnRvcnkoZXZlbnQpXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBHYW1lSXRlbXMuTEFOVEVSTlM6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhbnRlcm5EdXJhdGlvbiA9ICF0aGlzLmxhbnRlcm5EdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLnVsdGltYXRlV2F2ZVBsYXllckRpc3RhbmNlID0gNzA7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChNZXNzYWdlQm94RXZlbnRzLlNIT1cse21lc3NhZ2U6TWVzc2FnZUJveEV2ZW50cy5VU0VfTEFOVEVSTn0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdhbWVJdGVtcy5ET09SOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93UG9zaXRpb25CeUNvbG9yKHRoaXMubGV2ZWxFbmRQb3NpdGlvbiwgQ29sb3IuVFJBTlNQQVJFTlQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoTWVzc2FnZUJveEV2ZW50cy5TSE9XLHttZXNzYWdlOk1lc3NhZ2VCb3hFdmVudHMuVVNFX0RPT1J9KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHYW1lSXRlbXMuSEVBTFRIX1BBQ0tTOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxheWVyLl9haVtcImN1cnJlbnRTdGF0XCJdW1wiY3VycmVudEhlYWx0aFwiXSA8IHRoaXMucGxheWVyTWF4U3RhdFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXllci5fYWlbXCJjdXJyZW50U3RhdFwiXVtcImN1cnJlbnRIZWFsdGhcIl0rKztcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBsYXllclN0YXRDaGFuZ2UoXCJjdXJyZW50SGVhbHRoXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoTWVzc2FnZUJveEV2ZW50cy5TSE9XLHttZXNzYWdlOk1lc3NhZ2VCb3hFdmVudHMuVVNFX0hFQUxUSF9QQUNLfSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgR2FtZUl0ZW1zLlBIQVNJTkdQT1RJT046IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYWxmU2l6ZSA9IHRoaXMucGxheWVyLnNpemVXaXRoWm9vbS5zY2FsZSgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXllci5zZXRDb2xsaXNpb25TaGFwZShuZXcgQUFCQih0aGlzLnBsYXllci5wb3NpdGlvbiwgaGFsZlNpemUpKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoTWVzc2FnZUJveEV2ZW50cy5TSE9XLHttZXNzYWdlOk1lc3NhZ2VCb3hFdmVudHMuVVNFX1BIQVNJTkdfUE9USU9OfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgUmVtb3ZlSXRlbUZyb21JbnZlbnRvcnkoZXZlbnQ6IEdhbWVFdmVudCkge1xuICAgICAgICBjb25zdCBnYW1lSXRlbSA9IGV2ZW50LmRhdGEuZ2V0KFwiZ2FtZUl0ZW1cIik7XG4gICAgICAgIGdhbWVJdGVtLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZU1lbnVTdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLk1lbnVDdXJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBNZW51U3RhdGUuSElEREVOOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5NZW51Q3VyZW50U3RhdGUgPSBNZW51U3RhdGUuU0hPV047XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lbnVTdGF0ZS5TSE9XTjoge1xuICAgICAgICAgICAgICAgIHRoaXMuTWVudUN1cmVudFN0YXRlID0gTWVudVN0YXRlLkhJRERFTjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVudVN0YXRlLkNPTlRST0xfVEVYVF9NRU5VX1NIT1dOOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5NZW51Q3VyZW50U3RhdGUgPSBNZW51U3RhdGUuU0hPV047XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lbnVTdGF0ZS5IRUxQX1RFWFRfTUVOVV9TSE9XTjoge1xuICAgICAgICAgICAgICAgIHRoaXMuTWVudUN1cmVudFN0YXRlID0gTWVudVN0YXRlLlNIT1dOO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVNZW51U2hvd24oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5NZW51Q3VyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgTWVudVN0YXRlLkhJRERFTjoge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyQW5kTWVudShHYW1lTGF5ZXJzLlBBVVNFX01FTlVfQ09OVEFJTkVSLCBHYW1lTGF5ZXJzLlBBVVNFX01FTlUsIHRydWUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lbnVTdGF0ZS5TSE9XTjoge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyQW5kTWVudShHYW1lTGF5ZXJzLlBBVVNFX01FTlVfQ09OVEFJTkVSLCBHYW1lTGF5ZXJzLlBBVVNFX01FTlUsIGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyQW5kTWVudShHYW1lTGF5ZXJzLkNPTlRST0xfVEVYVF9NRU5VX0NPTlRBSU5FUiwgR2FtZUxheWVycy5DT05UUk9MX1RFWFRfTUVOVSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbnRhaW5lckFuZE1lbnUoR2FtZUxheWVycy5IRUxQX1RFWFRfTUVOVV9DT05UQUlORVIsIEdhbWVMYXllcnMuSEVMUF9URVhUX01FTlUsIHRydWUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lbnVTdGF0ZS5DT05UUk9MX1RFWFRfTUVOVV9TSE9XTjoge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyQW5kTWVudShHYW1lTGF5ZXJzLkNPTlRST0xfVEVYVF9NRU5VX0NPTlRBSU5FUiwgR2FtZUxheWVycy5DT05UUk9MX1RFWFRfTUVOVSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lbnVTdGF0ZS5IRUxQX1RFWFRfTUVOVV9TSE9XTjoge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyQW5kTWVudShHYW1lTGF5ZXJzLkhFTFBfVEVYVF9NRU5VX0NPTlRBSU5FUiwgR2FtZUxheWVycy5IRUxQX1RFWFRfTUVOVSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIHNldENvbnRhaW5lckFuZE1lbnUoY29udGFpbmVyOiBzdHJpbmcsIG1lbnU6IHN0cmluZywgZmxhZzogYm9vbGVhbiwpIHtcbiAgICAgICAgdGhpcy5nZXRMYXllcihjb250YWluZXIpLnNldEhpZGRlbihmbGFnKTtcbiAgICAgICAgdGhpcy5nZXRMYXllcihtZW51KS5zZXRIaWRkZW4oZmxhZyk7XG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVQaWNrR2FtZUl0ZW1zRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCkge1xuICAgICAgICB0aGlzLnB1dEl0ZW1Ub0ludmVudG9yeShldmVudClcbiAgICB9XG4gICAgcHJvdGVjdGVkIHB1dEl0ZW1Ub0ludmVudG9yeShldmVudDogR2FtZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGdhbWVJdGVtID0gPExhc2VyR3VuPmV2ZW50LmRhdGEuZ2V0KFwiZ2FtZUl0ZW1cIik7XG4gICAgICAgIGZvciAobGV0IHBvc3Rpb25JdGVtc01hcCBvZiBBcnJheS5mcm9tKHRoaXMuaW52ZW50b3J5U2xvdHNNYXAudmFsdWVzKCkpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBwb3N0aW9uSXRlbXNNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdhbWVJdGVtLnBvc2l0aW9uLnNldChrZXlbMF0sIGtleVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvc3Rpb25JdGVtc01hcC5zZXQoa2V5LCBbZ2FtZUl0ZW1dKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgc2hvd1Bvc2l0aW9uQnlDb2xvcihwb3NpdGlvbjogVmVjMiwgY29sb3I6IENvbG9yKSB7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzQnlQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIGxhYmVscy5mb3JFYWNoKGxhYmVsID0+IHtcbiAgICAgICAgICAgIGlmIChsYWJlbC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwuYmFja2dyb3VuZENvbG9yLmlzRXF1YWwoQ29sb3IuRk9HX09GX1dBUl9CTEFDSykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuYmFja2dyb3VuZENvbG9yID0gY29sb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFiZWwuYmFja2dyb3VuZENvbG9yLmlzRXF1YWwoQ29sb3IuVFJBTlNQQVJFTlQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLmJhY2tncm91bmRDb2xvciA9IGNvbG9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBpbml0VHJhbnNwYXJlbnRMYWJlbEJ5UG9zaXRpb24ocG9zaXRpb246IFZlYzIpOiBBcnJheTxMYWJlbD4ge1xuICAgICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0J5UG9zaXRpb24ocG9zaXRpb24pXG4gICAgICAgIGxhYmVscy5mb3JFYWNoKGxhYmVsID0+IHsgdGhpcy51cGRhdGVUcmFucGFyZW50TGFibGVzQ29sb3IobGFiZWwpIH0pXG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfVxuICAgIHB1YmxpYyB1cGRhdGVUcmFucGFyZW50TGFiZWxzKHNwcml0ZTogU3ByaXRlKSB7XG4gICAgICAgIGxldCBuZXh0VHJhbnNwYXJlbnRMYWJlbHMgPSB0aGlzLmdldExhYmVsc0J5UG9zaXRpb24oc3ByaXRlLnBvc2l0aW9uKTtcbiAgICAgICAgc3ByaXRlLmN1cnJlbnRUcmFuc3BhcmVudExhYmVscy5mb3JFYWNoKGxhYmVsID0+IHsgdGhpcy51cGRhdGVUcmFucGFyZW50TGFibGVzQ29sb3IobGFiZWwpIH0pXG4gICAgICAgIG5leHRUcmFuc3BhcmVudExhYmVscy5mb3JFYWNoKGxhYmVsID0+IHRoaXMudXBkYXRlVHJhbnBhcmVudExhYmxlc0NvbG9yKGxhYmVsKSlcbiAgICAgICAgc3ByaXRlLmN1cnJlbnRUcmFuc3BhcmVudExhYmVscyA9IG5leHRUcmFuc3BhcmVudExhYmVsc1xuICAgIH1cbiAgICBwdWJsaWMgZ2V0TGFiZWxzQnlQb3NpdGlvbihwb3N0aW9uOiBWZWMyKTogQXJyYXk8TGFiZWw+IHtcbiAgICAgICAgbGV0IGxhYmVsczogQXJyYXk8TGFiZWw+XG4gICAgICAgIGlmICghdGhpcy5sYW50ZXJuRHVyYXRpb24pIHtcbiAgICAgICAgICAgIGxhYmVscyA9IDxBcnJheTxMYWJlbD4+dGhpcy5nZXRTY2VuZUdyYXBoKCkuZ2V0Tm9kZXNBdChwb3N0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVscyA9IDxBcnJheTxMYWJlbD4+dGhpcy5nZXRTY2VuZUdyYXBoKCkuZ2V0Tm9kZXNJblJlZ2lvbih0aGlzLmJ1aWxkTGFudGVyblNoYXBlKHBvc3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBsYWJlbHMgPSBsYWJlbHMuZmlsdGVyKGxhYmVsID0+IGxhYmVsLmdldExheWVyKCkuZ2V0TmFtZSgpID09IEdhbWVMYXllcnMuRk9HX09GX1dBUilcbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9XG4gICAgcHVibGljIHVwZGF0ZVRyYW5wYXJlbnRMYWJsZXNDb2xvcihsYWJlbDogTGFiZWwpIHtcbiAgICAgICAgaWYgKGxhYmVsLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgaWYgKGxhYmVsLmJhY2tncm91bmRDb2xvci5pc0VxdWFsKENvbG9yLkZPR19PRl9XQVJfQkxBQ0spKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuRk9HX09GX1dBUl9UUkFOU1BBUkVOVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhYmVsLmJhY2tncm91bmRDb2xvci5pc0VxdWFsKENvbG9yLkZPR19PRl9XQVJfVFJBTlNQQVJFTlQpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuRk9HX09GX1dBUl9CTEFDSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgaW5pdExheWVycygpOiB2b2lkIHtcbiAgICAgICAgbGV0IGRlcHRoID0gMTtcbiAgICAgICAgZm9yIChjb25zdCBsYXllciBpbiBHYW1lTGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZExheWVyKGxheWVyLCBkZXB0aCk7XG4gICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyQW5kTWVudShHYW1lTGF5ZXJzLlBBVVNFX01FTlVfQ09OVEFJTkVSLCBHYW1lTGF5ZXJzLlBBVVNFX01FTlUsIHRydWUpO1xuICAgICAgICB0aGlzLnNldENvbnRhaW5lckFuZE1lbnUoR2FtZUxheWVycy5DT05UUk9MX1RFWFRfTUVOVV9DT05UQUlORVIsIEdhbWVMYXllcnMuQ09OVFJPTF9URVhUX01FTlUsIHRydWUpXG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyQW5kTWVudShHYW1lTGF5ZXJzLkhFTFBfVEVYVF9NRU5VX0NPTlRBSU5FUiwgR2FtZUxheWVycy5IRUxQX1RFWFRfTUVOVSwgdHJ1ZSlcbiAgICB9XG4gICAgcHJvdGVjdGVkIGhhbmRsZVBsYXllclN0YXRDaGFuZ2UodHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8vIHRoaXMuUGxheWVyU3RhdFVJW1BsYXllclN0YXRzTmFtZUFycmF5W2luZGV4XV0gPSBzdGF0VUk7XG4gICAgICAgIGxldCBvbmVTdGF0VUkgPSB0aGlzLlBsYXllclN0YXRVSVt0eXBlXVxuICAgICAgICBjb25zdCBjdXJyZW50U3RhdFZhbHVlID0gdGhpcy5wbGF5ZXIuX2FpW1wiY3VycmVudFN0YXRcIl1bdHlwZV1cbiAgICAgICAgbGV0IHVuaXQgPSBvbmVTdGF0VUlbXCJiYXJCZ1wiXS5zaXplLnggLyB0aGlzLnBsYXllck1heFN0YXRWYWx1ZTtcbiAgICAgICAgb25lU3RhdFVJW1wiYmFyXCJdLnNpemUuc2V0KG9uZVN0YXRVSVtcImJhckJnXCJdLnNpemUueCAtIHVuaXQgKiAodGhpcy5wbGF5ZXJNYXhTdGF0VmFsdWUgLSBjdXJyZW50U3RhdFZhbHVlKSwgb25lU3RhdFVJW1wiYmFyQmdcIl0uc2l6ZS55KTtcbiAgICAgICAgb25lU3RhdFVJW1wiYmFyXCJdLnBvc2l0aW9uLnNldChvbmVTdGF0VUlbXCJiYXJCZ1wiXS5wb3NpdGlvbi54IC0gKHVuaXQgLyAyIC8gdGhpcy5nZXRWaWV3U2NhbGUoKSkgKiAodGhpcy5wbGF5ZXJNYXhTdGF0VmFsdWUgLSBjdXJyZW50U3RhdFZhbHVlKSwgb25lU3RhdFVJW1wiYmFyQmdcIl0ucG9zaXRpb24ueSk7XG4gICAgICAgIGlmICh0eXBlID09IFwiY3VycmVudEhlYWx0aFwiKVxuICAgICAgICAgICAgb25lU3RhdFVJW1wiYmFyXCJdLmJhY2tncm91bmRDb2xvciA9IGN1cnJlbnRTdGF0VmFsdWUgPCB0aGlzLnBsYXllck1heFN0YXRWYWx1ZSAqIDEgLyA0ID8gQ29sb3IuUkVEIDogY3VycmVudFN0YXRWYWx1ZSA8IHRoaXMucGxheWVyTWF4U3RhdFZhbHVlICogMyAvIDQgPyBDb2xvci5ZRUxMT1cgOiBDb2xvci5HUkVFTjtcbiAgICB9XG5cblxuICAgIHByb3RlY3RlZCBpc1BsYXllckF0dGFja2luZygpIHtcbiAgICAgICAgbGV0IG1pZHBvaW50ID0gdGhpcy5nZXRGYWNlRGlyZWN0aW9uVmVjKCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBiYXR0bGVyIG9mIHRoaXMuYmF0dGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChiYXR0bGVyID09IHRoaXMucGxheWVyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmF0dGxlci5iYXR0bGVyQWN0aXZlICYmIGJhdHRsZXIucG9zaXRpb24uZGlzdGFuY2VUbyhtaWRwb2ludCkgPD0gMTUgJiYgdGhpcy5wbGF5ZXIuYW5pbWF0aW9uLmlzUGxheWluZyhcIkFUVEFDS0lOR1wiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQmF0dGxlckV2ZW50cy5NT05TVEVSX0RFQUQsIHsgaWQ6IGJhdHRsZXIuaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmF0dGxlci5iYXR0bGVyQWN0aXZlICYmIGJhdHRsZXIucG9zaXRpb24uZGlzdGFuY2VUbyh0aGlzLnBsYXllci5wb3NpdGlvbikgPCAxMCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wbGF5ZXIuX2FpWydpc0ludmluY2libGUnXSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChCYXR0bGVyRXZlbnRzLlBSSU5DRV9ISVQsIHsgaWQ6IGJhdHRsZXIuaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGdldEZhY2VEaXJlY3Rpb25WZWMoKTogVmVjMiB7XG4gICAgICAgIGxldCBtaWRwb2ludCA9IG5ldyBWZWMyKHRoaXMucGxheWVyLnBvc2l0aW9uLngsIHRoaXMucGxheWVyLnBvc2l0aW9uLnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGxheWVyLnJvdGF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gbWlkcG9pbnQgPSBuZXcgVmVjMih0aGlzLnBsYXllci5wb3NpdGlvbi54LCB0aGlzLnBsYXllci5wb3NpdGlvbi55IC0gMTUpO1xuICAgICAgICAgICAgICAgIG1pZHBvaW50LnkgPSB0aGlzLnBsYXllci5wb3NpdGlvbi55IC0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMuMTU6XG4gICAgICAgICAgICAgICAgbWlkcG9pbnQueSA9IHRoaXMucGxheWVyLnBvc2l0aW9uLnkgKyAxNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMS41OlxuICAgICAgICAgICAgICAgIG1pZHBvaW50LnggPSB0aGlzLnBsYXllci5wb3NpdGlvbi54IC0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQuNzU6XG4gICAgICAgICAgICAgICAgbWlkcG9pbnQueCA9IHRoaXMucGxheWVyLnBvc2l0aW9uLnggKyAxNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNS4yNTpcbiAgICAgICAgICAgICAgICBtaWRwb2ludC54ID0gdGhpcy5wbGF5ZXIucG9zaXRpb24ueCArIDEwO1xuICAgICAgICAgICAgICAgIG1pZHBvaW50LnkgPSB0aGlzLnBsYXllci5wb3NpdGlvbi55IC0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDAuNzU6XG4gICAgICAgICAgICAgICAgbWlkcG9pbnQueCA9IHRoaXMucGxheWVyLnBvc2l0aW9uLnggLSAxMDtcbiAgICAgICAgICAgICAgICBtaWRwb2ludC55ID0gdGhpcy5wbGF5ZXIucG9zaXRpb24ueSAtIDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzLjc1OlxuICAgICAgICAgICAgICAgIG1pZHBvaW50LnggPSB0aGlzLnBsYXllci5wb3NpdGlvbi54ICsgMTA7XG4gICAgICAgICAgICAgICAgbWlkcG9pbnQueSA9IHRoaXMucGxheWVyLnBvc2l0aW9uLnkgKyAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMi4yNTpcbiAgICAgICAgICAgICAgICBtaWRwb2ludC54ID0gdGhpcy5wbGF5ZXIucG9zaXRpb24ueCAtIDEwO1xuICAgICAgICAgICAgICAgIG1pZHBvaW50LnkgPSB0aGlzLnBsYXllci5wb3NpdGlvbi55ICsgMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG1pZHBvaW50ID0gdGhpcy5wbGF5ZXIucG9zaXRpb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pZHBvaW50O1xuICAgIH1cbiAgICBwcm90ZWN0ZWQgaXNQbGF5ZXJBdEl0ZW1zKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGdhbWVJdGVtcyBvZiB0aGlzLmdhbWVJdGVtc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZ2FtZUl0ZW1zLmZvckVhY2goZ2FtZUl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChnYW1lSXRlbS52aXNpYmxlICYmIGdhbWVJdGVtLnBvc2l0aW9uLmRpc3RhbmNlVG8odGhpcy5wbGF5ZXIucG9zaXRpb24pIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2FtZUl0ZW0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KGdhbWVJdGVtLm5hbWUsIHsgYWN0aW9uOiBBQ1RJT05UWVBFLlBJQ0ssIGdhbWVJdGVtOiBnYW1lSXRlbSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBwbGF5ZXIgaW4gdGhlIHNjZW5lXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXRQbGF5ZXIoKTogdm9pZCB7XG4gICAgICAgIGxldCBwbGF5ZXIgPSB0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShQbGF5ZXJBY3RvciwgXCJwcmluY2VcIiwgdGhpcy5HYW1lTGF5ZXJzLkJBU0UpO1xuICAgICAgICB0aGlzLnBsYXllciA9IHBsYXllclxuICAgICAgICBwbGF5ZXIucG9zaXRpb24uc2V0KHRoaXMucGxheWVySW5pdFBvc2l0aW9uLngsIHRoaXMucGxheWVySW5pdFBvc2l0aW9uLnkpO1xuICAgICAgICBwbGF5ZXIuYmF0dGxlR3JvdXAgPSAyO1xuICAgICAgICBwbGF5ZXIuc2NhbGUgPSBuZXcgVmVjMigyLCAyKTtcbiAgICAgICAgLy8gR2l2ZSB0aGUgcGxheWVyIHBoeXNpY3NcbiAgICAgICAgdGhpcy5iYXR0bGVycy5wdXNoKHRoaXMucGxheWVyKTtcbiAgICAgICAgcGxheWVyLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig4LCA4KSksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgaGFsZlNpemUgPSB0aGlzLnBsYXllci5zaXplV2l0aFpvb20uc2NhbGUoMC4xMjUpO1xuICAgICAgICBwbGF5ZXIuc2V0Q29sbGlzaW9uU2hhcGUobmV3IEFBQkIodGhpcy5wbGF5ZXIucG9zaXRpb24sIGhhbGZTaXplKSlcbiAgICAgICAgcGxheWVyLmN1cnJlbnRUcmFuc3BhcmVudExhYmVscyA9IHRoaXMuaW5pdFRyYW5zcGFyZW50TGFiZWxCeVBvc2l0aW9uKHRoaXMucGxheWVyLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5idWlsZExhbnRlcm5TaGFwZSh0aGlzLnBsYXllci5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMudmlzaWJsZUdyb3VwLnB1c2gocGxheWVyKTtcblxuICAgICAgICAvLyBHaXZlIHRoZSBwbGF5ZXIgUGxheWVyQUlcblxuICAgICAgICBpZiAodGhpcy5vcHRpb24uaXNBc3RhckNoZWNrZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXV0byBQaWxvdFwiKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdEFzdGFyTW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGxheWVyLmFkZEFJKFBsYXllckFJKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFVsdGltYXRlV2F2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFxuICAgICAgICBwbGF5ZXIuYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIpO1xuXG5cblxuICAgIH1cbiAgICBwcm90ZWN0ZWQgaW5pdEFzdGFyTW9kZSgpIHtcbiAgICAgICAgbGV0IG5hdm1lc2ggPSB0aGlzLmluaXRpYWxpemVOYXZtZXNoKG5ldyBQb3NpdGlvbkdyYXBoKCksIHRoaXMud2FsbHMpO1xuICAgICAgICBuYXZtZXNoLnJlZ2lzdGVyU3RyYXRlZ3koXCJhc3RhclwiLCBuZXcgQXN0YXJTdHJhdGVneShuYXZtZXNoKSk7XG4gICAgICAgIHRoaXMubmF2TWFuYWdlci5hZGROYXZpZ2FibGVFbnRpdHkoXCJuYXZtZXNoXCIsIG5hdm1lc2gpO1xuICAgICAgICBuYXZtZXNoLnNldFN0cmF0ZWd5KFwiYXN0YXJcIik7XG4gICAgICAgIHRoaXMucGxheWVyLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplLnNjYWxlVG8oMC4yNSk7XG4gICAgICAgIHRoaXMucGF0aCA9IG5hdm1lc2guZ2V0TmF2aWdhdGlvblBhdGgodGhpcy5wbGF5ZXIucG9zaXRpb24sIHRoaXMubGV2ZWxFbmRQb3NpdGlvbik7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGF0aCk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXRDb250cm9sVGV4dExheWVyKCkge1xuICAgICAgICBsZXQgY29udHJvbFRleHRPcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoNDUwLCA0NTApLFxuICAgICAgICAgICAgbWFyZ2luOiA0MCxcbiAgICAgICAgICAgIGxheWVyTmFtZTogR2FtZUxheWVycy5DT05UUk9MX1RFWFRfTUVOVVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbFRleHRMYXllcihjb250cm9sVGV4dE9wdGlvbilcbiAgICB9XG4gICAgcHJvdGVjdGVkIGFkZENvbnRyb2xUZXh0TGF5ZXIob3B0aW9uOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IG9wdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgbGV0IHlJbml0UG9zaXRpb24gPSBwb3NpdGlvbi55IC0gNDAwO1xuICAgICAgICBmb3IgKGxldCB0ZXh0IG9mIGNvbnRyb2xUZXh0QXJyYXkpIHtcbiAgICAgICAgICAgIHlJbml0UG9zaXRpb24gKz0gb3B0aW9uLm1hcmdpblxuICAgICAgICAgICAgbGV0IHRleHRPcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKHBvc2l0aW9uLnggLSAxNTAsIHlJbml0UG9zaXRpb24pLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwi4oCiIFwiICsgdGV4dCxcbiAgICAgICAgICAgICAgICBhbGlnbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsYXllck5hbWU6IG9wdGlvbi5sYXllck5hbWUsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IG9wdGlvbi5mb250U2l6ZSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLlRSQU5TUEFSRU5ULFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRMYWJlbCh0ZXh0T3B0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgaW5pdEhlbHBUZXh0TGF5ZXIoKSB7XG4gICAgICAgIGxldCBoZWxwVGV4dE9wdGlvbiA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMig0NTAsIDQ1MCksXG4gICAgICAgICAgICBtYXJnaW46IDQwLFxuICAgICAgICAgICAgbGF5ZXJOYW1lOiBHYW1lTGF5ZXJzLkhFTFBfVEVYVF9NRU5VXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRIZWxwVGV4dExheWVyKGhlbHBUZXh0T3B0aW9uKVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgYWRkSGVscFRleHRMYXllcihvcHRpb246IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gb3B0aW9uLnBvc2l0aW9uO1xuICAgICAgICBsZXQgeUluaXRQb3NpdGlvbiA9IHBvc2l0aW9uLnkgLSA0MDA7XG4gICAgICAgIGNvbnN0IG5ld1RleHQgPSBoZWxwVGV4dEFycmF5O1xuICAgICAgICBmb3IgKGxldCB0ZXh0IG9mIG5ld1RleHQpIHtcbiAgICAgICAgICAgIHlJbml0UG9zaXRpb24gKz0gb3B0aW9uLm1hcmdpblxuICAgICAgICAgICAgbGV0IHRleHRPcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKHBvc2l0aW9uLnggLSAzMjAsIHlJbml0UG9zaXRpb24pLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgYWxpZ246IFwibGVmdFwiLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3IuVFJBTlNQQVJFTlQsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IG9wdGlvbi5mb250U2l6ZSxcbiAgICAgICAgICAgICAgICBsYXllck5hbWU6IG9wdGlvbi5sYXllck5hbWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZExhYmVsKHRleHRPcHRpb24pO1xuICAgICAgICAgICAgLy8gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsb3B0aW9uLmxheWVyTmFtZSx0ZXh0T3B0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0ZWQgc2NlbmVDaGFuZ2UobmV4dFNjZW5lKSB7XG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Wm9vbUxldmVsKDEpO1xuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKG5leHRTY2VuZSwgdGhpcy5vcHRpb24pO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCwgeyBrZXk6IHRoaXMubGV2ZWxNdXNpY0tleSwgbG9vcDogdHJ1ZSwgaG9sZFJlZmVyZW5jZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcHVibGljIGluaXRQYXVzZU1lbnVMYXllcigpIHtcbiAgICAgICAgY29uc3QgcGF1c2VTaWduID0gXCJcXHUyM0Y4XCI7XG4gICAgICAgIGxldCBwYXVzZVNpZ25idXR0b25PcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoNDc1LCAyMCksXG4gICAgICAgICAgICB0ZXh0OiBwYXVzZVNpZ24sXG4gICAgICAgICAgICBsYXllck5hbWU6IEdhbWVMYXllcnMuVUksXG4gICAgICAgICAgICBidXR0b25OYW1lOiBQYXVzZUJ1dHRvbkV2ZW50LlBBVVNFLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDb2xvci5UUkFOU1BBUkVOVCxcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEJ1dHRvbnMocGF1c2VTaWduYnV0dG9uT3B0aW9uKTtcblxuICAgICAgICAvLyBsZXQgZW1wdHlNZW51T3B0aW9uID0ge1xuICAgICAgICAvLyAgICAgcG9zaXRpb246IHRoaXMuY2VudGVyLFxuICAgICAgICAvLyAgICAgdGV4dDogXCJcIixcbiAgICAgICAgLy8gICAgIHNpemU6IG5ldyBWZWMyKDMwMCwgNTUwKSxcbiAgICAgICAgLy8gICAgIGxheWVyTmFtZTogR2FtZUxheWVycy5QQVVTRV9NRU5VX0NPTlRBSU5FUixcbiAgICAgICAgLy8gICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3IuV0hJVEUsXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gdGhpcy5hZGRMYWJlbChlbXB0eU1lbnVPcHRpb24pO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuYWRkLnNwcml0ZSh0aGlzLmluR2FtZUNvbnRyb2xUZXh0QmFja2dyb3VuZCwgR2FtZUxheWVycy5QQVVTRV9NRU5VX0NPTlRBSU5FUik7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlLnBvc2l0aW9uLnNldCh0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55ICsgMjApO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuYWRkLnNwcml0ZSh0aGlzLmluR2FtZUNvbnRyb2xUZXh0QmFja2dyb3VuZCwgR2FtZUxheWVycy5DT05UUk9MX1RFWFRfTUVOVV9DT05UQUlORVIpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZS5wb3NpdGlvbi5zZXQodGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSArIDIwKTtcbiAgICAgICAgbGV0IGNvbnRyb2xUZXh0T3B0aW9uID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKDQwMCwgNTE1KSxcbiAgICAgICAgICAgIG1hcmdpbjogMzAsXG4gICAgICAgICAgICBsYXllck5hbWU6IEdhbWVMYXllcnMuQ09OVFJPTF9URVhUX01FTlVcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENvbnRyb2xUZXh0TGF5ZXIoY29udHJvbFRleHRPcHRpb24pXG4gICAgICAgIGxldCBpbkdhbWVDb250cm9sVGV4dEJhY2tncm91bmRJbWFnZSA9IHRoaXMuYWRkLnNwcml0ZSh0aGlzLmluR2FtZUhlbHBUZXh0QmFja2dyb3VuZCwgR2FtZUxheWVycy5IRUxQX1RFWFRfTUVOVV9DT05UQUlORVIpO1xuICAgICAgICBpbkdhbWVDb250cm9sVGV4dEJhY2tncm91bmRJbWFnZS5wb3NpdGlvbi5zZXQodGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSArIDEwKTtcbiAgICAgICAgbGV0IGhlbHBUZXh0T3B0aW9uID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKDQzNSwgNDUwKSxcbiAgICAgICAgICAgIG1hcmdpbjogNDAsXG4gICAgICAgICAgICBsYXllck5hbWU6IEdhbWVMYXllcnMuSEVMUF9URVhUX01FTlVcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEhlbHBUZXh0TGF5ZXIoaGVscFRleHRPcHRpb24pXG4gICAgICAgIGxldCBwYXVzZVRleHRPcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIodGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSAtIDEwMCksXG4gICAgICAgICAgICB0ZXh0OiBcIlBhdXNlZFwiLFxuICAgICAgICAgICAgc2l6ZTogbmV3IFZlYzIoMTAwLCAzMCksXG4gICAgICAgICAgICBsYXllck5hbWU6IEdhbWVMYXllcnMuUEFVU0VfTUVOVSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IENvbG9yLkJMQUNLLFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTGFiZWwocGF1c2VUZXh0T3B0aW9uKTtcbiAgICAgICAgbGV0IHBvc2l0aW9uWSA9IHRoaXMuY2VudGVyLnkgLSA2MDtcbiAgICAgICAgZm9yIChsZXQgYnV0dG9uTmFtZSBpbiBNYWluTWVudUJ1dHRvbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PSBcIlNlbGVjdF9sZXZlbHNcIilcbiAgICAgICAgICAgICAgICBidXR0b25OYW1lID0gXCJTZWxlY3QgbGV2ZWxzXCJcbiAgICAgICAgICAgIGxldCBidXR0b25PcHRpb24xID0ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMih0aGlzLmNlbnRlci54LCBwb3NpdGlvblkpLFxuICAgICAgICAgICAgICAgIHRleHQ6IGJ1dHRvbk5hbWUsXG4gICAgICAgICAgICAgICAgbGF5ZXJOYW1lOiBHYW1lTGF5ZXJzLlBBVVNFX01FTlUsXG4gICAgICAgICAgICAgICAgYnV0dG9uTmFtZTogYnV0dG9uTmFtZSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLlBVUlBMRSxcbiAgICAgICAgICAgICAgICBzaXplOiBuZXcgVmVjMigzMDAsIDUwKSxcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IENvbG9yLldISVRFLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRCdXR0b25zKGJ1dHRvbk9wdGlvbjEpO1xuICAgICAgICAgICAgcG9zaXRpb25ZID0gcG9zaXRpb25ZICsgNDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVOYXZtZXNoKGdyYXBoOiBQb3NpdGlvbkdyYXBoLCB3YWxsczogT3J0aG9nb25hbFRpbGVtYXApOiBOYXZtZXNoIHtcblxuXG4gICAgICAgIGxldCBkaW06IFZlYzIgPSB3YWxscy5nZXREaW1lbnNpb25zKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltLnk7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW0ueDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGU6IEFBQkIgPSB3YWxscy5nZXRUaWxlQ29sbGlkZXIoaiwgaSk7XG4gICAgICAgICAgICAgICAgZ3JhcGguYWRkUG9zaXRpb25lZE5vZGUodGlsZS5jZW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJjOiBWZWMyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLm51bVZlcnRpY2VzOyBpKyspIHtcbiAgICAgICAgICAgIHJjID0gd2FsbHMuZ2V0VGlsZUNvbFJvdyhpKTtcbiAgICAgICAgICAgIGlmICghd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShyYy54LCByYy55KSAmJlxuICAgICAgICAgICAgICAgICF3YWxscy5pc1RpbGVDb2xsaWRhYmxlKE1hdGhVdGlscy5jbGFtcChyYy54IC0gMSwgMCwgZGltLnggLSAxKSwgcmMueSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIHJjLnkpICYmXG4gICAgICAgICAgICAgICAgIXdhbGxzLmlzVGlsZUNvbGxpZGFibGUocmMueCwgTWF0aFV0aWxzLmNsYW1wKHJjLnkgLSAxLCAwLCBkaW0ueSAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICF3YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIE1hdGhVdGlscy5jbGFtcChyYy55ICsgMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55ICsgMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCAtIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55ICsgMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCArIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55IC0gMSwgMCwgZGltLnkgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAhd2FsbHMuaXNUaWxlQ29sbGlkYWJsZShNYXRoVXRpbHMuY2xhbXAocmMueCAtIDEsIDAsIGRpbS54IC0gMSksIE1hdGhVdGlscy5jbGFtcChyYy55IC0gMSwgMCwgZGltLnkgLSAxKSlcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGVkZ2UgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgICAgICByYyA9IHdhbGxzLmdldFRpbGVDb2xSb3coaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmICgoaSArIDEpICUgZGltLnggIT09IDAgJiYgIXdhbGxzLmlzVGlsZUNvbGxpZGFibGUocmMueCwgcmMueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYWRkRWRnZShpLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYWRkLmdyYXBoaWMoR3JhcGhpY1R5cGUuTElORSwgXCJncmFwaFwiLCB7c3RhcnQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkpLCBlbmQ6IHRoaXMuZ3JhcGguZ2V0Tm9kZVBvc2l0aW9uKGkgKyAxKX0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBlZGdlIGJlbG93XG4gICAgICAgICAgICAgICAgcmMgPSB3YWxscy5nZXRUaWxlQ29sUm93KGkgKyBkaW0ueCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyBkaW0ueCA8IGdyYXBoLm51bVZlcnRpY2VzICYmICF3YWxscy5pc1RpbGVDb2xsaWRhYmxlKHJjLngsIHJjLnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLmFkZEVkZ2UoaSwgaSArIGRpbS54KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5hZGQuZ3JhcGhpYyhHcmFwaGljVHlwZS5MSU5FLCBcImdyYXBoXCIsIHtzdGFydDogdGhpcy5ncmFwaC5nZXROb2RlUG9zaXRpb24oaSksIGVuZDogdGhpcy5ncmFwaC5nZXROb2RlUG9zaXRpb24oaSArIGRpbS54KX0pXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGlzIGdyYXBoIGFzIGEgbmF2aWdhYmxlIGVudGl0eVxuICAgICAgICByZXR1cm4gbmV3IE5hdm1lc2goZ3JhcGgpO1xuXG4gICAgfVxuICAgIHB1YmxpYyBpbml0Rm9nT2ZXYXIoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMud2FsbFNpemUgLyB0aGlzLmxhYmVsU2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMiAqIGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA8PSAyICogbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IDAuNSAqIGkgKiB0aGlzLmxhYmVsU2l6ZTtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IDAuNSAqIGogKiB0aGlzLmxhYmVsU2l6ZTtcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKHgsIHkpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJsYWNrTGFiZWwob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVibGljIGFkZEJsYWNrTGFiZWwob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICBjb25zdCBsYWJlbCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgR2FtZUxheWVycy5GT0dfT0ZfV0FSLCBvcHRpb25zKTtcbiAgICAgICAgbGFiZWwuc2l6ZS5zZXQodGhpcy5sYWJlbFNpemUgKiAyLCB0aGlzLmxhYmVsU2l6ZSAqIDIpO1xuICAgICAgICBsYWJlbC5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICAgIGxhYmVsLmJvcmRlclJhZGl1cyA9IDA7XG4gICAgICAgIGxhYmVsLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIGxhYmVsLmJhY2tncm91bmRDb2xvciA9IENvbG9yLkZPR19PRl9XQVJfQkxBQ0s7XG4gICAgfVxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRCYXR0bGVycygpOiBCYXR0bGVyW107XG59XG4iLCIvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyBJTVBPUlRTICMjIyMjIyMjIyMjIyMjIyMjIyMjICovXG4vLyBJbXBvcnQgZnJvbSBXb2xmaWUyRCBvciB5b3VyIG93biBmaWxlcyBoZXJlXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgQmFja0J1dHRvbkV2ZW50IH0gZnJvbSBcIi4uL0N1c3RvbWl6ZWRCdXR0b25cIjtcbmltcG9ydCBTZWxlY3RMZXZlbE1lbnVTY2VuZSBmcm9tIFwiLi9TZWxlY3RMZXZlbE1lbnVTY2VuZVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XG5pbXBvcnQgTWFpbk1lbnUgZnJvbSBcIi4vTWFpbk1lbnVTY2VuZVwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgeyBjb250cm9sVGV4dEFycmF5IH0gZnJvbSBcIi4uL1RleHRcIjtcbmltcG9ydCBIVzRTY2VuZSBmcm9tIFwiLi9BYnN0cmFjdFNjZW5lXCI7XG5pbXBvcnQgQmF0dGxlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQmF0dGxlU3lzdGVtL0JhdHRsZXJcIjtcbi8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIENMQVNTIERFRklOSVRJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cblxuLy8gV2VsY29tZSB0byBXb2xmaWUyRCFcbi8vIFRoaXMgaXMgYSBzaW1wbGUgc2FtcGxlIHNjZW5lIHNvIHNvbWV0aGluZyBkaXNwbGF5cyB3aGVuIHlvdSBydW4gdGhlIGdhbWUuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVhdENvZGVNZW51U2NlbmUgZXh0ZW5kcyBIVzRTY2VuZSB7XG4gICAgLyogIyMjIyMjIyMjIyBNRU1CRVIgREVGSU5JVElPTlMgIyMjIyMjIyMjIyovXG4gICAgcHJvdGVjdGVkIEFzdGFyID0gXCJBdXRvLVBpbG90XCI7XG4gICAgcHJvdGVjdGVkIEZvZ09mV2FyID0gXCJSZW1vdmUgRm9nIG9mIFdhclwiO1xuICAgIHByb3RlY3RlZCBhc3RhckNoZWNrTGFiZWw6IExhYmVsO1xuICAgIHByb3RlY3RlZCBpc0FzdGFyQ2hlY2tlZDpib29sZWFuO1xuICAgIHByb3RlY3RlZCBmb2dPZldhckNoZWNrTGFiZWw6IExhYmVsO1xuICAgIHByb3RlY3RlZCBpc2ZvZ09mV2FyQ2hlY2tlZDogYm9vbGVhbjtcbiAgICBsb2FkU2NlbmUoKTogdm9pZCB7XG4gICAgICAgIC8vIHRoaXMubG9hZC50aWxlbWFwKFwibWFwXCIsIFwiLi4vZGlzdC9zaGFkb3dNYXplX2Fzc2V0cy90aWxlbWFwcy90ZXN0Mi5qc29uXCIpO1xuXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZSh0aGlzLmJhY2tncm91bmRJbWFnZUtleSwgXCJzaGFkb3dNYXplX2Fzc2V0cy9pbWFnZXMvbWF6ZUJhY2tncm91bmQuanBnXCIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmxvYWQuZ2V0SW1hZ2UoXCJpbWFnZVwiKSk7XG5cbiAgICB9XG5cbiAgICAvLyBzdGFydFNjZW5lKCkgaXMgd2hlcmUgeW91IHNob3VsZCBidWlsZCBhbnkgZ2FtZSBvYmplY3RzIHlvdSB3aXNoIHRvIGhhdmUgaW4geW91ciBzY2VuZSxcbiAgICAvLyBvciB3aGVyZSB5b3Ugc2hvdWxkIGluaXRpYWxpemUgYW55IG90aGVyIHRoaW5ncyB5b3Ugd2lsbCBuZWVkIGluIHlvdXIgc2NlbmVcbiAgICAvLyBPbmNlIGFnYWluLCB0aGlzIG9jY3VycyBzdHJpY3RseSBhZnRlciBsb2FkU2NlbmUoKSwgc28gYW55dGhpbmcgeW91IGxvYWRlZCB0aGVyZSB3aWxsIGJlIGF2YWlsYWJsZVxuICAgIHN0YXJ0U2NlbmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWRkVUlMYXllcih0aGlzLkdhbWVMYXllcnMuQkFTRSlcbiAgICAgICAgdGhpcy5pc0FzdGFyQ2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzZm9nT2ZXYXJDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlID0gdGhpcy5hZGQuc3ByaXRlKHRoaXMuYmFja2dyb3VuZEltYWdlS2V5LCB0aGlzLkdhbWVMYXllcnMuQkFTRSk7XG4gICAgICAgIGxldCBjZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuICAgICAgICB0aGlzLmFkZEJhY2tCdXRvbih0aGlzLmJhY2tCdXR0b25Qb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlLnBvc2l0aW9uLnNldChjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgICBsZXQgdGV4dE9wdGlvbiA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSA0NTApLFxuICAgICAgICAgICAgdGV4dDogXCJDaGVhdCBNb2RlXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLlRSQU5TUEFSRU5ULFxuICAgICAgICAgICAgZm9udFNpemU6IDUwLFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTGFiZWwodGV4dE9wdGlvbik7XG4gICAgICAgIHRoaXMuYXN0YXJDaGVja0xhYmVsID0gdGhpcy5hZGRNb2RlQnV0dG9uKGNlbnRlciwgdGhpcy5Bc3Rhcik7XG4gICAgICAgIGNlbnRlciA9IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDIwMCk7XG4gICAgICAgIHRoaXMuZm9nT2ZXYXJDaGVja0xhYmVsID0gdGhpcy5hZGRNb2RlQnV0dG9uKGNlbnRlciwgdGhpcy5Gb2dPZldhcik7XG4gICAgICBcbiAgICB9XG4gICAgcHVibGljIGFkZE1vZGVCdXR0b24ocG9zaXRpb246IFZlYzIsIGJ1dHRvbk5hbWU6IHN0cmluZykge1xuICAgICAgICBsZXQgYVN0YXJUZXh0T3B0aW9uID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkgLSAyNTApLFxuICAgICAgICAgICAgdGV4dDogYnV0dG9uTmFtZSxcbiAgICAgICAgICAgIHNpemU6IG5ldyBWZWMyKDMwMCwgNTApLFxuICAgICAgICAgICAgLy8gYnV0dG9uTmFtZTpcIkFzdGFyXCIsXG4gICAgICAgICAgICBmb250U2l6ZTogNTAsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IENvbG9yLlBVUlBMRSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3IuVFJBTlNQQVJFTlQsXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRMYWJlbChhU3RhclRleHRPcHRpb24pO1xuICAgICAgICBsZXQgYVN0YXJDaG9pY2VPcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIocG9zaXRpb24ueCwgcG9zaXRpb24ueSAtIDE1MCksXG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgc2l6ZTogbmV3IFZlYzIoNTAsIDUwKSxcbiAgICAgICAgICAgIGJ1dHRvbk5hbWU6IGJ1dHRvbk5hbWUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLldISVRFLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEwLFxuICAgICAgICAgICAgZm9udFNpemU6IDMwLFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkQnV0dG9ucyhhU3RhckNob2ljZU9wdGlvbik7XG4gICAgICAgIGxldCBhU3RhckNoZWNrT3B0aW9uID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkgLSAxNTApLFxuICAgICAgICAgICAgdGV4dDogXCJcXHUyNzEzXCIsXG4gICAgICAgICAgICBzaXplOiBuZXcgVmVjMig1MCwgNTApLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDb2xvci5XSElURSxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxMCxcbiAgICAgICAgICAgIGZvbnRTaXplOiA1MCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogQ29sb3IuVFJBTlNQQVJFTlQsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGFiZWwoYVN0YXJDaGVja09wdGlvbik7XG4gICAgfVxuICAgIHB1YmxpYyB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcikge1xuICAgICAgICB3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgc2hvd0NoZWNrTGFiZWwobGFiZWw6IExhYmVsLCBmbGFnOiBib29sZWFuKSB7XG4gICAgICAgIGlmICghZmxhZykge1xuICAgICAgICAgICAgbGFiZWwuc2V0VGV4dENvbG9yKENvbG9yLkJMQUNLKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsLnNldFRleHRDb2xvcihDb2xvci5UUkFOU1BBUkVOVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFmbGFnO1xuICAgIH1cbiAgIFxuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50LnR5cGUgPT09IHRoaXMuQXN0YXIpXG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnR5cGUpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGV2ZW50LnR5cGUgPT09IHRoaXMuRm9nT2ZXYXIpXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBCYWNrQnV0dG9uRXZlbnQuQkFDSzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbj17XG4gICAgICAgICAgICAgICAgICAgIGlzQXN0YXJDaGVja2VkOnRoaXMuaXNBc3RhckNoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIGlzZm9nT2ZXYXJDaGVja2VkOnRoaXMuaXNmb2dPZldhckNoZWNrZWQsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoU2VsZWN0TGV2ZWxNZW51U2NlbmUsb3B0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgdGhpcy5Bc3Rhcjoge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuaXNBc3RhckNoZWNrZWQ9ICF0aGlzLmlzQXN0YXJDaGVja2VkXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5zaG93Q2hlY2tMYWJlbCh0aGlzLmFzdGFyQ2hlY2tMYWJlbCwgdGhpcy5pc0FzdGFyQ2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0FzdGFyQ2hlY2tlZCA9IHRoaXMuc2hvd0NoZWNrTGFiZWwodGhpcy5hc3RhckNoZWNrTGFiZWwsdGhpcy5pc0FzdGFyQ2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHRoaXMuRm9nT2ZXYXI6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzZm9nT2ZXYXJDaGVja2VkID10aGlzLnNob3dDaGVja0xhYmVsKHRoaXMuZm9nT2ZXYXJDaGVja0xhYmVsLCB0aGlzLmlzZm9nT2ZXYXJDaGVja2VkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRCYXR0bGVycygpOiBCYXR0bGVyW10geyByZXR1cm4gdGhpcy5iYXR0bGVyczsgfVxuXG4gICAgXG59IiwiLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMgSU1QT1JUUyAjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xuLy8gSW1wb3J0IGZyb20gV29sZmllMkQgb3IgeW91ciBvd24gZmlsZXMgaGVyZVxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IEJhY2tCdXR0b25FdmVudCB9IGZyb20gXCIuLi9DdXN0b21pemVkQnV0dG9uXCI7XG5pbXBvcnQgU2VsZWN0TGV2ZWxNZW51U2NlbmUgZnJvbSBcIi4vU2VsZWN0TGV2ZWxNZW51U2NlbmVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xuaW1wb3J0IE1haW5NZW51IGZyb20gXCIuL01haW5NZW51U2NlbmVcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IHsgY29udHJvbFRleHRBcnJheSB9IGZyb20gXCIuLi9UZXh0XCI7XG5pbXBvcnQgSFc0U2NlbmUgZnJvbSBcIi4vQWJzdHJhY3RTY2VuZVwiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXR0bGVyXCI7XG4vKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyBDTEFTUyBERUZJTklUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjICovXG5cbi8vIFdlbGNvbWUgdG8gV29sZmllMkQhXG4vLyBUaGlzIGlzIGEgc2ltcGxlIHNhbXBsZSBzY2VuZSBzbyBzb21ldGhpbmcgZGlzcGxheXMgd2hlbiB5b3UgcnVuIHRoZSBnYW1lLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udHJvbFNjZW5lIGV4dGVuZHMgSFc0U2NlbmUge1xuICAgIC8qICMjIyMjIyMjIyMgTUVNQkVSIERFRklOSVRJT05TICMjIyMjIyMjIyMqL1xuICAgIGxvYWRTY2VuZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gdGhpcy5sb2FkLnRpbGVtYXAoXCJtYXBcIiwgXCIuLi9kaXN0L3NoYWRvd01hemVfYXNzZXRzL3RpbGVtYXBzL3Rlc3QyLmpzb25cIik7XG5cbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKHRoaXMuYmFja2dyb3VuZEltYWdlS2V5LCBcInNoYWRvd01hemVfYXNzZXRzL2ltYWdlcy9tYXplQmFja2dyb3VuZC5qcGdcIik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubG9hZC5nZXRJbWFnZShcImltYWdlXCIpKTtcbiAgICAgICBcbiAgICB9XG5cbiAgICAvLyBzdGFydFNjZW5lKCkgaXMgd2hlcmUgeW91IHNob3VsZCBidWlsZCBhbnkgZ2FtZSBvYmplY3RzIHlvdSB3aXNoIHRvIGhhdmUgaW4geW91ciBzY2VuZSxcbiAgICAvLyBvciB3aGVyZSB5b3Ugc2hvdWxkIGluaXRpYWxpemUgYW55IG90aGVyIHRoaW5ncyB5b3Ugd2lsbCBuZWVkIGluIHlvdXIgc2NlbmVcbiAgICAvLyBPbmNlIGFnYWluLCB0aGlzIG9jY3VycyBzdHJpY3RseSBhZnRlciBsb2FkU2NlbmUoKSwgc28gYW55dGhpbmcgeW91IGxvYWRlZCB0aGVyZSB3aWxsIGJlIGF2YWlsYWJsZVxuICAgIHN0YXJ0U2NlbmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWRkVUlMYXllciggIHRoaXMuR2FtZUxheWVycy5CQVNFKVxuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuYWRkLnNwcml0ZSh0aGlzLmJhY2tncm91bmRJbWFnZUtleSwgICB0aGlzLkdhbWVMYXllcnMuQkFTRSk7XG4gICAgICAgIGxldCBjZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZS5wb3NpdGlvbi5zZXQoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgICAgbGV0IHRleHRPcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gNDUwKSxcbiAgICAgICAgICAgIHRleHQ6IFwiQ29udHJvbHNcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjpDb2xvci5UUkFOU1BBUkVOVCxcbiAgICAgICAgICAgIGZvbnRTaXplOjUwLFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTGFiZWwodGV4dE9wdGlvbik7XG4gICAgICAgIGxldCBjb250cm9sVGV4dE9wdGlvbiA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBjZW50ZXIsXG4gICAgICAgICAgICB0ZXh0OiBjb250cm9sVGV4dEFycmF5LFxuICAgICAgICAgICAgbWFyZ2luOjcwLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOkNvbG9yLlRSQU5TUEFSRU5ULFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbFRleHRMYXllcihjb250cm9sVGV4dE9wdGlvbik7XG4gICAgICAgIHRoaXMuYWRkQmFja0J1dG9uKHRoaXMuYmFja0J1dHRvblBvc2l0aW9uKTtcbiAgICB9XG4gICAgICBwdWJsaWMgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQodGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gIFxuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN1cGVyLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQudHlwZSk7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBCYWNrQnV0dG9uRXZlbnQuQkFDSzoge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTWFpbk1lbnUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0QmF0dGxlcnMoKTogQmF0dGxlcltdIHsgcmV0dXJuIHRoaXMuYmF0dGxlcnM7IH1cblxufSIsIi8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIElNUE9SVFMgIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cbi8vIEltcG9ydCBmcm9tIFdvbGZpZTJEIG9yIHlvdXIgb3duIGZpbGVzIGhlcmVcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgQmFja0J1dHRvbkV2ZW50IH0gZnJvbSBcIi4uL0N1c3RvbWl6ZWRCdXR0b25cIjtcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9NYWluTWVudVNjZW5lXCI7XG5pbXBvcnQgSFc0U2NlbmUgZnJvbSBcIi4vQWJzdHJhY3RTY2VuZVwiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXR0bGVyXCI7XG4vKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyBDTEFTUyBERUZJTklUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjICovXG5cbi8vIFdlbGNvbWUgdG8gV29sZmllMkQhXG4vLyBUaGlzIGlzIGEgc2ltcGxlIHNhbXBsZSBzY2VuZSBzbyBzb21ldGhpbmcgZGlzcGxheXMgd2hlbiB5b3UgcnVuIHRoZSBnYW1lLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscFNjZW5lIGV4dGVuZHMgSFc0U2NlbmUge1xuICAgIC8qICMjIyMjIyMjIyMgTUVNQkVSIERFRklOSVRJT05TICMjIyMjIyMjIyMqL1xuICAgIC8vIHByaXZhdGUgbWFpbk1lbnVMYXllck5hbWU6IHN0cmluZyA9IFwic3RhcnRTY2VuZVwiO1xuICAgIGxvYWRTY2VuZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gdGhpcy5sb2FkLnRpbGVtYXAoXCJtYXBcIiwgXCIuLi9kaXN0L3NoYWRvd01hemVfYXNzZXRzL3RpbGVtYXBzL3Rlc3QyLmpzb25cIik7XG4gICAgICAgIHRoaXMubG9hZC5pbWFnZSh0aGlzLmJhY2tncm91bmRJbWFnZUtleSwgXCJzaGFkb3dNYXplX2Fzc2V0cy9pbWFnZXMvbWF6ZUJhY2tncm91bmQuanBnXCIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmxvYWQuZ2V0SW1hZ2UoXCJpbWFnZVwiKSk7XG4gICAgfVxuXG4gICAgLy8gc3RhcnRTY2VuZSgpIGlzIHdoZXJlIHlvdSBzaG91bGQgYnVpbGQgYW55IGdhbWUgb2JqZWN0cyB5b3Ugd2lzaCB0byBoYXZlIGluIHlvdXIgc2NlbmUsXG4gICAgLy8gb3Igd2hlcmUgeW91IHNob3VsZCBpbml0aWFsaXplIGFueSBvdGhlciB0aGluZ3MgeW91IHdpbGwgbmVlZCBpbiB5b3VyIHNjZW5lXG4gICAgLy8gT25jZSBhZ2FpbiwgdGhpcyBvY2N1cnMgc3RyaWN0bHkgYWZ0ZXIgbG9hZFNjZW5lKCksIHNvIGFueXRoaW5nIHlvdSBsb2FkZWQgdGhlcmUgd2lsbCBiZSBhdmFpbGFibGVcbiAgICBzdGFydFNjZW5lKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFkZFVJTGF5ZXIoIHRoaXMuR2FtZUxheWVycy5CQVNFKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSB0aGlzLmFkZC5zcHJpdGUodGhpcy5iYWNrZ3JvdW5kSW1hZ2VLZXksICB0aGlzLkdhbWVMYXllcnMuQkFTRSk7XG4gICAgICAgIGxldCBjZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZS5wb3NpdGlvbi5zZXQoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgICAgbGV0IHRleHRPcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gNDUwKSxcbiAgICAgICAgICAgIHRleHQ6IFwiSGVscFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDb2xvci5UUkFOU1BBUkVOVCxcbiAgICAgICAgICAgIGZvbnRTaXplOiA1MCxcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGVscFRleHRPcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogY2VudGVyLFxuICAgICAgICAgICAgbWFyZ2luOiA1MCxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ29sb3IuVFJBTlNQQVJFTlQsXG4gICAgICAgICAgICBmb250U2l6ZTogMzEsXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRMYWJlbCh0ZXh0T3B0aW9uKTtcbiAgICAgICAgdGhpcy5hZGRIZWxwVGV4dExheWVyKGhlbHBUZXh0T3B0aW9uKTtcbiAgICAgICAgdGhpcy5hZGRCYWNrQnV0b24odGhpcy5iYWNrQnV0dG9uUG9zaXRpb24pO1xuICAgIH1cbiAgICBwdWJsaWMgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGdhbWVFdmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KClcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgIFxuICAgICAgIFxuICAgIH1cbiAgXG4gICAgcHVibGljIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudC50eXBlKTtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJhY2tCdXR0b25FdmVudC5CQUNLOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShNYWluTWVudSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRCYXR0bGVycygpOiBCYXR0bGVyW10geyByZXR1cm4gdGhpcy5iYXR0bGVyczsgfVxuXG59IiwiXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgU2VsZWN0TGV2ZWxNZW51U2NlbmUgZnJvbSBcIi4vU2VsZWN0TGV2ZWxNZW51U2NlbmVcIjtcbmltcG9ydCBTdGFydFNjZW5lIGZyb20gXCIuL1N0YXJ0U2NlbmVcIjtcbmltcG9ydCBQcm9qZWN0U2NlbmUgZnJvbSBcIi4vQWJzdHJhY3RTY2VuZVwiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXR0bGVyXCI7XG5cbmltcG9ydCB7IE1haW5NZW51QnV0dG9uRXZlbnQsIFBhdXNlQnV0dG9uRXZlbnQgfSBmcm9tIFwiLi4vQ3VzdG9taXplZEJ1dHRvblwiO1xuXG5pbXBvcnQgeyBQbGF5ZXJFdmVudHMgfSBmcm9tIFwiLi4vUHJvamVjdEV2ZW50c1wiO1xuaW1wb3J0IENoZWF0Q29kZU1lbnVTY2VuZSBmcm9tIFwiLi9DaGVhdENvZGVNZW51U2NlbmVcIjtcbmltcG9ydCB7IE1lbnVTdGF0ZSB9IGZyb20gXCIuLi9NZW51U3RhdGVcIjtcbmNvbnN0IEFDVElPTlRZUEUgPSB7XG4gICAgUElDSzogXCJQSUNLXCIsXG4gICAgVVNFOiBcIlVTRVwiLFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRyb0xldmVsU2NlbmUgZXh0ZW5kcyBQcm9qZWN0U2NlbmUge1xuXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBMRVZFTF9NVVNJQ19LRVkgPSBcIkxFVkVMX01VU0lDXCI7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBMRVZFTF9NVVNJQ19QQVRIID0gXCJzaGFkb3dNYXplX2Fzc2V0cy9tdXNpYy9sZXZlbF9iZ20ubXAzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIFNjZW5lLnVwZGF0ZSgpXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGxvYWRTY2VuZSgpIHtcbiAgICAgICAgdGhpcy5sZXZlbE11c2ljS2V5ID0gSW50cm9MZXZlbFNjZW5lLkxFVkVMX01VU0lDX0tFWVxuXG4gICAgICAgIC8vIHRoaXMubG9hZC5hdWRpbyh0aGlzLmxldmVsTXVzaWNLZXksIEludHJvTGV2ZWxTY2VuZS5MRVZFTF9NVVNJQ19QQVRIKTtcblxuICAgICAgICB0aGlzLmxvYWRBbGxHYW1lSXRlbXMoKTtcbiAgICAgICAgdGhpcy5sb2FkVWx0aW1hdGVXYXZlKCk7XG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcInByaW5jZVwiLCBcInNoYWRvd01hemVfYXNzZXRzL3Nwcml0ZXNoZWV0cy9wcmluY2UuanNvblwiKTtcblxuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJibGFja19wdWRkaW5nXCIsIFwic2hhZG93TWF6ZV9hc3NldHMvc3ByaXRlc2hlZXRzL2JsYWNrX3B1ZGRpbmcuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwidHJvbGxcIiwgXCJzaGFkb3dNYXplX2Fzc2V0cy9zcHJpdGVzaGVldHMvdHJvbGwuanNvblwiKTtcblxuICAgICAgICB0aGlzLmxvYWQub2JqZWN0KFwibW9uc3RlclwiLCBcInNoYWRvd01hemVfYXNzZXRzL2RhdGEvZW5lbWllcy9tb25zdGVyLmpzb25cIilcblxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UodGhpcy5pbkdhbWVDb250cm9sVGV4dEJhY2tncm91bmQsIFwic2hhZG93TWF6ZV9hc3NldHMvaW1hZ2VzL2luR2FtZUNvbnRyb2xUZXh0QmFja2dyb3VuZC5wbmdcIik7XG4gICAgICAgIHRoaXMubG9hZC5pbWFnZSh0aGlzLmluR2FtZUhlbHBUZXh0QmFja2dyb3VuZCwgXCJzaGFkb3dNYXplX2Fzc2V0cy9pbWFnZXMvaW5HYW1lSGVscFRleHRCYWNrZ3JvdW5kLnBuZ1wiKTtcblxuICAgICAgICAvLyBMb2FkIHRoZSB0aWxlbWFwXG4gICAgICAgIC8vIHRoaXMubG9hZC50aWxlbWFwKFwibGV2ZWxcIiwgXCJzaGFkb3dNYXplX2Fzc2V0cy90aWxlbWFwcy9mdXR1cmVMZXZlbC5qc29uXCIpO1xuICAgICAgICB0aGlzLmxvYWQudGlsZW1hcChcImxldmVsXCIsIFwic2hhZG93TWF6ZV9hc3NldHMvdGlsZW1hcHMvTElfVEVTVF9NQVAuanNvblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBTY2VuZS5zdGFydFNjZW5lXG4gICAgICovXG4gICBcblxuICAgXG5cblxuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN1cGVyLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgdGhpcy5oYW5kbGVJbkdhbWVCdXR0b25FdmVudChldmVudCk7XG4gICAgICAgIC8vIGFjdGlvbiB0eXBlOiAgXG4gICAgfVxuICAgIHByb3RlY3RlZCBoYW5kbGVJbkdhbWVCdXR0b25FdmVudChldmVudDpHYW1lRXZlbnQpe1xuICAgICAgICBsZXQgbmV4dFNjZW5lO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhldmVudClcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1haW5NZW51QnV0dG9uRXZlbnQuUmVzdGFydDoge1xuICAgICAgICAgICAgICAgIG5leHRTY2VuZSA9IEludHJvTGV2ZWxTY2VuZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQYXVzZUJ1dHRvbkV2ZW50LlBBVVNFOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNZW51U3RhdGVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lbnVTaG93bigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNYWluTWVudUJ1dHRvbkV2ZW50LlNlbGVjdF9sZXZlbHM6IHtcbiAgICAgICAgICAgICAgICBuZXh0U2NlbmUgPSBTZWxlY3RMZXZlbE1lbnVTY2VuZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNYWluTWVudUJ1dHRvbkV2ZW50LkNvbnRyb2xzOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5NZW51Q3VyZW50U3RhdGUgPSBNZW51U3RhdGUuQ09OVFJPTF9URVhUX01FTlVfU0hPV05cbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lbnVTaG93bigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWFpbk1lbnVCdXR0b25FdmVudC5IZWxwOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5NZW51Q3VyZW50U3RhdGUgPSBNZW51U3RhdGUuSEVMUF9URVhUX01FTlVfU0hPV05cbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lbnVTaG93bigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNYWluTWVudUJ1dHRvbkV2ZW50LkNIRUFUOntcbiAgICAgICAgICAgICAgICBuZXh0U2NlbmUgPSBDaGVhdENvZGVNZW51U2NlbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWFpbk1lbnVCdXR0b25FdmVudC5FeGl0OiB7XG4gICAgICAgICAgICAgICAgbmV4dFNjZW5lID0gU3RhcnRTY2VuZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQbGF5ZXJFdmVudHMuUExBWUVSX0VOVEVSRURfTEVWRUxfRU5EOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFbnRlcmVkTGV2ZWxFbmQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgY2FzZSBQbGF5ZXJFdmVudHMuTEVWRUxfRU5EOiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTY2VuZSA9IFNlbGVjdExldmVsTWVudVNjZW5lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVDaGFuZ2UobmV4dFNjZW5lKVxuICAgICAgICAgICAgICAgIH0sIDIwMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKG5leHRTY2VuZSl7XG4gICAgICAgICAgICB0aGlzLnNjZW5lQ2hhbmdlKG5leHRTY2VuZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRCYXR0bGVycygpOiBCYXR0bGVyW10geyByZXR1cm4gdGhpcy5iYXR0bGVyczsgfVxuICAgIC8qKiBJbml0aWFsaXplcyB0aGUgbGF5ZXJzIGluIHRoZSBzY2VuZSAqL1xuXG5cblxufVxuIiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuLy8gaW1wb3J0IE1haW5IVzRTY2VuZSBmcm9tIFwiLi9NYWluSFc0U2NlbmVcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbi8vIGltcG9ydCBHdWFyZERlbW9TY2VuZSBmcm9tIFwiLi9HdWFyZERlbW9TY2VuZVwiO1xuaW1wb3J0IHsgTWFpbk1lbnVCdXR0b25FdmVudCB9IGZyb20gXCIuLi9DdXN0b21pemVkQnV0dG9uXCI7XG5pbXBvcnQgU2VsZWN0TGV2ZWxNZW51U2NlbmUgZnJvbSBcIi4vU2VsZWN0TGV2ZWxNZW51U2NlbmVcIjtcbmltcG9ydCBIZWxwU2NlbmUgZnJvbSBcIi4vSGVscFNjZW5lXCI7XG5pbXBvcnQgU3RhcnRTY2VuZSBmcm9tIFwiLi9TdGFydFNjZW5lXCI7XG5pbXBvcnQgQ29udHJvbFNjZW5lIGZyb20gXCIuL0NvbnRyb2xTY2VuZVwiO1xuaW1wb3J0IENoZWF0Q29kZU1lbnVTY2VuZSBmcm9tIFwiLi9DaGVhdENvZGVNZW51U2NlbmVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgeyBHYW1lTGF5ZXJzIH0gZnJvbSBcIi4uL0dhbWVMYXllcnNcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5NZW51IGV4dGVuZHMgU2NlbmUge1xuICAgIHByaXZhdGUgbWFpbk1lbnVMYXllck5hbWU6XCJtYWluTWVudVwiO1xuICAgIC8vIExheWVycywgZm9yIG11bHRpcGxlIG1haW4gbWVudSBzY3JlZW5zXG4gICAgcHJpdmF0ZSBtYWluTWVudTogTGF5ZXI7XG4gICAgcHJpdmF0ZSBhYm91dDogTGF5ZXI7XG4gICAgcHJpdmF0ZSBjb250cm9sOiBMYXllcjtcbiAgICBwcml2YXRlIGJhY2tncm91bmRJbWFnZTogU3ByaXRlO1xuICAgIFxuICAgIHByaXZhdGUgYmFja2dyb3VuZEltYWdlS2V5OlwiYmFja2dyb3VuZEltYWdlXCI7XG4gICAgcHJpdmF0ZSBvcHRpb246UmVjb3JkPHN0cmluZywgYW55PjtcbiAgICBwdWJsaWMgaW5pdFNjZW5lKG9wdGlvbjogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvblxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLm9wdGlvbilcbiAgICB9XG4gICAgcHVibGljIGxvYWRTY2VuZSgpe1xuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UodGhpcy5iYWNrZ3JvdW5kSW1hZ2VLZXksXCJzaGFkb3dNYXplX2Fzc2V0cy9pbWFnZXMvZnVsbEJhY2tncm91bmQuanBnXCIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGFydFNjZW5lKCl7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuICAgICAgICB0aGlzLm1haW5NZW51ID0gdGhpcy5hZGRVSUxheWVyKCAgR2FtZUxheWVycy5CQVNFKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSB0aGlzLmFkZC5zcHJpdGUodGhpcy5iYWNrZ3JvdW5kSW1hZ2VLZXksICBHYW1lTGF5ZXJzLkJBU0UpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZS5wb3NpdGlvbi5zZXQoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgICAgLy8gVGhlIG1haW4gbWVudVxuICAgICAgICBsZXQgcG9zaXRpb25ZPWNlbnRlci55IC0gNDAwO1xuICAgICAgIFxuICAgICAgICBmb3IobGV0IGJ1dHRvbk5hbWUgaW4gTWFpbk1lbnVCdXR0b25FdmVudCl7XG4gICAgICAgICAgICBpZihidXR0b25OYW1lID09IFwiUmVzdGFydFwiKSBjb250aW51ZTtcbiAgICAgICAgICAgIHBvc2l0aW9uWSA9IHBvc2l0aW9uWSArIDEwMDtcbiAgICAgICAgICAgIGlmKGJ1dHRvbk5hbWUgPT0gXCJTZWxlY3RfbGV2ZWxzXCIpIFxuICAgICAgICAgICAgICAgIGJ1dHRvbk5hbWUgPSBcIlNlbGVjdCBsZXZlbHNcIiAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zPXtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjpuZXcgVmVjMihjZW50ZXIueCxwb3NpdGlvblkpLFxuICAgICAgICAgICAgICAgIHRleHQ6YnV0dG9uTmFtZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQnV0dG9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgYWRkQnV0dG9ucyhvcHRpb25zOlJlY29yZDxzdHJpbmcsIGFueT4pe1xuICAgICAgIFxuICAgICAgICBjb25zdCBuZXdCdXR0b24gPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCAgR2FtZUxheWVycy5CQVNFLCBvcHRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIG5ld0J1dHRvbi5zaXplLnNldCgzMDAsIDUwKTtcbiAgICAgICAgbmV3QnV0dG9uLmJvcmRlcldpZHRoID0gMjtcbiAgICAgICAgbmV3QnV0dG9uLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIG5ld0J1dHRvbi5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5CTEFDSztcbiAgICAgICAgbmV3QnV0dG9uLnNldFRleHRDb2xvcihDb2xvci5QVVJQTEUpO1xuICAgICAgICBuZXdCdXR0b24ub25DbGlja0V2ZW50SWQgPSBvcHRpb25zLnRleHQ7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKG9wdGlvbnMudGV4dCk7XG4gICAgfVxuICAgIHB1YmxpYyB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcil7XG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnR5cGUpXG4gICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1haW5NZW51QnV0dG9uRXZlbnQuU2VsZWN0X2xldmVsczoge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoU2VsZWN0TGV2ZWxNZW51U2NlbmUsdGhpcy5vcHRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNYWluTWVudUJ1dHRvbkV2ZW50LkNvbnRyb2xzOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShDb250cm9sU2NlbmUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNYWluTWVudUJ1dHRvbkV2ZW50LkhlbHA6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKEhlbHBTY2VuZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1haW5NZW51QnV0dG9uRXZlbnQuRXhpdDp7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShTdGFydFNjZW5lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWFpbk1lbnVCdXR0b25FdmVudC5DSEVBVDp7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZSggQ2hlYXRDb2RlTWVudVNjZW5lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgQmFja0J1dHRvbkV2ZW50LCBTZWxlY3RNZW51QnV0dG9uRXZlbnQgfSBmcm9tIFwiLi4vQ3VzdG9taXplZEJ1dHRvblwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBJbnRyb0xldmVsU2NlbmUgZnJvbSBcIi4vSW50cm9MZXZlbFNjZW5lXCI7XG5pbXBvcnQgeyBHYW1lTGF5ZXJzIH0gZnJvbSBcIi4uL0dhbWVMYXllcnNcIjtcbmltcG9ydCBBYnN0cmFjdFNjZW5lIGZyb20gXCIuL0Fic3RyYWN0U2NlbmVcIjtcbmltcG9ydCBDaGVhdENvZGVNZW51U2NlbmUgZnJvbSBcIi4vQ2hlYXRDb2RlTWVudVNjZW5lXCI7XG5pbXBvcnQgTWFpbk1lbnVTY2VuZSBmcm9tIFwiLi9NYWluTWVudVNjZW5lXCI7XG5pbXBvcnQgQmF0dGxlciBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQmF0dGxlU3lzdGVtL0JhdHRsZXJcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5NZW51IGV4dGVuZHMgQWJzdHJhY3RTY2VuZSAge1xuICAgIHByaXZhdGUgbWFpbk1lbnVMYXllck5hbWUgPSBcIm1haW5NZW51XCI7XG4gICAgLy8gcHJpdmF0ZSBiYWNrZ3JvdW5kSW1hZ2VLZXkgPSBcImJhY2tncm91bmRJbWFnZVwiO1xuICAgIHByaXZhdGUgbWFpbk1lbnU6IExheWVyO1xuICAgIC8vIHByaXZhdGUgYmFja2dyb3VuZEltYWdlOiBTcHJpdGU7XG4gICAgLy8gcHJpdmF0ZSBHYW1lTGF5ZXJzID0gR2FtZUxheWVycztcbiAgICBwdWJsaWMgaW5pdFNjZW5lKG9wdGlvbjogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvblxuICAgIH1cbiAgICBwdWJsaWMgbG9hZFNjZW5lKCkge1xuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UodGhpcy5iYWNrZ3JvdW5kSW1hZ2VLZXksIFwic2hhZG93TWF6ZV9hc3NldHMvaW1hZ2VzL21hemVCYWNrZ3JvdW5kLmpwZ1wiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhcnRTY2VuZSgpIHtcbiAgICAgICAgdGhpcy5hZGRVSUxheWVyKHRoaXMuR2FtZUxheWVycy5CQVNFKTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSB0aGlzLmFkZC5zcHJpdGUodGhpcy5iYWNrZ3JvdW5kSW1hZ2VLZXksIHRoaXMuR2FtZUxheWVycy5CQVNFKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UucG9zaXRpb24uc2V0KGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICAgIC8vIFRoZSBtYWluIG1lbnVcbiAgICAgICAgbGV0IHBvc2l0aW9uWT1jZW50ZXIueSAtIDEwMDtcbiAgICAgICAgbGV0IGkgPSAwIDtcbiAgICAgICAgZm9yKGxldCBidXR0b25OYW1lIGluIFNlbGVjdE1lbnVCdXR0b25FdmVudCl7XG4gICAgICAgICAgICBidXR0b25OYW1lID0gU2VsZWN0TWVudUJ1dHRvbkV2ZW50W2J1dHRvbk5hbWVdXG4gICAgICAgICAgICBpZihpICA9PT0gMCApe1xuICAgICAgICAgICAgICAgIGxldCBidXR0b25PcHRpb249e1xuICAgICAgICAgICAgICAgICAgICBidXR0b25OYW1lOmJ1dHRvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOm5ldyBWZWMyKGNlbnRlci54LHBvc2l0aW9uWSksXG4gICAgICAgICAgICAgICAgICAgIHNpemU6bmV3IFZlYzIoMzAwLCA1MCksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6YnV0dG9uTmFtZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCdXR0b25zKGJ1dHRvbk9wdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRCYWNrQnV0b24odGhpcy5iYWNrQnV0dG9uUG9zaXRpb24pO1xuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcikge1xuICAgICAgICB3aGlsZSAodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnR5cGUpXG4gICAgICAgIFxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQmFja0J1dHRvbkV2ZW50LkJBQ0s6e1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTWFpbk1lbnVTY2VuZSx0aGlzLm9wdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNlbGVjdE1lbnVCdXR0b25FdmVudC5MRVZFTF8xOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShJbnRyb0xldmVsU2NlbmUsdGhpcy5vcHRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTZWxlY3RNZW51QnV0dG9uRXZlbnQuTEVWRUxfMjoge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoQXN0YXJEZW1vU2NlbmUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTZWxlY3RNZW51QnV0dG9uRXZlbnQuTEVWRUxfNjoge1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYXNlIFNlbGVjdE1lbnVCdXR0b25FdmVudC5DSEVBVDp7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKCBDaGVhdENvZGVNZW51U2NlbmUpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldEJhdHRsZXJzKCk6IEJhdHRsZXJbXSB7IHJldHVybiB0aGlzLmJhdHRsZXJzOyB9XG5cbn0iLCIvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyBJTVBPUlRTICMjIyMjIyMjIyMjIyMjIyMjIyMjICovXG4vLyBJbXBvcnQgZnJvbSBXb2xmaWUyRCBvciB5b3VyIG93biBmaWxlcyBoZXJlXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IFN0YXJ0TWVudUJ1dHRvbkV2ZW50IH0gZnJvbSBcIi4uL0N1c3RvbWl6ZWRCdXR0b25cIjtcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9NYWluTWVudVNjZW5lXCI7XG5pbXBvcnQgSFc0U2NlbmUgZnJvbSBcIi4vQWJzdHJhY3RTY2VuZVwiO1xuaW1wb3J0IEJhdHRsZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZVN5c3RlbS9CYXR0bGVyXCI7XG4vKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyBDTEFTUyBERUZJTklUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjICovXG5cbi8vIFdlbGNvbWUgdG8gV29sZmllMkQhXG4vLyBUaGlzIGlzIGEgc2ltcGxlIHNhbXBsZSBzY2VuZSBzbyBzb21ldGhpbmcgZGlzcGxheXMgd2hlbiB5b3UgcnVuIHRoZSBnYW1lLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhcnRTY2VuZSBleHRlbmRzIEhXNFNjZW5lIHtcbiAgICAvKiAjIyMjIyMjIyMjIE1FTUJFUiBERUZJTklUSU9OUyAjIyMjIyMjIyMjKi9cblxuICAgIGxvYWRTY2VuZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gdGhpcy5sb2FkLnRpbGVtYXAoXCJtYXBcIiwgXCIuLi9kaXN0L3NoYWRvd01hemVfYXNzZXRzL3RpbGVtYXBzL3Rlc3QyLmpzb25cIik7XG5cbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKHRoaXMuYmFja2dyb3VuZEltYWdlS2V5LCBcInNoYWRvd01hemVfYXNzZXRzL2ltYWdlcy9zcGxhc2guanBnXCIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmxvYWQuZ2V0SW1hZ2UoXCJpbWFnZVwiKSk7XG4gICAgfVxuXG4gICAgLy8gc3RhcnRTY2VuZSgpIGlzIHdoZXJlIHlvdSBzaG91bGQgYnVpbGQgYW55IGdhbWUgb2JqZWN0cyB5b3Ugd2lzaCB0byBoYXZlIGluIHlvdXIgc2NlbmUsXG4gICAgLy8gb3Igd2hlcmUgeW91IHNob3VsZCBpbml0aWFsaXplIGFueSBvdGhlciB0aGluZ3MgeW91IHdpbGwgbmVlZCBpbiB5b3VyIHNjZW5lXG4gICAgLy8gT25jZSBhZ2FpbiwgdGhpcyBvY2N1cnMgc3RyaWN0bHkgYWZ0ZXIgbG9hZFNjZW5lKCksIHNvIGFueXRoaW5nIHlvdSBsb2FkZWQgdGhlcmUgd2lsbCBiZSBhdmFpbGFibGVcbiAgICBzdGFydFNjZW5lKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFkZFVJTGF5ZXIoICB0aGlzLkdhbWVMYXllcnMuQkFTRSlcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSB0aGlzLmFkZC5zcHJpdGUodGhpcy5iYWNrZ3JvdW5kSW1hZ2VLZXksICAgdGhpcy5HYW1lTGF5ZXJzLkJBU0UpO1xuICAgICAgICBsZXQgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UucG9zaXRpb24uc2V0KGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICAgIGxldCB0ZXh0T3B0aW9uID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDMwMCksXG4gICAgICAgICAgICB0ZXh0OiBcIlNoYWRvdyBNYXplXCIsXG4gICAgICAgICAgICBzaXplOiBuZXcgVmVjMig0MDAsIDEwMCksXG4gICAgICAgICAgICBmb250U2l6ZTogNjAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLlRSQU5TUEFSRU5ULFxuICAgICAgICAgICAgZm9udDogXCJBcHBsZSBDaGFuY2VyeVwiLFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTGFiZWwodGV4dE9wdGlvbik7XG4gICAgICAgIGxldCBidXR0b25PcHRpb24gPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgMTAwKSxcbiAgICAgICAgICAgIHRleHQ6IFN0YXJ0TWVudUJ1dHRvbkV2ZW50LlNUQVJUX0dBTUUsXG4gICAgICAgICAgICBzaXplOiBuZXcgVmVjMigzMDAsIDUwKSxcbiAgICAgICAgICAgIHRleHRDb2xvcjogQ29sb3IuUFVSUExFLFxuICAgICAgICAgICAgYnV0dG9uTmFtZTogXCJTdGFydCBHYW1lXCIsXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRCdXR0b25zKGJ1dHRvbk9wdGlvbik7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZVNjZW5lKGRlbHRhVDogbnVtYmVyKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XG4gICAgICAgICAgICBjb25zdCBnYW1lRXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KGdhbWVFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHB1YmxpYyBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTdGFydE1lbnVCdXR0b25FdmVudC5TVEFSVF9HQU1FOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShNYWluTWVudSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaWMgZ2V0QmF0dGxlcnMoKTogQmF0dGxlcltdIHsgcmV0dXJuIHRoaXMuYmF0dGxlcnM7IH1cblxufSIsImNvbnN0IGhlbHBUZXh0PVwiVGhlIHByaW5jZeKAmXMgZ29hbCBpcyB0byBtYWtlIGl0IG91dCBvZiB0aGUgbWF6ZSBhbGl2ZSEgSGUgaGFzIGEgc3dvcmQgYW5kIHNoaWVsZCB0byBoZWxwIGhpbSBkbyBzbywgYXMgd2VsbCBhcyBhbiB1bHRpbWF0ZSBhYmlsaXR5IGluIHRoZSBmb3JtIG9mIGEgZmx5aW5nIHN3b3JkIHNsYXNoLiBVc2luZyB0aGUgYXR0YWNrIGJ1dHRvbiB3aWxsIHN3aW5nIGhpcyBzd29yZCBhdCB0aGUgcHJpbmNl4oCZcyBlbmVtaWVzIGluIGZyb250IG9mIGhpbSwgZGVhbGluZyBkYW1hZ2UuIFRvIHVzZSBoaXMgc2hpZWxkLCBob2xkIGRvd24gdGhlIHNoaWVsZCBidXR0b24gdG8gYWJzb3JiIGluY29taW5nIGRhbWFnZS4gQmUgY2FyZWZ1bCB0aG91Z2gsIHRoZSBzaGllbGQgd2lsbCBnbyBvbiBjb29sLWRvd24gaWYgaXQgdGFrZXMgdG9vIG11Y2ggZGFtYWdlLiBZb3UgY2FuIGFsc28gcGFycnkgYXR0YWNrcyBieSBwcmVzc2luZyB0aGUgc2hpZWxkIGJ1dHRvbiByaWdodCB3aGVuIGFuIGF0dGFjayB3aWxsIGhpdCB5b3UuIFRoaXMgd2lsbCByZWJvdW5kIHJhbmdlZCBhdHRhY2tzLCBhbmQgc3R1biBtZWxlZSBlbmVtaWVzLlwiXG5jb25zdCBjb250cm9sVGV4dD1cIlcgLSBNb3ZlIFVwXFxuQSAtIE1vdmUgTGVmdFxcblMgLSBNb3ZlIERvd25cXG5EIC0gTW92ZSBSaWdodFxcbkogLSBBdHRhY2tcXG5LIC0gU2hpZWxkXFxuVSAtIFN3b3JkIFNsYXNoXFxuRXNjIC0gUGF1c2UgYW5kIE1lbnVcXG5OdW1iZXIgLSBVc2UgSXRlbXNcIjtcbmZ1bmN0aW9uIGJ1aWxkQ29udHJvbFRleHQoKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgY29uc3QgbGluZXMgPSBjb250cm9sVGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgLy8gY29uc3Qga2V5VmFsdWVzQXJyYXkgPSBsaW5lcy5tYXAobGluZSA9PiBsaW5lLnNwbGl0KCcgLSAnKVswXSk7XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuZnVuY3Rpb24gYnVpbGRIZWxwVGV4dCgpOiBBcnJheTxzdHJpbmc+IHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSBoZWxwVGV4dFxuICAgIGNvbnN0IE1BWF9MSU5FX0xFTkdUSCA9IDcwO1xuICAgIGNvbnN0IGxpbmVzID0gcGFyYWdyYXBoLnNwbGl0KFwiIFwiKTtcbiAgICBsZXQgY3VycmVudExpbmUgPSBcIlwiO1xuICAgIGNvbnN0IHJlc3VsdCA9IGxpbmVzLnJlZHVjZSgoYWNjLCB3b3JkKSA9PiB7XG4gICAgICBpZiAoY3VycmVudExpbmUubGVuZ3RoICsgd29yZC5sZW5ndGggKyAxID4gTUFYX0xJTkVfTEVOR1RIKSB7XG4gICAgICAgIGFjYy5wdXNoKGN1cnJlbnRMaW5lLnRyaW0oKSk7XG4gICAgICAgIGN1cnJlbnRMaW5lID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRMaW5lICs9IGAke3dvcmR9IGA7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTsgXG4gICAgcmVzdWx0LnB1c2goY3VycmVudExpbmUudHJpbSgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNvbnN0IGNvbnRyb2xUZXh0QXJyYXkgPSBidWlsZENvbnRyb2xUZXh0KCk7XG5leHBvcnQgY29uc3QgaGVscFRleHRBcnJheSA9YnVpbGRIZWxwVGV4dCgpO1xuXG4iLCJpbXBvcnQgR2FtZSBmcm9tIFwiLi9Xb2xmaWUyRC9Mb29wL0dhbWVcIjtcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9kZW1vR2FtZS9TY2VuZXMvTWFpbk1lbnVTY2VuZVwiO1xuaW1wb3J0IHsgUGxheWVySW5wdXQgfSBmcm9tIFwiLi9kZW1vR2FtZS9BSS9QbGF5ZXIvUGxheWVyQ29udHJvbGxlclwiO1xuaW1wb3J0IGRlZmF1bHRfc2NlbmUgZnJvbSBcIi4vZGVmYXVsdF9zY2VuZVwiO1xuLy8gaW1wb3J0IE1haW5IVzRTY2VuZSBmcm9tIFwiLi9kZW1vR2FtZS9TY2VuZXMvTWFpbkhXNFNjZW5lXCI7XG5pbXBvcnQgSW50cm9MZXZlbFNjZW5lIGZyb20gXCIuL2RlbW9HYW1lL1NjZW5lcy9JbnRyb0xldmVsU2NlbmVcIjtcbmltcG9ydCBTdGFydFNjZW5lIGZyb20gXCIuL2RlbW9HYW1lL1NjZW5lcy9TdGFydFNjZW5lXCI7XG5pbXBvcnQgQ29udHJvbFNjZW5lIGZyb20gXCIuL2RlbW9HYW1lL1NjZW5lcy9Db250cm9sU2NlbmVcIjtcbmltcG9ydCBIZWxwU2NlbmUgZnJvbSBcIi4vZGVtb0dhbWUvU2NlbmVzL0hlbHBTY2VuZVwiO1xuaW1wb3J0IFNlbGVjdExldmVsTWVudVNjZW5lIGZyb20gXCIuL2RlbW9HYW1lL1NjZW5lcy9TZWxlY3RMZXZlbE1lbnVTY2VuZVwiO1xuaW1wb3J0IEJ1YmJsZVNoYWRlclR5cGUgZnJvbSBcIi4vZGVtb0dhbWUvU2hhZGVycy9CdWJibGVTaGFkZXJUeXBlXCI7XG5pbXBvcnQgTGFzZXJTaGFkZXJUeXBlIGZyb20gXCIuL2RlbW9HYW1lL1NoYWRlcnMvTGFzZXJTaGFkZXJUeXBlXCI7XG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xuaW1wb3J0IHsgVXNlSXRlbUlucHV0IH0gZnJvbSBcIi4vZGVtb0dhbWUvQUkvUGxheWVyL1BsYXllckNvbnRyb2xsZXJcIjtcbmltcG9ydCBDaGVhdENvZGVNZW51U2NlbmUgZnJvbSBcIi4vZGVtb0dhbWUvU2NlbmVzL0NoZWF0Q29kZU1lbnVTY2VuZVwiO1xuLy8gVGhlIG1haW4gZnVuY3Rpb24gaXMgeW91ciBlbnRyeXBvaW50IGludG8gV29sZmllMkQuIFNwZWNpZnkgeW91ciBmaXJzdCBzY2VuZSBhbmQgYW55IG9wdGlvbnMgaGVyZS5cbihmdW5jdGlvbiBtYWluKCkge1xuICAgIC8vIFJ1biBhbnkgdGVzdHNcbiAgICBydW5UZXN0cygpO1xuXG4gICAgLy8gU2V0IHVwIG9wdGlvbnMgZm9yIG91ciBnYW1lXG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgIGNhbnZhc1NpemU6IHsgeDogMTAyNCwgeTogMTAyNCB9LCAgICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgZ2FtZVxuICAgICAgICBjbGVhckNvbG9yOiB7IHI6IDAuMSwgZzogMC4xLCBiOiAwLjEgfSwgICAvLyBUaGUgY29sb3IgdGhlIGdhbWUgY2xlYXJzIHRvXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBuYW1lOiBQbGF5ZXJJbnB1dC5NT1ZFX1VQLCBrZXlzOiBbXCJ3XCJdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFBsYXllcklucHV0Lk1PVkVfRE9XTiwga2V5czogW1wic1wiXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBQbGF5ZXJJbnB1dC5NT1ZFX0xFRlQsIGtleXM6IFtcImFcIl0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogUGxheWVySW5wdXQuTU9WRV9SSUdIVCwga2V5czogW1wiZFwiXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBQbGF5ZXJJbnB1dC5QSUNLVVBfSVRFTSwga2V5czogW1wiZVwiXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBQbGF5ZXJJbnB1dC5EUk9QX0lURU0sIGtleXM6IFtcInFcIl0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogUGxheWVySW5wdXQuQVRUQUNLSU5HLCBrZXlzOiBbXCJqXCJdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFBsYXllcklucHV0LlNISUVMRElORywga2V5czogW1wia1wiXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBQbGF5ZXJJbnB1dC5VTFRJTUFURSwga2V5czogW1widVwiXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInNsb3QyXCIsIGtleXM6IFtcIjJcIl0gfSxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gdXNlV2ViR0w6IHRydWUsICAgXG4gICAgICAgIHVzZVdlYkdMOiBmYWxzZSwgICAgICAgICAgICAgICAgICAvLyBUZWxsIHRoZSBnYW1lIHdlIHdhbnQgdG8gdXNlIHdlYmdsXG4gICAgICAgIHNob3dEZWJ1ZzogZmFsc2UsICAgICAgICAgICAgICAgICAgICAvLyBXaGV0aGVyIHRvIHNob3cgZGVidWcgbWVzc2FnZXMuIFlvdSBjYW4gY2hhbmdlIHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudFxuICAgIH1cblxuICAgIC8vIFNldCB1cCBjdXN0b20gcmVnaXN0cmllc1xuICAgIC8vIFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oXG4gICAgLy8gICAgIEJ1YmJsZVNoYWRlclR5cGUuS0VZLCAgIC8vIFRoZSBrZXkgb2YgdGhlIHNoYWRlciBwcm9ncmFtXG4gICAgLy8gICAgIEJ1YmJsZVNoYWRlclR5cGUsICAgICAgICAgICAvLyBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHNoYWRlciBwcm9ncmFtXG4gICAgLy8gICAgIEJ1YmJsZVNoYWRlclR5cGUuVlNIQURFUiwgICAvLyBUaGUgcGF0aCB0byB0aGUgdmVydGV4IHNoYWRlclxuICAgIC8vICAgICBCdWJibGVTaGFkZXJUeXBlLkZTSEFERVIpOyAgLy8gdGhlIHBhdGggdG8gdGhlIGZyYWdtZW50IHNoYWRlciovXG5cbiAgICAvLyBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFxuICAgIC8vICAgICBMYXNlclNoYWRlclR5cGUuS0VZLFxuICAgIC8vICAgICBMYXNlclNoYWRlclR5cGUsXG4gICAgLy8gICAgIExhc2VyU2hhZGVyVHlwZS5WU0hBREVSLFxuICAgIC8vICAgICBMYXNlclNoYWRlclR5cGUuRlNIQURFUlxuICAgIC8vICk7XG4gICAgLy8gQ3JlYXRlIGEgZ2FtZSB3aXRoIHRoZSBvcHRpb25zIHNwZWNpZmllZFxuICAgIGNvbnN0IGdhbWUgPSBuZXcgR2FtZShvcHRpb25zKTtcbiAgICAvLyBTdGFydCBvdXIgZ2FtZVxuICAgIGdhbWUuc3RhcnQoSW50cm9MZXZlbFNjZW5lLCB7fSk7XG4gICAgLy8gZ2FtZS5zdGFydChIZWxwU2NlbmUsIHt9KTtcbiAgICAvLyBnYW1lLnN0YXJ0KENvbnRyb2xTY2VuZSx7fSk7XG4gICAgLy8gZ2FtZS5zdGFydChTdGFydFNjZW5lLCB7fSk7XG4gICAgLy8gZ2FtZS5zdGFydChDaGVhdENvZGVNZW51U2NlbmUse30pO1xuICAgIC8vIGdhbWUuc3RhcnQoU2VsZWN0TGV2ZWxNZW51U2NlbmUse30pO1xuICAgIC8vIGdhbWUuc3RhcnQoTWFpbk1lbnUsIHt9KTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHJ1blRlc3RzKCkgeyB9OyJdfQ==
